/* soapC.cpp
   Generated by gSOAP 2.7.12 from dcm.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/
#include "stdafx.h"
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.12 2009-05-22 08:50:25 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_in_xsd__byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__historyType:
		return soap_in_ns1__historyType(soap, NULL, NULL, "ns1:historyType");
	case SOAP_TYPE_ns1__actionLogType:
		return soap_in_ns1__actionLogType(soap, NULL, NULL, "ns1:actionLogType");
	case SOAP_TYPE_ns1__customEventType:
		return soap_in_ns1__customEventType(soap, NULL, NULL, "ns1:customEventType");
	case SOAP_TYPE_ns1__conditionOperator:
		return soap_in_ns1__conditionOperator(soap, NULL, NULL, "ns1:conditionOperator");
	case SOAP_TYPE_ns1__entityType:
		return soap_in_ns1__entityType(soap, NULL, NULL, "ns1:entityType");
	case SOAP_TYPE_ns1__metricType:
		return soap_in_ns1__metricType(soap, NULL, NULL, "ns1:metricType");
	case SOAP_TYPE_ns1__globalProperty:
		return soap_in_ns1__globalProperty(soap, NULL, NULL, "ns1:globalProperty");
	case SOAP_TYPE_ns1__predefinedEventType:
		return soap_in_ns1__predefinedEventType(soap, NULL, NULL, "ns1:predefinedEventType");
	case SOAP_TYPE_ns1__entityProperty:
		return soap_in_ns1__entityProperty(soap, NULL, NULL, "ns1:entityProperty");
	case SOAP_TYPE_ns1__day:
		return soap_in_ns1__day(soap, NULL, NULL, "ns1:day");
	case SOAP_TYPE_ns1__policyType:
		return soap_in_ns1__policyType(soap, NULL, NULL, "ns1:policyType");
	case SOAP_TYPE_ns1__aggregationLevel:
		return soap_in_ns1__aggregationLevel(soap, NULL, NULL, "ns1:aggregationLevel");
	case SOAP_TYPE_ns1__queryType:
		return soap_in_ns1__queryType(soap, NULL, NULL, "ns1:queryType");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__unsubscribeEventHandlerResponse:
		return soap_in_ns1__unsubscribeEventHandlerResponse(soap, NULL, NULL, "ns1:unsubscribeEventHandlerResponse");
	case SOAP_TYPE_ns1__unsubscribeEventHandler:
		return soap_in_ns1__unsubscribeEventHandler(soap, NULL, NULL, "ns1:unsubscribeEventHandler");
	case SOAP_TYPE_ns1__getEntityPropertiesResponse:
		return soap_in_ns1__getEntityPropertiesResponse(soap, NULL, NULL, "ns1:getEntityPropertiesResponse");
	case SOAP_TYPE_ns1__getEntityProperties:
		return soap_in_ns1__getEntityProperties(soap, NULL, NULL, "ns1:getEntityProperties");
	case SOAP_TYPE_ns1__getEventStateResponse:
		return soap_in_ns1__getEventStateResponse(soap, NULL, NULL, "ns1:getEventStateResponse");
	case SOAP_TYPE_ns1__getEventState:
		return soap_in_ns1__getEventState(soap, NULL, NULL, "ns1:getEventState");
	case SOAP_TYPE_ns1__associateEntityResponse:
		return soap_in_ns1__associateEntityResponse(soap, NULL, NULL, "ns1:associateEntityResponse");
	case SOAP_TYPE_ns1__associateEntity:
		return soap_in_ns1__associateEntity(soap, NULL, NULL, "ns1:associateEntity");
	case SOAP_TYPE_ns1__getPolicyHistoryResponse:
		return soap_in_ns1__getPolicyHistoryResponse(soap, NULL, NULL, "ns1:getPolicyHistoryResponse");
	case SOAP_TYPE_ns1__getPolicyHistory:
		return soap_in_ns1__getPolicyHistory(soap, NULL, NULL, "ns1:getPolicyHistory");
	case SOAP_TYPE_ns1__getActionLogRecordsResponse:
		return soap_in_ns1__getActionLogRecordsResponse(soap, NULL, NULL, "ns1:getActionLogRecordsResponse");
	case SOAP_TYPE_ns1__getActionLogRecords:
		return soap_in_ns1__getActionLogRecords(soap, NULL, NULL, "ns1:getActionLogRecords");
	case SOAP_TYPE_ns1__setPolicyStateResponse:
		return soap_in_ns1__setPolicyStateResponse(soap, NULL, NULL, "ns1:setPolicyStateResponse");
	case SOAP_TYPE_ns1__setPolicyState:
		return soap_in_ns1__setPolicyState(soap, NULL, NULL, "ns1:setPolicyState");
	case SOAP_TYPE_ns1__policyData:
		return soap_in_ns1__policyData(soap, NULL, NULL, "ns1:policyData");
	case SOAP_TYPE_ns1__getPolicyDataResponse:
		return soap_in_ns1__getPolicyDataResponse(soap, NULL, NULL, "ns1:getPolicyDataResponse");
	case SOAP_TYPE_ns1__getPolicyData:
		return soap_in_ns1__getPolicyData(soap, NULL, NULL, "ns1:getPolicyData");
	case SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse:
		return soap_in_ns1__getMetricAggregationPeriodListResponse(soap, NULL, NULL, "ns1:getMetricAggregationPeriodListResponse");
	case SOAP_TYPE_ns1__getMetricAggregationPeriodList:
		return soap_in_ns1__getMetricAggregationPeriodList(soap, NULL, NULL, "ns1:getMetricAggregationPeriodList");
	case SOAP_TYPE_ns1__defineCustomEventResponse:
		return soap_in_ns1__defineCustomEventResponse(soap, NULL, NULL, "ns1:defineCustomEventResponse");
	case SOAP_TYPE_ns1__defineCustomEvent:
		return soap_in_ns1__defineCustomEvent(soap, NULL, NULL, "ns1:defineCustomEvent");
	case SOAP_TYPE_ns1__enumerateEntitiesResponse:
		return soap_in_ns1__enumerateEntitiesResponse(soap, NULL, NULL, "ns1:enumerateEntitiesResponse");
	case SOAP_TYPE_ns1__enumerateEntities:
		return soap_in_ns1__enumerateEntities(soap, NULL, NULL, "ns1:enumerateEntities");
	case SOAP_TYPE_ns1__getCollectionStateResponse:
		return soap_in_ns1__getCollectionStateResponse(soap, NULL, NULL, "ns1:getCollectionStateResponse");
	case SOAP_TYPE_ns1__getCollectionState:
		return soap_in_ns1__getCollectionState(soap, NULL, NULL, "ns1:getCollectionState");
	case SOAP_TYPE_ns1__deleteSecretKeyResponse:
		return soap_in_ns1__deleteSecretKeyResponse(soap, NULL, NULL, "ns1:deleteSecretKeyResponse");
	case SOAP_TYPE_ns1__deleteSecretKey:
		return soap_in_ns1__deleteSecretKey(soap, NULL, NULL, "ns1:deleteSecretKey");
	case SOAP_TYPE_ns1__unsubscribePredefinedEventResponse:
		return soap_in_ns1__unsubscribePredefinedEventResponse(soap, NULL, NULL, "ns1:unsubscribePredefinedEventResponse");
	case SOAP_TYPE_ns1__unsubscribePredefinedEvent:
		return soap_in_ns1__unsubscribePredefinedEvent(soap, NULL, NULL, "ns1:unsubscribePredefinedEvent");
	case SOAP_TYPE_ns1__updateCustomEventResponse:
		return soap_in_ns1__updateCustomEventResponse(soap, NULL, NULL, "ns1:updateCustomEventResponse");
	case SOAP_TYPE_ns1__updateCustomEvent:
		return soap_in_ns1__updateCustomEvent(soap, NULL, NULL, "ns1:updateCustomEvent");
	case SOAP_TYPE_ns1__getPolicyStateResponse:
		return soap_in_ns1__getPolicyStateResponse(soap, NULL, NULL, "ns1:getPolicyStateResponse");
	case SOAP_TYPE_ns1__getPolicyState:
		return soap_in_ns1__getPolicyState(soap, NULL, NULL, "ns1:getPolicyState");
	case SOAP_TYPE_ns1__enumeratePoliciesResponse:
		return soap_in_ns1__enumeratePoliciesResponse(soap, NULL, NULL, "ns1:enumeratePoliciesResponse");
	case SOAP_TYPE_ns1__enumeratePolicies:
		return soap_in_ns1__enumeratePolicies(soap, NULL, NULL, "ns1:enumeratePolicies");
	case SOAP_TYPE_ns1__enumerateCustomEventsResponse:
		return soap_in_ns1__enumerateCustomEventsResponse(soap, NULL, NULL, "ns1:enumerateCustomEventsResponse");
	case SOAP_TYPE_ns1__enumerateCustomEvents:
		return soap_in_ns1__enumerateCustomEvents(soap, NULL, NULL, "ns1:enumerateCustomEvents");
	case SOAP_TYPE_ns1__getPredefinedEventTypesResponse:
		return soap_in_ns1__getPredefinedEventTypesResponse(soap, NULL, NULL, "ns1:getPredefinedEventTypesResponse");
	case SOAP_TYPE_ns1__getPredefinedEventTypes:
		return soap_in_ns1__getPredefinedEventTypes(soap, NULL, NULL, "ns1:getPredefinedEventTypes");
	case SOAP_TYPE_ns1__customEventData:
		return soap_in_ns1__customEventData(soap, NULL, NULL, "ns1:customEventData");
	case SOAP_TYPE_ns1__getCustomEventDataResponse:
		return soap_in_ns1__getCustomEventDataResponse(soap, NULL, NULL, "ns1:getCustomEventDataResponse");
	case SOAP_TYPE_ns1__getCustomEventData:
		return soap_in_ns1__getCustomEventData(soap, NULL, NULL, "ns1:getCustomEventData");
	case SOAP_TYPE_ns1__getEventHandlerResponse:
		return soap_in_ns1__getEventHandlerResponse(soap, NULL, NULL, "ns1:getEventHandlerResponse");
	case SOAP_TYPE_ns1__getEventHandler:
		return soap_in_ns1__getEventHandler(soap, NULL, NULL, "ns1:getEventHandler");
	case SOAP_TYPE_ns1__addEntityResponse:
		return soap_in_ns1__addEntityResponse(soap, NULL, NULL, "ns1:addEntityResponse");
	case SOAP_TYPE_ns1__addEntity:
		return soap_in_ns1__addEntity(soap, NULL, NULL, "ns1:addEntity");
	case SOAP_TYPE_ns1__getMetricDataResponse:
		return soap_in_ns1__getMetricDataResponse(soap, NULL, NULL, "ns1:getMetricDataResponse");
	case SOAP_TYPE_ns1__getMetricData:
		return soap_in_ns1__getMetricData(soap, NULL, NULL, "ns1:getMetricData");
	case SOAP_TYPE_ns1__disassociateEntityResponse:
		return soap_in_ns1__disassociateEntityResponse(soap, NULL, NULL, "ns1:disassociateEntityResponse");
	case SOAP_TYPE_ns1__disassociateEntity:
		return soap_in_ns1__disassociateEntity(soap, NULL, NULL, "ns1:disassociateEntity");
	case SOAP_TYPE_ns1__removeCustomEventResponse:
		return soap_in_ns1__removeCustomEventResponse(soap, NULL, NULL, "ns1:removeCustomEventResponse");
	case SOAP_TYPE_ns1__removeCustomEvent:
		return soap_in_ns1__removeCustomEvent(soap, NULL, NULL, "ns1:removeCustomEvent");
	case SOAP_TYPE_ns1__submitSecretKeyResponse:
		return soap_in_ns1__submitSecretKeyResponse(soap, NULL, NULL, "ns1:submitSecretKeyResponse");
	case SOAP_TYPE_ns1__submitSecretKey:
		return soap_in_ns1__submitSecretKey(soap, NULL, NULL, "ns1:submitSecretKey");
	case SOAP_TYPE_ns1__setEntityPropertiesResponse:
		return soap_in_ns1__setEntityPropertiesResponse(soap, NULL, NULL, "ns1:setEntityPropertiesResponse");
	case SOAP_TYPE_ns1__property:
		return soap_in_ns1__property(soap, NULL, NULL, "ns1:property");
	case SOAP_TYPE_ns1__setEntityProperties:
		return soap_in_ns1__setEntityProperties(soap, NULL, NULL, "ns1:setEntityProperties");
	case SOAP_TYPE_ns1__setEventStateResponse:
		return soap_in_ns1__setEventStateResponse(soap, NULL, NULL, "ns1:setEventStateResponse");
	case SOAP_TYPE_ns1__setEventState:
		return soap_in_ns1__setEventState(soap, NULL, NULL, "ns1:setEventState");
	case SOAP_TYPE_ns1__subscribeEventHandlerResponse:
		return soap_in_ns1__subscribeEventHandlerResponse(soap, NULL, NULL, "ns1:subscribeEventHandlerResponse");
	case SOAP_TYPE_ns1__subscribeEventHandler:
		return soap_in_ns1__subscribeEventHandler(soap, NULL, NULL, "ns1:subscribeEventHandler");
	case SOAP_TYPE_ns1__getGlobalPropertyResponse:
		return soap_in_ns1__getGlobalPropertyResponse(soap, NULL, NULL, "ns1:getGlobalPropertyResponse");
	case SOAP_TYPE_ns1__getGlobalProperty:
		return soap_in_ns1__getGlobalProperty(soap, NULL, NULL, "ns1:getGlobalProperty");
	case SOAP_TYPE_ns1__updatePolicyResponse:
		return soap_in_ns1__updatePolicyResponse(soap, NULL, NULL, "ns1:updatePolicyResponse");
	case SOAP_TYPE_ns1__updatePolicy:
		return soap_in_ns1__updatePolicy(soap, NULL, NULL, "ns1:updatePolicy");
	case SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse:
		return soap_in_ns1__rediscoverNodeCapabilitiesResponse(soap, NULL, NULL, "ns1:rediscoverNodeCapabilitiesResponse");
	case SOAP_TYPE_ns1__rediscoverNodeCapabilities:
		return soap_in_ns1__rediscoverNodeCapabilities(soap, NULL, NULL, "ns1:rediscoverNodeCapabilities");
	case SOAP_TYPE_ns1__removeEntityResponse:
		return soap_in_ns1__removeEntityResponse(soap, NULL, NULL, "ns1:removeEntityResponse");
	case SOAP_TYPE_ns1__removeEntity:
		return soap_in_ns1__removeEntity(soap, NULL, NULL, "ns1:removeEntity");
	case SOAP_TYPE_ns1__setCollectionStateResponse:
		return soap_in_ns1__setCollectionStateResponse(soap, NULL, NULL, "ns1:setCollectionStateResponse");
	case SOAP_TYPE_ns1__setCollectionState:
		return soap_in_ns1__setCollectionState(soap, NULL, NULL, "ns1:setCollectionState");
	case SOAP_TYPE_ns1__setGlobalPropertyResponse:
		return soap_in_ns1__setGlobalPropertyResponse(soap, NULL, NULL, "ns1:setGlobalPropertyResponse");
	case SOAP_TYPE_ns1__setGlobalProperty:
		return soap_in_ns1__setGlobalProperty(soap, NULL, NULL, "ns1:setGlobalProperty");
	case SOAP_TYPE_ns1__subscribePredefinedEventResponse:
		return soap_in_ns1__subscribePredefinedEventResponse(soap, NULL, NULL, "ns1:subscribePredefinedEventResponse");
	case SOAP_TYPE_ns1__subscribePredefinedEvent:
		return soap_in_ns1__subscribePredefinedEvent(soap, NULL, NULL, "ns1:subscribePredefinedEvent");
	case SOAP_TYPE_ns1__getVersionResponse:
		return soap_in_ns1__getVersionResponse(soap, NULL, NULL, "ns1:getVersionResponse");
	case SOAP_TYPE_ns1__getVersion:
		return soap_in_ns1__getVersion(soap, NULL, NULL, "ns1:getVersion");
	case SOAP_TYPE_ns1__findEntitiesResponse:
		return soap_in_ns1__findEntitiesResponse(soap, NULL, NULL, "ns1:findEntitiesResponse");
	case SOAP_TYPE_ns1__findEntities:
		return soap_in_ns1__findEntities(soap, NULL, NULL, "ns1:findEntities");
	case SOAP_TYPE_ns1__exportHierarchyResponse:
		return soap_in_ns1__exportHierarchyResponse(soap, NULL, NULL, "ns1:exportHierarchyResponse");
	case SOAP_TYPE_ns1__exportHierarchy:
		return soap_in_ns1__exportHierarchy(soap, NULL, NULL, "ns1:exportHierarchy");
	case SOAP_TYPE_ns1__enumerateEventHandlersResponse:
		return soap_in_ns1__enumerateEventHandlersResponse(soap, NULL, NULL, "ns1:enumerateEventHandlersResponse");
	case SOAP_TYPE_ns1__enumerateEventHandlers:
		return soap_in_ns1__enumerateEventHandlers(soap, NULL, NULL, "ns1:enumerateEventHandlers");
	case SOAP_TYPE_ns1__aggregationPeriod:
		return soap_in_ns1__aggregationPeriod(soap, NULL, NULL, "ns1:aggregationPeriod");
	case SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse:
		return soap_in_ns1__getQueryAggregationPeriodListResponse(soap, NULL, NULL, "ns1:getQueryAggregationPeriodListResponse");
	case SOAP_TYPE_ns1__getQueryAggregationPeriodList:
		return soap_in_ns1__getQueryAggregationPeriodList(soap, NULL, NULL, "ns1:getQueryAggregationPeriodList");
	case SOAP_TYPE_ns1__isPolicyActiveResponse:
		return soap_in_ns1__isPolicyActiveResponse(soap, NULL, NULL, "ns1:isPolicyActiveResponse");
	case SOAP_TYPE_ns1__isPolicyActive:
		return soap_in_ns1__isPolicyActive(soap, NULL, NULL, "ns1:isPolicyActive");
	case SOAP_TYPE_ns1__importHierarchyResponse:
		return soap_in_ns1__importHierarchyResponse(soap, NULL, NULL, "ns1:importHierarchyResponse");
	case SOAP_TYPE_ns1__importHierarchy:
		return soap_in_ns1__importHierarchy(soap, NULL, NULL, "ns1:importHierarchy");
	case SOAP_TYPE_ns1__getNextDataResponse:
		return soap_in_ns1__getNextDataResponse(soap, NULL, NULL, "ns1:getNextDataResponse");
	case SOAP_TYPE_ns1__getNextData:
		return soap_in_ns1__getNextData(soap, NULL, NULL, "ns1:getNextData");
	case SOAP_TYPE_ns1__schedulePolicyResponse:
		return soap_in_ns1__schedulePolicyResponse(soap, NULL, NULL, "ns1:schedulePolicyResponse");
	case SOAP_TYPE_ns1__schedulePolicy:
		return soap_in_ns1__schedulePolicy(soap, NULL, NULL, "ns1:schedulePolicy");
	case SOAP_TYPE_ns1__setPolicyResponse:
		return soap_in_ns1__setPolicyResponse(soap, NULL, NULL, "ns1:setPolicyResponse");
	case SOAP_TYPE_ns1__setPolicy:
		return soap_in_ns1__setPolicy(soap, NULL, NULL, "ns1:setPolicy");
	case SOAP_TYPE_ns1__ptData:
		return soap_in_ns1__ptData(soap, NULL, NULL, "ns1:ptData");
	case SOAP_TYPE_ns1__enumerationData:
		return soap_in_ns1__enumerationData(soap, NULL, NULL, "ns1:enumerationData");
	case SOAP_TYPE_ns1__getQueryDataResponse:
		return soap_in_ns1__getQueryDataResponse(soap, NULL, NULL, "ns1:getQueryDataResponse");
	case SOAP_TYPE_ns1__getQueryData:
		return soap_in_ns1__getQueryData(soap, NULL, NULL, "ns1:getQueryData");
	case SOAP_TYPE_ns1__Exception:
		return soap_in_ns1__Exception(soap, NULL, NULL, "ns1:Exception");
	case SOAP_TYPE_ns1__removePolicyResponse:
		return soap_in_ns1__removePolicyResponse(soap, NULL, NULL, "ns1:removePolicyResponse");
	case SOAP_TYPE_ns1__removePolicy:
		return soap_in_ns1__removePolicy(soap, NULL, NULL, "ns1:removePolicy");
	case SOAP_TYPE_PointerTons1__updateCustomEventResponse:
		return soap_in_PointerTons1__updateCustomEventResponse(soap, NULL, NULL, "ns1:updateCustomEventResponse");
	case SOAP_TYPE_PointerTons1__updateCustomEvent:
		return soap_in_PointerTons1__updateCustomEvent(soap, NULL, NULL, "ns1:updateCustomEvent");
	case SOAP_TYPE_PointerTons1__unsubscribePredefinedEventResponse:
		return soap_in_PointerTons1__unsubscribePredefinedEventResponse(soap, NULL, NULL, "ns1:unsubscribePredefinedEventResponse");
	case SOAP_TYPE_PointerTons1__unsubscribePredefinedEvent:
		return soap_in_PointerTons1__unsubscribePredefinedEvent(soap, NULL, NULL, "ns1:unsubscribePredefinedEvent");
	case SOAP_TYPE_PointerTons1__unsubscribeEventHandlerResponse:
		return soap_in_PointerTons1__unsubscribeEventHandlerResponse(soap, NULL, NULL, "ns1:unsubscribeEventHandlerResponse");
	case SOAP_TYPE_PointerTons1__unsubscribeEventHandler:
		return soap_in_PointerTons1__unsubscribeEventHandler(soap, NULL, NULL, "ns1:unsubscribeEventHandler");
	case SOAP_TYPE_PointerTons1__subscribePredefinedEventResponse:
		return soap_in_PointerTons1__subscribePredefinedEventResponse(soap, NULL, NULL, "ns1:subscribePredefinedEventResponse");
	case SOAP_TYPE_PointerTons1__subscribePredefinedEvent:
		return soap_in_PointerTons1__subscribePredefinedEvent(soap, NULL, NULL, "ns1:subscribePredefinedEvent");
	case SOAP_TYPE_PointerTons1__subscribeEventHandlerResponse:
		return soap_in_PointerTons1__subscribeEventHandlerResponse(soap, NULL, NULL, "ns1:subscribeEventHandlerResponse");
	case SOAP_TYPE_PointerTons1__subscribeEventHandler:
		return soap_in_PointerTons1__subscribeEventHandler(soap, NULL, NULL, "ns1:subscribeEventHandler");
	case SOAP_TYPE_PointerTons1__submitSecretKeyResponse:
		return soap_in_PointerTons1__submitSecretKeyResponse(soap, NULL, NULL, "ns1:submitSecretKeyResponse");
	case SOAP_TYPE_PointerTons1__submitSecretKey:
		return soap_in_PointerTons1__submitSecretKey(soap, NULL, NULL, "ns1:submitSecretKey");
	case SOAP_TYPE_PointerTons1__setPolicyStateResponse:
		return soap_in_PointerTons1__setPolicyStateResponse(soap, NULL, NULL, "ns1:setPolicyStateResponse");
	case SOAP_TYPE_PointerTons1__setPolicyState:
		return soap_in_PointerTons1__setPolicyState(soap, NULL, NULL, "ns1:setPolicyState");
	case SOAP_TYPE_PointerTons1__setGlobalPropertyResponse:
		return soap_in_PointerTons1__setGlobalPropertyResponse(soap, NULL, NULL, "ns1:setGlobalPropertyResponse");
	case SOAP_TYPE_PointerTons1__setGlobalProperty:
		return soap_in_PointerTons1__setGlobalProperty(soap, NULL, NULL, "ns1:setGlobalProperty");
	case SOAP_TYPE_PointerTons1__setEventStateResponse:
		return soap_in_PointerTons1__setEventStateResponse(soap, NULL, NULL, "ns1:setEventStateResponse");
	case SOAP_TYPE_PointerTons1__setEventState:
		return soap_in_PointerTons1__setEventState(soap, NULL, NULL, "ns1:setEventState");
	case SOAP_TYPE_PointerTons1__setEntityPropertiesResponse:
		return soap_in_PointerTons1__setEntityPropertiesResponse(soap, NULL, NULL, "ns1:setEntityPropertiesResponse");
	case SOAP_TYPE_PointerTons1__setEntityProperties:
		return soap_in_PointerTons1__setEntityProperties(soap, NULL, NULL, "ns1:setEntityProperties");
	case SOAP_TYPE_PointerTons1__setCollectionStateResponse:
		return soap_in_PointerTons1__setCollectionStateResponse(soap, NULL, NULL, "ns1:setCollectionStateResponse");
	case SOAP_TYPE_PointerTons1__setCollectionState:
		return soap_in_PointerTons1__setCollectionState(soap, NULL, NULL, "ns1:setCollectionState");
	case SOAP_TYPE_PointerTons1__schedulePolicyResponse:
		return soap_in_PointerTons1__schedulePolicyResponse(soap, NULL, NULL, "ns1:schedulePolicyResponse");
	case SOAP_TYPE_PointerTons1__schedulePolicy:
		return soap_in_PointerTons1__schedulePolicy(soap, NULL, NULL, "ns1:schedulePolicy");
	case SOAP_TYPE_PointerTons1__removePolicyResponse:
		return soap_in_PointerTons1__removePolicyResponse(soap, NULL, NULL, "ns1:removePolicyResponse");
	case SOAP_TYPE_PointerTons1__removePolicy:
		return soap_in_PointerTons1__removePolicy(soap, NULL, NULL, "ns1:removePolicy");
	case SOAP_TYPE_PointerTons1__removeEntityResponse:
		return soap_in_PointerTons1__removeEntityResponse(soap, NULL, NULL, "ns1:removeEntityResponse");
	case SOAP_TYPE_PointerTons1__removeEntity:
		return soap_in_PointerTons1__removeEntity(soap, NULL, NULL, "ns1:removeEntity");
	case SOAP_TYPE_PointerTons1__removeCustomEventResponse:
		return soap_in_PointerTons1__removeCustomEventResponse(soap, NULL, NULL, "ns1:removeCustomEventResponse");
	case SOAP_TYPE_PointerTons1__removeCustomEvent:
		return soap_in_PointerTons1__removeCustomEvent(soap, NULL, NULL, "ns1:removeCustomEvent");
	case SOAP_TYPE_PointerTons1__rediscoverNodeCapabilitiesResponse:
		return soap_in_PointerTons1__rediscoverNodeCapabilitiesResponse(soap, NULL, NULL, "ns1:rediscoverNodeCapabilitiesResponse");
	case SOAP_TYPE_PointerTons1__rediscoverNodeCapabilities:
		return soap_in_PointerTons1__rediscoverNodeCapabilities(soap, NULL, NULL, "ns1:rediscoverNodeCapabilities");
	case SOAP_TYPE_PointerTons1__isPolicyActiveResponse:
		return soap_in_PointerTons1__isPolicyActiveResponse(soap, NULL, NULL, "ns1:isPolicyActiveResponse");
	case SOAP_TYPE_PointerTons1__isPolicyActive:
		return soap_in_PointerTons1__isPolicyActive(soap, NULL, NULL, "ns1:isPolicyActive");
	case SOAP_TYPE_PointerTons1__importHierarchyResponse:
		return soap_in_PointerTons1__importHierarchyResponse(soap, NULL, NULL, "ns1:importHierarchyResponse");
	case SOAP_TYPE_PointerTons1__importHierarchy:
		return soap_in_PointerTons1__importHierarchy(soap, NULL, NULL, "ns1:importHierarchy");
	case SOAP_TYPE_PointerTons1__getQueryDataResponse:
		return soap_in_PointerTons1__getQueryDataResponse(soap, NULL, NULL, "ns1:getQueryDataResponse");
	case SOAP_TYPE_PointerTons1__getQueryData:
		return soap_in_PointerTons1__getQueryData(soap, NULL, NULL, "ns1:getQueryData");
	case SOAP_TYPE_PointerTons1__getQueryAggregationPeriodListResponse:
		return soap_in_PointerTons1__getQueryAggregationPeriodListResponse(soap, NULL, NULL, "ns1:getQueryAggregationPeriodListResponse");
	case SOAP_TYPE_PointerTons1__getQueryAggregationPeriodList:
		return soap_in_PointerTons1__getQueryAggregationPeriodList(soap, NULL, NULL, "ns1:getQueryAggregationPeriodList");
	case SOAP_TYPE_PointerTons1__getPredefinedEventTypesResponse:
		return soap_in_PointerTons1__getPredefinedEventTypesResponse(soap, NULL, NULL, "ns1:getPredefinedEventTypesResponse");
	case SOAP_TYPE_PointerTons1__getPredefinedEventTypes:
		return soap_in_PointerTons1__getPredefinedEventTypes(soap, NULL, NULL, "ns1:getPredefinedEventTypes");
	case SOAP_TYPE_PointerTons1__getPolicyStateResponse:
		return soap_in_PointerTons1__getPolicyStateResponse(soap, NULL, NULL, "ns1:getPolicyStateResponse");
	case SOAP_TYPE_PointerTons1__getPolicyState:
		return soap_in_PointerTons1__getPolicyState(soap, NULL, NULL, "ns1:getPolicyState");
	case SOAP_TYPE_PointerTons1__getPolicyHistoryResponse:
		return soap_in_PointerTons1__getPolicyHistoryResponse(soap, NULL, NULL, "ns1:getPolicyHistoryResponse");
	case SOAP_TYPE_PointerTons1__getPolicyHistory:
		return soap_in_PointerTons1__getPolicyHistory(soap, NULL, NULL, "ns1:getPolicyHistory");
	case SOAP_TYPE_PointerTons1__getPolicyDataResponse:
		return soap_in_PointerTons1__getPolicyDataResponse(soap, NULL, NULL, "ns1:getPolicyDataResponse");
	case SOAP_TYPE_PointerTons1__getPolicyData:
		return soap_in_PointerTons1__getPolicyData(soap, NULL, NULL, "ns1:getPolicyData");
	case SOAP_TYPE_PointerTons1__getNextDataResponse:
		return soap_in_PointerTons1__getNextDataResponse(soap, NULL, NULL, "ns1:getNextDataResponse");
	case SOAP_TYPE_PointerTons1__getNextData:
		return soap_in_PointerTons1__getNextData(soap, NULL, NULL, "ns1:getNextData");
	case SOAP_TYPE_PointerTons1__getMetricDataResponse:
		return soap_in_PointerTons1__getMetricDataResponse(soap, NULL, NULL, "ns1:getMetricDataResponse");
	case SOAP_TYPE_PointerTons1__getMetricData:
		return soap_in_PointerTons1__getMetricData(soap, NULL, NULL, "ns1:getMetricData");
	case SOAP_TYPE_PointerTons1__getMetricAggregationPeriodListResponse:
		return soap_in_PointerTons1__getMetricAggregationPeriodListResponse(soap, NULL, NULL, "ns1:getMetricAggregationPeriodListResponse");
	case SOAP_TYPE_PointerTons1__getMetricAggregationPeriodList:
		return soap_in_PointerTons1__getMetricAggregationPeriodList(soap, NULL, NULL, "ns1:getMetricAggregationPeriodList");
	case SOAP_TYPE_PointerTons1__getGlobalPropertyResponse:
		return soap_in_PointerTons1__getGlobalPropertyResponse(soap, NULL, NULL, "ns1:getGlobalPropertyResponse");
	case SOAP_TYPE_PointerTons1__getGlobalProperty:
		return soap_in_PointerTons1__getGlobalProperty(soap, NULL, NULL, "ns1:getGlobalProperty");
	case SOAP_TYPE_PointerTons1__getEventStateResponse:
		return soap_in_PointerTons1__getEventStateResponse(soap, NULL, NULL, "ns1:getEventStateResponse");
	case SOAP_TYPE_PointerTons1__getEventState:
		return soap_in_PointerTons1__getEventState(soap, NULL, NULL, "ns1:getEventState");
	case SOAP_TYPE_PointerTons1__getEventHandlerResponse:
		return soap_in_PointerTons1__getEventHandlerResponse(soap, NULL, NULL, "ns1:getEventHandlerResponse");
	case SOAP_TYPE_PointerTons1__getEventHandler:
		return soap_in_PointerTons1__getEventHandler(soap, NULL, NULL, "ns1:getEventHandler");
	case SOAP_TYPE_PointerTons1__getEntityPropertiesResponse:
		return soap_in_PointerTons1__getEntityPropertiesResponse(soap, NULL, NULL, "ns1:getEntityPropertiesResponse");
	case SOAP_TYPE_PointerTons1__getEntityProperties:
		return soap_in_PointerTons1__getEntityProperties(soap, NULL, NULL, "ns1:getEntityProperties");
	case SOAP_TYPE_PointerTons1__getCustomEventDataResponse:
		return soap_in_PointerTons1__getCustomEventDataResponse(soap, NULL, NULL, "ns1:getCustomEventDataResponse");
	case SOAP_TYPE_PointerTons1__getCustomEventData:
		return soap_in_PointerTons1__getCustomEventData(soap, NULL, NULL, "ns1:getCustomEventData");
	case SOAP_TYPE_PointerTons1__getCollectionStateResponse:
		return soap_in_PointerTons1__getCollectionStateResponse(soap, NULL, NULL, "ns1:getCollectionStateResponse");
	case SOAP_TYPE_PointerTons1__getCollectionState:
		return soap_in_PointerTons1__getCollectionState(soap, NULL, NULL, "ns1:getCollectionState");
	case SOAP_TYPE_PointerTons1__getActionLogRecordsResponse:
		return soap_in_PointerTons1__getActionLogRecordsResponse(soap, NULL, NULL, "ns1:getActionLogRecordsResponse");
	case SOAP_TYPE_PointerTons1__getActionLogRecords:
		return soap_in_PointerTons1__getActionLogRecords(soap, NULL, NULL, "ns1:getActionLogRecords");
	case SOAP_TYPE_PointerTons1__findEntitiesResponse:
		return soap_in_PointerTons1__findEntitiesResponse(soap, NULL, NULL, "ns1:findEntitiesResponse");
	case SOAP_TYPE_PointerTons1__findEntities:
		return soap_in_PointerTons1__findEntities(soap, NULL, NULL, "ns1:findEntities");
	case SOAP_TYPE_PointerTons1__exportHierarchyResponse:
		return soap_in_PointerTons1__exportHierarchyResponse(soap, NULL, NULL, "ns1:exportHierarchyResponse");
	case SOAP_TYPE_PointerTons1__exportHierarchy:
		return soap_in_PointerTons1__exportHierarchy(soap, NULL, NULL, "ns1:exportHierarchy");
	case SOAP_TYPE_PointerTons1__enumeratePoliciesResponse:
		return soap_in_PointerTons1__enumeratePoliciesResponse(soap, NULL, NULL, "ns1:enumeratePoliciesResponse");
	case SOAP_TYPE_PointerTons1__enumeratePolicies:
		return soap_in_PointerTons1__enumeratePolicies(soap, NULL, NULL, "ns1:enumeratePolicies");
	case SOAP_TYPE_PointerTons1__enumerateEventHandlersResponse:
		return soap_in_PointerTons1__enumerateEventHandlersResponse(soap, NULL, NULL, "ns1:enumerateEventHandlersResponse");
	case SOAP_TYPE_PointerTons1__enumerateEventHandlers:
		return soap_in_PointerTons1__enumerateEventHandlers(soap, NULL, NULL, "ns1:enumerateEventHandlers");
	case SOAP_TYPE_PointerTons1__enumerateEntitiesResponse:
		return soap_in_PointerTons1__enumerateEntitiesResponse(soap, NULL, NULL, "ns1:enumerateEntitiesResponse");
	case SOAP_TYPE_PointerTons1__enumerateEntities:
		return soap_in_PointerTons1__enumerateEntities(soap, NULL, NULL, "ns1:enumerateEntities");
	case SOAP_TYPE_PointerTons1__enumerateCustomEventsResponse:
		return soap_in_PointerTons1__enumerateCustomEventsResponse(soap, NULL, NULL, "ns1:enumerateCustomEventsResponse");
	case SOAP_TYPE_PointerTons1__enumerateCustomEvents:
		return soap_in_PointerTons1__enumerateCustomEvents(soap, NULL, NULL, "ns1:enumerateCustomEvents");
	case SOAP_TYPE_PointerTons1__disassociateEntityResponse:
		return soap_in_PointerTons1__disassociateEntityResponse(soap, NULL, NULL, "ns1:disassociateEntityResponse");
	case SOAP_TYPE_PointerTons1__disassociateEntity:
		return soap_in_PointerTons1__disassociateEntity(soap, NULL, NULL, "ns1:disassociateEntity");
	case SOAP_TYPE_PointerTons1__deleteSecretKeyResponse:
		return soap_in_PointerTons1__deleteSecretKeyResponse(soap, NULL, NULL, "ns1:deleteSecretKeyResponse");
	case SOAP_TYPE_PointerTons1__deleteSecretKey:
		return soap_in_PointerTons1__deleteSecretKey(soap, NULL, NULL, "ns1:deleteSecretKey");
	case SOAP_TYPE_PointerTons1__defineCustomEventResponse:
		return soap_in_PointerTons1__defineCustomEventResponse(soap, NULL, NULL, "ns1:defineCustomEventResponse");
	case SOAP_TYPE_PointerTons1__defineCustomEvent:
		return soap_in_PointerTons1__defineCustomEvent(soap, NULL, NULL, "ns1:defineCustomEvent");
	case SOAP_TYPE_PointerTons1__associateEntityResponse:
		return soap_in_PointerTons1__associateEntityResponse(soap, NULL, NULL, "ns1:associateEntityResponse");
	case SOAP_TYPE_PointerTons1__associateEntity:
		return soap_in_PointerTons1__associateEntity(soap, NULL, NULL, "ns1:associateEntity");
	case SOAP_TYPE_PointerTons1__addEntityResponse:
		return soap_in_PointerTons1__addEntityResponse(soap, NULL, NULL, "ns1:addEntityResponse");
	case SOAP_TYPE_PointerTons1__addEntity:
		return soap_in_PointerTons1__addEntity(soap, NULL, NULL, "ns1:addEntity");
	case SOAP_TYPE_PointerTons1__updatePolicyResponse:
		return soap_in_PointerTons1__updatePolicyResponse(soap, NULL, NULL, "ns1:updatePolicyResponse");
	case SOAP_TYPE_PointerTons1__updatePolicy:
		return soap_in_PointerTons1__updatePolicy(soap, NULL, NULL, "ns1:updatePolicy");
	case SOAP_TYPE_PointerTons1__setPolicyResponse:
		return soap_in_PointerTons1__setPolicyResponse(soap, NULL, NULL, "ns1:setPolicyResponse");
	case SOAP_TYPE_PointerTons1__setPolicy:
		return soap_in_PointerTons1__setPolicy(soap, NULL, NULL, "ns1:setPolicy");
	case SOAP_TYPE_PointerTons1__getVersionResponse:
		return soap_in_PointerTons1__getVersionResponse(soap, NULL, NULL, "ns1:getVersionResponse");
	case SOAP_TYPE_PointerTons1__getVersion:
		return soap_in_PointerTons1__getVersion(soap, NULL, NULL, "ns1:getVersion");
	case SOAP_TYPE_PointerTons1__Exception:
		return soap_in_PointerTons1__Exception(soap, NULL, NULL, "ns1:Exception");
	case SOAP_TYPE_PointerTons1__historyType:
		return soap_in_PointerTons1__historyType(soap, NULL, NULL, "ns1:historyType");
	case SOAP_TYPE_PointerTons1__actionLogType:
		return soap_in_PointerTons1__actionLogType(soap, NULL, NULL, "ns1:actionLogType");
	case SOAP_TYPE_PointerTons1__policyData:
		return soap_in_PointerTons1__policyData(soap, NULL, NULL, "ns1:policyData");
	case SOAP_TYPE_PointerTons1__customEventType:
		return soap_in_PointerTons1__customEventType(soap, NULL, NULL, "ns1:customEventType");
	case SOAP_TYPE_PointerTons1__conditionOperator:
		return soap_in_PointerTons1__conditionOperator(soap, NULL, NULL, "ns1:conditionOperator");
	case SOAP_TYPE_PointerTons1__customEventData:
		return soap_in_PointerTons1__customEventData(soap, NULL, NULL, "ns1:customEventData");
	case SOAP_TYPE_PointerTons1__entityType:
		return soap_in_PointerTons1__entityType(soap, NULL, NULL, "ns1:entityType");
	case SOAP_TYPE_PointerTons1__metricType:
		return soap_in_PointerTons1__metricType(soap, NULL, NULL, "ns1:metricType");
	case SOAP_TYPE_PointerTons1__property:
		return soap_in_PointerTons1__property(soap, NULL, NULL, "ns1:property");
	case SOAP_TYPE_PointerTons1__globalProperty:
		return soap_in_PointerTons1__globalProperty(soap, NULL, NULL, "ns1:globalProperty");
	case SOAP_TYPE_PointerTons1__entityProperty:
		return soap_in_PointerTons1__entityProperty(soap, NULL, NULL, "ns1:entityProperty");
	case SOAP_TYPE_PointerTons1__aggregationPeriod:
		return soap_in_PointerTons1__aggregationPeriod(soap, NULL, NULL, "ns1:aggregationPeriod");
	case SOAP_TYPE_PointerTons1__policyType:
		return soap_in_PointerTons1__policyType(soap, NULL, NULL, "ns1:policyType");
	case SOAP_TYPE_PointerTons1__ptData:
		return soap_in_PointerTons1__ptData(soap, NULL, NULL, "ns1:ptData");
	case SOAP_TYPE_PointerTons1__enumerationData:
		return soap_in_PointerTons1__enumerationData(soap, NULL, NULL, "ns1:enumerationData");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__aggregationLevel:
		return soap_in_PointerTons1__aggregationLevel(soap, NULL, NULL, "ns1:aggregationLevel");
	case SOAP_TYPE_PointerTons1__queryType:
		return soap_in_PointerTons1__queryType(soap, NULL, NULL, "ns1:queryType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unsubscribeEventHandlerResponse"))
		{	*type = SOAP_TYPE_ns1__unsubscribeEventHandlerResponse;
			return soap_in_ns1__unsubscribeEventHandlerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unsubscribeEventHandler"))
		{	*type = SOAP_TYPE_ns1__unsubscribeEventHandler;
			return soap_in_ns1__unsubscribeEventHandler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEntityPropertiesResponse"))
		{	*type = SOAP_TYPE_ns1__getEntityPropertiesResponse;
			return soap_in_ns1__getEntityPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEntityProperties"))
		{	*type = SOAP_TYPE_ns1__getEntityProperties;
			return soap_in_ns1__getEntityProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventStateResponse"))
		{	*type = SOAP_TYPE_ns1__getEventStateResponse;
			return soap_in_ns1__getEventStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventState"))
		{	*type = SOAP_TYPE_ns1__getEventState;
			return soap_in_ns1__getEventState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:associateEntityResponse"))
		{	*type = SOAP_TYPE_ns1__associateEntityResponse;
			return soap_in_ns1__associateEntityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:associateEntity"))
		{	*type = SOAP_TYPE_ns1__associateEntity;
			return soap_in_ns1__associateEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPolicyHistoryResponse"))
		{	*type = SOAP_TYPE_ns1__getPolicyHistoryResponse;
			return soap_in_ns1__getPolicyHistoryResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPolicyHistory"))
		{	*type = SOAP_TYPE_ns1__getPolicyHistory;
			return soap_in_ns1__getPolicyHistory(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getActionLogRecordsResponse"))
		{	*type = SOAP_TYPE_ns1__getActionLogRecordsResponse;
			return soap_in_ns1__getActionLogRecordsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getActionLogRecords"))
		{	*type = SOAP_TYPE_ns1__getActionLogRecords;
			return soap_in_ns1__getActionLogRecords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPolicyStateResponse"))
		{	*type = SOAP_TYPE_ns1__setPolicyStateResponse;
			return soap_in_ns1__setPolicyStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPolicyState"))
		{	*type = SOAP_TYPE_ns1__setPolicyState;
			return soap_in_ns1__setPolicyState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:policyData"))
		{	*type = SOAP_TYPE_ns1__policyData;
			return soap_in_ns1__policyData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPolicyDataResponse"))
		{	*type = SOAP_TYPE_ns1__getPolicyDataResponse;
			return soap_in_ns1__getPolicyDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPolicyData"))
		{	*type = SOAP_TYPE_ns1__getPolicyData;
			return soap_in_ns1__getPolicyData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetricAggregationPeriodListResponse"))
		{	*type = SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse;
			return soap_in_ns1__getMetricAggregationPeriodListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetricAggregationPeriodList"))
		{	*type = SOAP_TYPE_ns1__getMetricAggregationPeriodList;
			return soap_in_ns1__getMetricAggregationPeriodList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineCustomEventResponse"))
		{	*type = SOAP_TYPE_ns1__defineCustomEventResponse;
			return soap_in_ns1__defineCustomEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:defineCustomEvent"))
		{	*type = SOAP_TYPE_ns1__defineCustomEvent;
			return soap_in_ns1__defineCustomEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumerateEntitiesResponse"))
		{	*type = SOAP_TYPE_ns1__enumerateEntitiesResponse;
			return soap_in_ns1__enumerateEntitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumerateEntities"))
		{	*type = SOAP_TYPE_ns1__enumerateEntities;
			return soap_in_ns1__enumerateEntities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCollectionStateResponse"))
		{	*type = SOAP_TYPE_ns1__getCollectionStateResponse;
			return soap_in_ns1__getCollectionStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCollectionState"))
		{	*type = SOAP_TYPE_ns1__getCollectionState;
			return soap_in_ns1__getCollectionState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteSecretKeyResponse"))
		{	*type = SOAP_TYPE_ns1__deleteSecretKeyResponse;
			return soap_in_ns1__deleteSecretKeyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:deleteSecretKey"))
		{	*type = SOAP_TYPE_ns1__deleteSecretKey;
			return soap_in_ns1__deleteSecretKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unsubscribePredefinedEventResponse"))
		{	*type = SOAP_TYPE_ns1__unsubscribePredefinedEventResponse;
			return soap_in_ns1__unsubscribePredefinedEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:unsubscribePredefinedEvent"))
		{	*type = SOAP_TYPE_ns1__unsubscribePredefinedEvent;
			return soap_in_ns1__unsubscribePredefinedEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateCustomEventResponse"))
		{	*type = SOAP_TYPE_ns1__updateCustomEventResponse;
			return soap_in_ns1__updateCustomEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateCustomEvent"))
		{	*type = SOAP_TYPE_ns1__updateCustomEvent;
			return soap_in_ns1__updateCustomEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPolicyStateResponse"))
		{	*type = SOAP_TYPE_ns1__getPolicyStateResponse;
			return soap_in_ns1__getPolicyStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPolicyState"))
		{	*type = SOAP_TYPE_ns1__getPolicyState;
			return soap_in_ns1__getPolicyState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumeratePoliciesResponse"))
		{	*type = SOAP_TYPE_ns1__enumeratePoliciesResponse;
			return soap_in_ns1__enumeratePoliciesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumeratePolicies"))
		{	*type = SOAP_TYPE_ns1__enumeratePolicies;
			return soap_in_ns1__enumeratePolicies(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumerateCustomEventsResponse"))
		{	*type = SOAP_TYPE_ns1__enumerateCustomEventsResponse;
			return soap_in_ns1__enumerateCustomEventsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumerateCustomEvents"))
		{	*type = SOAP_TYPE_ns1__enumerateCustomEvents;
			return soap_in_ns1__enumerateCustomEvents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPredefinedEventTypesResponse"))
		{	*type = SOAP_TYPE_ns1__getPredefinedEventTypesResponse;
			return soap_in_ns1__getPredefinedEventTypesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getPredefinedEventTypes"))
		{	*type = SOAP_TYPE_ns1__getPredefinedEventTypes;
			return soap_in_ns1__getPredefinedEventTypes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:customEventData"))
		{	*type = SOAP_TYPE_ns1__customEventData;
			return soap_in_ns1__customEventData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomEventDataResponse"))
		{	*type = SOAP_TYPE_ns1__getCustomEventDataResponse;
			return soap_in_ns1__getCustomEventDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getCustomEventData"))
		{	*type = SOAP_TYPE_ns1__getCustomEventData;
			return soap_in_ns1__getCustomEventData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventHandlerResponse"))
		{	*type = SOAP_TYPE_ns1__getEventHandlerResponse;
			return soap_in_ns1__getEventHandlerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getEventHandler"))
		{	*type = SOAP_TYPE_ns1__getEventHandler;
			return soap_in_ns1__getEventHandler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addEntityResponse"))
		{	*type = SOAP_TYPE_ns1__addEntityResponse;
			return soap_in_ns1__addEntityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addEntity"))
		{	*type = SOAP_TYPE_ns1__addEntity;
			return soap_in_ns1__addEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetricDataResponse"))
		{	*type = SOAP_TYPE_ns1__getMetricDataResponse;
			return soap_in_ns1__getMetricDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getMetricData"))
		{	*type = SOAP_TYPE_ns1__getMetricData;
			return soap_in_ns1__getMetricData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:disassociateEntityResponse"))
		{	*type = SOAP_TYPE_ns1__disassociateEntityResponse;
			return soap_in_ns1__disassociateEntityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:disassociateEntity"))
		{	*type = SOAP_TYPE_ns1__disassociateEntity;
			return soap_in_ns1__disassociateEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeCustomEventResponse"))
		{	*type = SOAP_TYPE_ns1__removeCustomEventResponse;
			return soap_in_ns1__removeCustomEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeCustomEvent"))
		{	*type = SOAP_TYPE_ns1__removeCustomEvent;
			return soap_in_ns1__removeCustomEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:submitSecretKeyResponse"))
		{	*type = SOAP_TYPE_ns1__submitSecretKeyResponse;
			return soap_in_ns1__submitSecretKeyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:submitSecretKey"))
		{	*type = SOAP_TYPE_ns1__submitSecretKey;
			return soap_in_ns1__submitSecretKey(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setEntityPropertiesResponse"))
		{	*type = SOAP_TYPE_ns1__setEntityPropertiesResponse;
			return soap_in_ns1__setEntityPropertiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:property"))
		{	*type = SOAP_TYPE_ns1__property;
			return soap_in_ns1__property(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setEntityProperties"))
		{	*type = SOAP_TYPE_ns1__setEntityProperties;
			return soap_in_ns1__setEntityProperties(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setEventStateResponse"))
		{	*type = SOAP_TYPE_ns1__setEventStateResponse;
			return soap_in_ns1__setEventStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setEventState"))
		{	*type = SOAP_TYPE_ns1__setEventState;
			return soap_in_ns1__setEventState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeEventHandlerResponse"))
		{	*type = SOAP_TYPE_ns1__subscribeEventHandlerResponse;
			return soap_in_ns1__subscribeEventHandlerResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribeEventHandler"))
		{	*type = SOAP_TYPE_ns1__subscribeEventHandler;
			return soap_in_ns1__subscribeEventHandler(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalPropertyResponse"))
		{	*type = SOAP_TYPE_ns1__getGlobalPropertyResponse;
			return soap_in_ns1__getGlobalPropertyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getGlobalProperty"))
		{	*type = SOAP_TYPE_ns1__getGlobalProperty;
			return soap_in_ns1__getGlobalProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePolicyResponse"))
		{	*type = SOAP_TYPE_ns1__updatePolicyResponse;
			return soap_in_ns1__updatePolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updatePolicy"))
		{	*type = SOAP_TYPE_ns1__updatePolicy;
			return soap_in_ns1__updatePolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rediscoverNodeCapabilitiesResponse"))
		{	*type = SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse;
			return soap_in_ns1__rediscoverNodeCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:rediscoverNodeCapabilities"))
		{	*type = SOAP_TYPE_ns1__rediscoverNodeCapabilities;
			return soap_in_ns1__rediscoverNodeCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeEntityResponse"))
		{	*type = SOAP_TYPE_ns1__removeEntityResponse;
			return soap_in_ns1__removeEntityResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removeEntity"))
		{	*type = SOAP_TYPE_ns1__removeEntity;
			return soap_in_ns1__removeEntity(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCollectionStateResponse"))
		{	*type = SOAP_TYPE_ns1__setCollectionStateResponse;
			return soap_in_ns1__setCollectionStateResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setCollectionState"))
		{	*type = SOAP_TYPE_ns1__setCollectionState;
			return soap_in_ns1__setCollectionState(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setGlobalPropertyResponse"))
		{	*type = SOAP_TYPE_ns1__setGlobalPropertyResponse;
			return soap_in_ns1__setGlobalPropertyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setGlobalProperty"))
		{	*type = SOAP_TYPE_ns1__setGlobalProperty;
			return soap_in_ns1__setGlobalProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribePredefinedEventResponse"))
		{	*type = SOAP_TYPE_ns1__subscribePredefinedEventResponse;
			return soap_in_ns1__subscribePredefinedEventResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:subscribePredefinedEvent"))
		{	*type = SOAP_TYPE_ns1__subscribePredefinedEvent;
			return soap_in_ns1__subscribePredefinedEvent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVersionResponse"))
		{	*type = SOAP_TYPE_ns1__getVersionResponse;
			return soap_in_ns1__getVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getVersion"))
		{	*type = SOAP_TYPE_ns1__getVersion;
			return soap_in_ns1__getVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findEntitiesResponse"))
		{	*type = SOAP_TYPE_ns1__findEntitiesResponse;
			return soap_in_ns1__findEntitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:findEntities"))
		{	*type = SOAP_TYPE_ns1__findEntities;
			return soap_in_ns1__findEntities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:exportHierarchyResponse"))
		{	*type = SOAP_TYPE_ns1__exportHierarchyResponse;
			return soap_in_ns1__exportHierarchyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:exportHierarchy"))
		{	*type = SOAP_TYPE_ns1__exportHierarchy;
			return soap_in_ns1__exportHierarchy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumerateEventHandlersResponse"))
		{	*type = SOAP_TYPE_ns1__enumerateEventHandlersResponse;
			return soap_in_ns1__enumerateEventHandlersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumerateEventHandlers"))
		{	*type = SOAP_TYPE_ns1__enumerateEventHandlers;
			return soap_in_ns1__enumerateEventHandlers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:aggregationPeriod"))
		{	*type = SOAP_TYPE_ns1__aggregationPeriod;
			return soap_in_ns1__aggregationPeriod(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getQueryAggregationPeriodListResponse"))
		{	*type = SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse;
			return soap_in_ns1__getQueryAggregationPeriodListResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getQueryAggregationPeriodList"))
		{	*type = SOAP_TYPE_ns1__getQueryAggregationPeriodList;
			return soap_in_ns1__getQueryAggregationPeriodList(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:isPolicyActiveResponse"))
		{	*type = SOAP_TYPE_ns1__isPolicyActiveResponse;
			return soap_in_ns1__isPolicyActiveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:isPolicyActive"))
		{	*type = SOAP_TYPE_ns1__isPolicyActive;
			return soap_in_ns1__isPolicyActive(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:importHierarchyResponse"))
		{	*type = SOAP_TYPE_ns1__importHierarchyResponse;
			return soap_in_ns1__importHierarchyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:importHierarchy"))
		{	*type = SOAP_TYPE_ns1__importHierarchy;
			return soap_in_ns1__importHierarchy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getNextDataResponse"))
		{	*type = SOAP_TYPE_ns1__getNextDataResponse;
			return soap_in_ns1__getNextDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getNextData"))
		{	*type = SOAP_TYPE_ns1__getNextData;
			return soap_in_ns1__getNextData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:schedulePolicyResponse"))
		{	*type = SOAP_TYPE_ns1__schedulePolicyResponse;
			return soap_in_ns1__schedulePolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:schedulePolicy"))
		{	*type = SOAP_TYPE_ns1__schedulePolicy;
			return soap_in_ns1__schedulePolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPolicyResponse"))
		{	*type = SOAP_TYPE_ns1__setPolicyResponse;
			return soap_in_ns1__setPolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:setPolicy"))
		{	*type = SOAP_TYPE_ns1__setPolicy;
			return soap_in_ns1__setPolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ptData"))
		{	*type = SOAP_TYPE_ns1__ptData;
			return soap_in_ns1__ptData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:enumerationData"))
		{	*type = SOAP_TYPE_ns1__enumerationData;
			return soap_in_ns1__enumerationData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getQueryDataResponse"))
		{	*type = SOAP_TYPE_ns1__getQueryDataResponse;
			return soap_in_ns1__getQueryDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:getQueryData"))
		{	*type = SOAP_TYPE_ns1__getQueryData;
			return soap_in_ns1__getQueryData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Exception"))
		{	*type = SOAP_TYPE_ns1__Exception;
			return soap_in_ns1__Exception(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removePolicyResponse"))
		{	*type = SOAP_TYPE_ns1__removePolicyResponse;
			return soap_in_ns1__removePolicyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:removePolicy"))
		{	*type = SOAP_TYPE_ns1__removePolicy;
			return soap_in_ns1__removePolicy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_xsd__byte;
			return soap_in_xsd__byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:historyType"))
		{	*type = SOAP_TYPE_ns1__historyType;
			return soap_in_ns1__historyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:actionLogType"))
		{	*type = SOAP_TYPE_ns1__actionLogType;
			return soap_in_ns1__actionLogType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:customEventType"))
		{	*type = SOAP_TYPE_ns1__customEventType;
			return soap_in_ns1__customEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:conditionOperator"))
		{	*type = SOAP_TYPE_ns1__conditionOperator;
			return soap_in_ns1__conditionOperator(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:entityType"))
		{	*type = SOAP_TYPE_ns1__entityType;
			return soap_in_ns1__entityType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:metricType"))
		{	*type = SOAP_TYPE_ns1__metricType;
			return soap_in_ns1__metricType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:globalProperty"))
		{	*type = SOAP_TYPE_ns1__globalProperty;
			return soap_in_ns1__globalProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:predefinedEventType"))
		{	*type = SOAP_TYPE_ns1__predefinedEventType;
			return soap_in_ns1__predefinedEventType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:entityProperty"))
		{	*type = SOAP_TYPE_ns1__entityProperty;
			return soap_in_ns1__entityProperty(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:day"))
		{	*type = SOAP_TYPE_ns1__day;
			return soap_in_ns1__day(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:policyType"))
		{	*type = SOAP_TYPE_ns1__policyType;
			return soap_in_ns1__policyType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:aggregationLevel"))
		{	*type = SOAP_TYPE_ns1__aggregationLevel;
			return soap_in_ns1__aggregationLevel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:queryType"))
		{	*type = SOAP_TYPE_ns1__queryType;
			return soap_in_ns1__queryType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_xsd__byte:
		return soap_out_xsd__byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__historyType:
		return soap_out_ns1__historyType(soap, tag, id, (const enum ns1__historyType *)ptr, "ns1:historyType");
	case SOAP_TYPE_ns1__actionLogType:
		return soap_out_ns1__actionLogType(soap, tag, id, (const enum ns1__actionLogType *)ptr, "ns1:actionLogType");
	case SOAP_TYPE_ns1__customEventType:
		return soap_out_ns1__customEventType(soap, tag, id, (const enum ns1__customEventType *)ptr, "ns1:customEventType");
	case SOAP_TYPE_ns1__conditionOperator:
		return soap_out_ns1__conditionOperator(soap, tag, id, (const enum ns1__conditionOperator *)ptr, "ns1:conditionOperator");
	case SOAP_TYPE_ns1__entityType:
		return soap_out_ns1__entityType(soap, tag, id, (const enum ns1__entityType *)ptr, "ns1:entityType");
	case SOAP_TYPE_ns1__metricType:
		return soap_out_ns1__metricType(soap, tag, id, (const enum ns1__metricType *)ptr, "ns1:metricType");
	case SOAP_TYPE_ns1__globalProperty:
		return soap_out_ns1__globalProperty(soap, tag, id, (const enum ns1__globalProperty *)ptr, "ns1:globalProperty");
	case SOAP_TYPE_ns1__predefinedEventType:
		return soap_out_ns1__predefinedEventType(soap, tag, id, (const enum ns1__predefinedEventType *)ptr, "ns1:predefinedEventType");
	case SOAP_TYPE_ns1__entityProperty:
		return soap_out_ns1__entityProperty(soap, tag, id, (const enum ns1__entityProperty *)ptr, "ns1:entityProperty");
	case SOAP_TYPE_ns1__day:
		return soap_out_ns1__day(soap, tag, id, (const enum ns1__day *)ptr, "ns1:day");
	case SOAP_TYPE_ns1__policyType:
		return soap_out_ns1__policyType(soap, tag, id, (const enum ns1__policyType *)ptr, "ns1:policyType");
	case SOAP_TYPE_ns1__aggregationLevel:
		return soap_out_ns1__aggregationLevel(soap, tag, id, (const enum ns1__aggregationLevel *)ptr, "ns1:aggregationLevel");
	case SOAP_TYPE_ns1__queryType:
		return soap_out_ns1__queryType(soap, tag, id, (const enum ns1__queryType *)ptr, "ns1:queryType");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__unsubscribeEventHandlerResponse:
		return ((ns1__unsubscribeEventHandlerResponse *)ptr)->soap_out(soap, tag, id, "ns1:unsubscribeEventHandlerResponse");
	case SOAP_TYPE_ns1__unsubscribeEventHandler:
		return ((ns1__unsubscribeEventHandler *)ptr)->soap_out(soap, tag, id, "ns1:unsubscribeEventHandler");
	case SOAP_TYPE_ns1__getEntityPropertiesResponse:
		return ((ns1__getEntityPropertiesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getEntityPropertiesResponse");
	case SOAP_TYPE_ns1__getEntityProperties:
		return ((ns1__getEntityProperties *)ptr)->soap_out(soap, tag, id, "ns1:getEntityProperties");
	case SOAP_TYPE_ns1__getEventStateResponse:
		return ((ns1__getEventStateResponse *)ptr)->soap_out(soap, tag, id, "ns1:getEventStateResponse");
	case SOAP_TYPE_ns1__getEventState:
		return ((ns1__getEventState *)ptr)->soap_out(soap, tag, id, "ns1:getEventState");
	case SOAP_TYPE_ns1__associateEntityResponse:
		return ((ns1__associateEntityResponse *)ptr)->soap_out(soap, tag, id, "ns1:associateEntityResponse");
	case SOAP_TYPE_ns1__associateEntity:
		return ((ns1__associateEntity *)ptr)->soap_out(soap, tag, id, "ns1:associateEntity");
	case SOAP_TYPE_ns1__getPolicyHistoryResponse:
		return ((ns1__getPolicyHistoryResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPolicyHistoryResponse");
	case SOAP_TYPE_ns1__getPolicyHistory:
		return ((ns1__getPolicyHistory *)ptr)->soap_out(soap, tag, id, "ns1:getPolicyHistory");
	case SOAP_TYPE_ns1__getActionLogRecordsResponse:
		return ((ns1__getActionLogRecordsResponse *)ptr)->soap_out(soap, tag, id, "ns1:getActionLogRecordsResponse");
	case SOAP_TYPE_ns1__getActionLogRecords:
		return ((ns1__getActionLogRecords *)ptr)->soap_out(soap, tag, id, "ns1:getActionLogRecords");
	case SOAP_TYPE_ns1__setPolicyStateResponse:
		return ((ns1__setPolicyStateResponse *)ptr)->soap_out(soap, tag, id, "ns1:setPolicyStateResponse");
	case SOAP_TYPE_ns1__setPolicyState:
		return ((ns1__setPolicyState *)ptr)->soap_out(soap, tag, id, "ns1:setPolicyState");
	case SOAP_TYPE_ns1__policyData:
		return ((ns1__policyData *)ptr)->soap_out(soap, tag, id, "ns1:policyData");
	case SOAP_TYPE_ns1__getPolicyDataResponse:
		return ((ns1__getPolicyDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPolicyDataResponse");
	case SOAP_TYPE_ns1__getPolicyData:
		return ((ns1__getPolicyData *)ptr)->soap_out(soap, tag, id, "ns1:getPolicyData");
	case SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse:
		return ((ns1__getMetricAggregationPeriodListResponse *)ptr)->soap_out(soap, tag, id, "ns1:getMetricAggregationPeriodListResponse");
	case SOAP_TYPE_ns1__getMetricAggregationPeriodList:
		return ((ns1__getMetricAggregationPeriodList *)ptr)->soap_out(soap, tag, id, "ns1:getMetricAggregationPeriodList");
	case SOAP_TYPE_ns1__defineCustomEventResponse:
		return ((ns1__defineCustomEventResponse *)ptr)->soap_out(soap, tag, id, "ns1:defineCustomEventResponse");
	case SOAP_TYPE_ns1__defineCustomEvent:
		return ((ns1__defineCustomEvent *)ptr)->soap_out(soap, tag, id, "ns1:defineCustomEvent");
	case SOAP_TYPE_ns1__enumerateEntitiesResponse:
		return ((ns1__enumerateEntitiesResponse *)ptr)->soap_out(soap, tag, id, "ns1:enumerateEntitiesResponse");
	case SOAP_TYPE_ns1__enumerateEntities:
		return ((ns1__enumerateEntities *)ptr)->soap_out(soap, tag, id, "ns1:enumerateEntities");
	case SOAP_TYPE_ns1__getCollectionStateResponse:
		return ((ns1__getCollectionStateResponse *)ptr)->soap_out(soap, tag, id, "ns1:getCollectionStateResponse");
	case SOAP_TYPE_ns1__getCollectionState:
		return ((ns1__getCollectionState *)ptr)->soap_out(soap, tag, id, "ns1:getCollectionState");
	case SOAP_TYPE_ns1__deleteSecretKeyResponse:
		return ((ns1__deleteSecretKeyResponse *)ptr)->soap_out(soap, tag, id, "ns1:deleteSecretKeyResponse");
	case SOAP_TYPE_ns1__deleteSecretKey:
		return ((ns1__deleteSecretKey *)ptr)->soap_out(soap, tag, id, "ns1:deleteSecretKey");
	case SOAP_TYPE_ns1__unsubscribePredefinedEventResponse:
		return ((ns1__unsubscribePredefinedEventResponse *)ptr)->soap_out(soap, tag, id, "ns1:unsubscribePredefinedEventResponse");
	case SOAP_TYPE_ns1__unsubscribePredefinedEvent:
		return ((ns1__unsubscribePredefinedEvent *)ptr)->soap_out(soap, tag, id, "ns1:unsubscribePredefinedEvent");
	case SOAP_TYPE_ns1__updateCustomEventResponse:
		return ((ns1__updateCustomEventResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateCustomEventResponse");
	case SOAP_TYPE_ns1__updateCustomEvent:
		return ((ns1__updateCustomEvent *)ptr)->soap_out(soap, tag, id, "ns1:updateCustomEvent");
	case SOAP_TYPE_ns1__getPolicyStateResponse:
		return ((ns1__getPolicyStateResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPolicyStateResponse");
	case SOAP_TYPE_ns1__getPolicyState:
		return ((ns1__getPolicyState *)ptr)->soap_out(soap, tag, id, "ns1:getPolicyState");
	case SOAP_TYPE_ns1__enumeratePoliciesResponse:
		return ((ns1__enumeratePoliciesResponse *)ptr)->soap_out(soap, tag, id, "ns1:enumeratePoliciesResponse");
	case SOAP_TYPE_ns1__enumeratePolicies:
		return ((ns1__enumeratePolicies *)ptr)->soap_out(soap, tag, id, "ns1:enumeratePolicies");
	case SOAP_TYPE_ns1__enumerateCustomEventsResponse:
		return ((ns1__enumerateCustomEventsResponse *)ptr)->soap_out(soap, tag, id, "ns1:enumerateCustomEventsResponse");
	case SOAP_TYPE_ns1__enumerateCustomEvents:
		return ((ns1__enumerateCustomEvents *)ptr)->soap_out(soap, tag, id, "ns1:enumerateCustomEvents");
	case SOAP_TYPE_ns1__getPredefinedEventTypesResponse:
		return ((ns1__getPredefinedEventTypesResponse *)ptr)->soap_out(soap, tag, id, "ns1:getPredefinedEventTypesResponse");
	case SOAP_TYPE_ns1__getPredefinedEventTypes:
		return ((ns1__getPredefinedEventTypes *)ptr)->soap_out(soap, tag, id, "ns1:getPredefinedEventTypes");
	case SOAP_TYPE_ns1__customEventData:
		return ((ns1__customEventData *)ptr)->soap_out(soap, tag, id, "ns1:customEventData");
	case SOAP_TYPE_ns1__getCustomEventDataResponse:
		return ((ns1__getCustomEventDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:getCustomEventDataResponse");
	case SOAP_TYPE_ns1__getCustomEventData:
		return ((ns1__getCustomEventData *)ptr)->soap_out(soap, tag, id, "ns1:getCustomEventData");
	case SOAP_TYPE_ns1__getEventHandlerResponse:
		return ((ns1__getEventHandlerResponse *)ptr)->soap_out(soap, tag, id, "ns1:getEventHandlerResponse");
	case SOAP_TYPE_ns1__getEventHandler:
		return ((ns1__getEventHandler *)ptr)->soap_out(soap, tag, id, "ns1:getEventHandler");
	case SOAP_TYPE_ns1__addEntityResponse:
		return ((ns1__addEntityResponse *)ptr)->soap_out(soap, tag, id, "ns1:addEntityResponse");
	case SOAP_TYPE_ns1__addEntity:
		return ((ns1__addEntity *)ptr)->soap_out(soap, tag, id, "ns1:addEntity");
	case SOAP_TYPE_ns1__getMetricDataResponse:
		return ((ns1__getMetricDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:getMetricDataResponse");
	case SOAP_TYPE_ns1__getMetricData:
		return ((ns1__getMetricData *)ptr)->soap_out(soap, tag, id, "ns1:getMetricData");
	case SOAP_TYPE_ns1__disassociateEntityResponse:
		return ((ns1__disassociateEntityResponse *)ptr)->soap_out(soap, tag, id, "ns1:disassociateEntityResponse");
	case SOAP_TYPE_ns1__disassociateEntity:
		return ((ns1__disassociateEntity *)ptr)->soap_out(soap, tag, id, "ns1:disassociateEntity");
	case SOAP_TYPE_ns1__removeCustomEventResponse:
		return ((ns1__removeCustomEventResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeCustomEventResponse");
	case SOAP_TYPE_ns1__removeCustomEvent:
		return ((ns1__removeCustomEvent *)ptr)->soap_out(soap, tag, id, "ns1:removeCustomEvent");
	case SOAP_TYPE_ns1__submitSecretKeyResponse:
		return ((ns1__submitSecretKeyResponse *)ptr)->soap_out(soap, tag, id, "ns1:submitSecretKeyResponse");
	case SOAP_TYPE_ns1__submitSecretKey:
		return ((ns1__submitSecretKey *)ptr)->soap_out(soap, tag, id, "ns1:submitSecretKey");
	case SOAP_TYPE_ns1__setEntityPropertiesResponse:
		return ((ns1__setEntityPropertiesResponse *)ptr)->soap_out(soap, tag, id, "ns1:setEntityPropertiesResponse");
	case SOAP_TYPE_ns1__property:
		return ((ns1__property *)ptr)->soap_out(soap, tag, id, "ns1:property");
	case SOAP_TYPE_ns1__setEntityProperties:
		return ((ns1__setEntityProperties *)ptr)->soap_out(soap, tag, id, "ns1:setEntityProperties");
	case SOAP_TYPE_ns1__setEventStateResponse:
		return ((ns1__setEventStateResponse *)ptr)->soap_out(soap, tag, id, "ns1:setEventStateResponse");
	case SOAP_TYPE_ns1__setEventState:
		return ((ns1__setEventState *)ptr)->soap_out(soap, tag, id, "ns1:setEventState");
	case SOAP_TYPE_ns1__subscribeEventHandlerResponse:
		return ((ns1__subscribeEventHandlerResponse *)ptr)->soap_out(soap, tag, id, "ns1:subscribeEventHandlerResponse");
	case SOAP_TYPE_ns1__subscribeEventHandler:
		return ((ns1__subscribeEventHandler *)ptr)->soap_out(soap, tag, id, "ns1:subscribeEventHandler");
	case SOAP_TYPE_ns1__getGlobalPropertyResponse:
		return ((ns1__getGlobalPropertyResponse *)ptr)->soap_out(soap, tag, id, "ns1:getGlobalPropertyResponse");
	case SOAP_TYPE_ns1__getGlobalProperty:
		return ((ns1__getGlobalProperty *)ptr)->soap_out(soap, tag, id, "ns1:getGlobalProperty");
	case SOAP_TYPE_ns1__updatePolicyResponse:
		return ((ns1__updatePolicyResponse *)ptr)->soap_out(soap, tag, id, "ns1:updatePolicyResponse");
	case SOAP_TYPE_ns1__updatePolicy:
		return ((ns1__updatePolicy *)ptr)->soap_out(soap, tag, id, "ns1:updatePolicy");
	case SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse:
		return ((ns1__rediscoverNodeCapabilitiesResponse *)ptr)->soap_out(soap, tag, id, "ns1:rediscoverNodeCapabilitiesResponse");
	case SOAP_TYPE_ns1__rediscoverNodeCapabilities:
		return ((ns1__rediscoverNodeCapabilities *)ptr)->soap_out(soap, tag, id, "ns1:rediscoverNodeCapabilities");
	case SOAP_TYPE_ns1__removeEntityResponse:
		return ((ns1__removeEntityResponse *)ptr)->soap_out(soap, tag, id, "ns1:removeEntityResponse");
	case SOAP_TYPE_ns1__removeEntity:
		return ((ns1__removeEntity *)ptr)->soap_out(soap, tag, id, "ns1:removeEntity");
	case SOAP_TYPE_ns1__setCollectionStateResponse:
		return ((ns1__setCollectionStateResponse *)ptr)->soap_out(soap, tag, id, "ns1:setCollectionStateResponse");
	case SOAP_TYPE_ns1__setCollectionState:
		return ((ns1__setCollectionState *)ptr)->soap_out(soap, tag, id, "ns1:setCollectionState");
	case SOAP_TYPE_ns1__setGlobalPropertyResponse:
		return ((ns1__setGlobalPropertyResponse *)ptr)->soap_out(soap, tag, id, "ns1:setGlobalPropertyResponse");
	case SOAP_TYPE_ns1__setGlobalProperty:
		return ((ns1__setGlobalProperty *)ptr)->soap_out(soap, tag, id, "ns1:setGlobalProperty");
	case SOAP_TYPE_ns1__subscribePredefinedEventResponse:
		return ((ns1__subscribePredefinedEventResponse *)ptr)->soap_out(soap, tag, id, "ns1:subscribePredefinedEventResponse");
	case SOAP_TYPE_ns1__subscribePredefinedEvent:
		return ((ns1__subscribePredefinedEvent *)ptr)->soap_out(soap, tag, id, "ns1:subscribePredefinedEvent");
	case SOAP_TYPE_ns1__getVersionResponse:
		return ((ns1__getVersionResponse *)ptr)->soap_out(soap, tag, id, "ns1:getVersionResponse");
	case SOAP_TYPE_ns1__getVersion:
		return ((ns1__getVersion *)ptr)->soap_out(soap, tag, id, "ns1:getVersion");
	case SOAP_TYPE_ns1__findEntitiesResponse:
		return ((ns1__findEntitiesResponse *)ptr)->soap_out(soap, tag, id, "ns1:findEntitiesResponse");
	case SOAP_TYPE_ns1__findEntities:
		return ((ns1__findEntities *)ptr)->soap_out(soap, tag, id, "ns1:findEntities");
	case SOAP_TYPE_ns1__exportHierarchyResponse:
		return ((ns1__exportHierarchyResponse *)ptr)->soap_out(soap, tag, id, "ns1:exportHierarchyResponse");
	case SOAP_TYPE_ns1__exportHierarchy:
		return ((ns1__exportHierarchy *)ptr)->soap_out(soap, tag, id, "ns1:exportHierarchy");
	case SOAP_TYPE_ns1__enumerateEventHandlersResponse:
		return ((ns1__enumerateEventHandlersResponse *)ptr)->soap_out(soap, tag, id, "ns1:enumerateEventHandlersResponse");
	case SOAP_TYPE_ns1__enumerateEventHandlers:
		return ((ns1__enumerateEventHandlers *)ptr)->soap_out(soap, tag, id, "ns1:enumerateEventHandlers");
	case SOAP_TYPE_ns1__aggregationPeriod:
		return ((ns1__aggregationPeriod *)ptr)->soap_out(soap, tag, id, "ns1:aggregationPeriod");
	case SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse:
		return ((ns1__getQueryAggregationPeriodListResponse *)ptr)->soap_out(soap, tag, id, "ns1:getQueryAggregationPeriodListResponse");
	case SOAP_TYPE_ns1__getQueryAggregationPeriodList:
		return ((ns1__getQueryAggregationPeriodList *)ptr)->soap_out(soap, tag, id, "ns1:getQueryAggregationPeriodList");
	case SOAP_TYPE_ns1__isPolicyActiveResponse:
		return ((ns1__isPolicyActiveResponse *)ptr)->soap_out(soap, tag, id, "ns1:isPolicyActiveResponse");
	case SOAP_TYPE_ns1__isPolicyActive:
		return ((ns1__isPolicyActive *)ptr)->soap_out(soap, tag, id, "ns1:isPolicyActive");
	case SOAP_TYPE_ns1__importHierarchyResponse:
		return ((ns1__importHierarchyResponse *)ptr)->soap_out(soap, tag, id, "ns1:importHierarchyResponse");
	case SOAP_TYPE_ns1__importHierarchy:
		return ((ns1__importHierarchy *)ptr)->soap_out(soap, tag, id, "ns1:importHierarchy");
	case SOAP_TYPE_ns1__getNextDataResponse:
		return ((ns1__getNextDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:getNextDataResponse");
	case SOAP_TYPE_ns1__getNextData:
		return ((ns1__getNextData *)ptr)->soap_out(soap, tag, id, "ns1:getNextData");
	case SOAP_TYPE_ns1__schedulePolicyResponse:
		return ((ns1__schedulePolicyResponse *)ptr)->soap_out(soap, tag, id, "ns1:schedulePolicyResponse");
	case SOAP_TYPE_ns1__schedulePolicy:
		return ((ns1__schedulePolicy *)ptr)->soap_out(soap, tag, id, "ns1:schedulePolicy");
	case SOAP_TYPE_ns1__setPolicyResponse:
		return ((ns1__setPolicyResponse *)ptr)->soap_out(soap, tag, id, "ns1:setPolicyResponse");
	case SOAP_TYPE_ns1__setPolicy:
		return ((ns1__setPolicy *)ptr)->soap_out(soap, tag, id, "ns1:setPolicy");
	case SOAP_TYPE_ns1__ptData:
		return ((ns1__ptData *)ptr)->soap_out(soap, tag, id, "ns1:ptData");
	case SOAP_TYPE_ns1__enumerationData:
		return ((ns1__enumerationData *)ptr)->soap_out(soap, tag, id, "ns1:enumerationData");
	case SOAP_TYPE_ns1__getQueryDataResponse:
		return ((ns1__getQueryDataResponse *)ptr)->soap_out(soap, tag, id, "ns1:getQueryDataResponse");
	case SOAP_TYPE_ns1__getQueryData:
		return ((ns1__getQueryData *)ptr)->soap_out(soap, tag, id, "ns1:getQueryData");
	case SOAP_TYPE_ns1__Exception:
		return ((ns1__Exception *)ptr)->soap_out(soap, tag, id, "ns1:Exception");
	case SOAP_TYPE_ns1__removePolicyResponse:
		return ((ns1__removePolicyResponse *)ptr)->soap_out(soap, tag, id, "ns1:removePolicyResponse");
	case SOAP_TYPE_ns1__removePolicy:
		return ((ns1__removePolicy *)ptr)->soap_out(soap, tag, id, "ns1:removePolicy");
	case SOAP_TYPE_PointerTons1__updateCustomEventResponse:
		return soap_out_PointerTons1__updateCustomEventResponse(soap, tag, id, (ns1__updateCustomEventResponse *const*)ptr, "ns1:updateCustomEventResponse");
	case SOAP_TYPE_PointerTons1__updateCustomEvent:
		return soap_out_PointerTons1__updateCustomEvent(soap, tag, id, (ns1__updateCustomEvent *const*)ptr, "ns1:updateCustomEvent");
	case SOAP_TYPE_PointerTons1__unsubscribePredefinedEventResponse:
		return soap_out_PointerTons1__unsubscribePredefinedEventResponse(soap, tag, id, (ns1__unsubscribePredefinedEventResponse *const*)ptr, "ns1:unsubscribePredefinedEventResponse");
	case SOAP_TYPE_PointerTons1__unsubscribePredefinedEvent:
		return soap_out_PointerTons1__unsubscribePredefinedEvent(soap, tag, id, (ns1__unsubscribePredefinedEvent *const*)ptr, "ns1:unsubscribePredefinedEvent");
	case SOAP_TYPE_PointerTons1__unsubscribeEventHandlerResponse:
		return soap_out_PointerTons1__unsubscribeEventHandlerResponse(soap, tag, id, (ns1__unsubscribeEventHandlerResponse *const*)ptr, "ns1:unsubscribeEventHandlerResponse");
	case SOAP_TYPE_PointerTons1__unsubscribeEventHandler:
		return soap_out_PointerTons1__unsubscribeEventHandler(soap, tag, id, (ns1__unsubscribeEventHandler *const*)ptr, "ns1:unsubscribeEventHandler");
	case SOAP_TYPE_PointerTons1__subscribePredefinedEventResponse:
		return soap_out_PointerTons1__subscribePredefinedEventResponse(soap, tag, id, (ns1__subscribePredefinedEventResponse *const*)ptr, "ns1:subscribePredefinedEventResponse");
	case SOAP_TYPE_PointerTons1__subscribePredefinedEvent:
		return soap_out_PointerTons1__subscribePredefinedEvent(soap, tag, id, (ns1__subscribePredefinedEvent *const*)ptr, "ns1:subscribePredefinedEvent");
	case SOAP_TYPE_PointerTons1__subscribeEventHandlerResponse:
		return soap_out_PointerTons1__subscribeEventHandlerResponse(soap, tag, id, (ns1__subscribeEventHandlerResponse *const*)ptr, "ns1:subscribeEventHandlerResponse");
	case SOAP_TYPE_PointerTons1__subscribeEventHandler:
		return soap_out_PointerTons1__subscribeEventHandler(soap, tag, id, (ns1__subscribeEventHandler *const*)ptr, "ns1:subscribeEventHandler");
	case SOAP_TYPE_PointerTons1__submitSecretKeyResponse:
		return soap_out_PointerTons1__submitSecretKeyResponse(soap, tag, id, (ns1__submitSecretKeyResponse *const*)ptr, "ns1:submitSecretKeyResponse");
	case SOAP_TYPE_PointerTons1__submitSecretKey:
		return soap_out_PointerTons1__submitSecretKey(soap, tag, id, (ns1__submitSecretKey *const*)ptr, "ns1:submitSecretKey");
	case SOAP_TYPE_PointerTons1__setPolicyStateResponse:
		return soap_out_PointerTons1__setPolicyStateResponse(soap, tag, id, (ns1__setPolicyStateResponse *const*)ptr, "ns1:setPolicyStateResponse");
	case SOAP_TYPE_PointerTons1__setPolicyState:
		return soap_out_PointerTons1__setPolicyState(soap, tag, id, (ns1__setPolicyState *const*)ptr, "ns1:setPolicyState");
	case SOAP_TYPE_PointerTons1__setGlobalPropertyResponse:
		return soap_out_PointerTons1__setGlobalPropertyResponse(soap, tag, id, (ns1__setGlobalPropertyResponse *const*)ptr, "ns1:setGlobalPropertyResponse");
	case SOAP_TYPE_PointerTons1__setGlobalProperty:
		return soap_out_PointerTons1__setGlobalProperty(soap, tag, id, (ns1__setGlobalProperty *const*)ptr, "ns1:setGlobalProperty");
	case SOAP_TYPE_PointerTons1__setEventStateResponse:
		return soap_out_PointerTons1__setEventStateResponse(soap, tag, id, (ns1__setEventStateResponse *const*)ptr, "ns1:setEventStateResponse");
	case SOAP_TYPE_PointerTons1__setEventState:
		return soap_out_PointerTons1__setEventState(soap, tag, id, (ns1__setEventState *const*)ptr, "ns1:setEventState");
	case SOAP_TYPE_PointerTons1__setEntityPropertiesResponse:
		return soap_out_PointerTons1__setEntityPropertiesResponse(soap, tag, id, (ns1__setEntityPropertiesResponse *const*)ptr, "ns1:setEntityPropertiesResponse");
	case SOAP_TYPE_PointerTons1__setEntityProperties:
		return soap_out_PointerTons1__setEntityProperties(soap, tag, id, (ns1__setEntityProperties *const*)ptr, "ns1:setEntityProperties");
	case SOAP_TYPE_PointerTons1__setCollectionStateResponse:
		return soap_out_PointerTons1__setCollectionStateResponse(soap, tag, id, (ns1__setCollectionStateResponse *const*)ptr, "ns1:setCollectionStateResponse");
	case SOAP_TYPE_PointerTons1__setCollectionState:
		return soap_out_PointerTons1__setCollectionState(soap, tag, id, (ns1__setCollectionState *const*)ptr, "ns1:setCollectionState");
	case SOAP_TYPE_PointerTons1__schedulePolicyResponse:
		return soap_out_PointerTons1__schedulePolicyResponse(soap, tag, id, (ns1__schedulePolicyResponse *const*)ptr, "ns1:schedulePolicyResponse");
	case SOAP_TYPE_PointerTons1__schedulePolicy:
		return soap_out_PointerTons1__schedulePolicy(soap, tag, id, (ns1__schedulePolicy *const*)ptr, "ns1:schedulePolicy");
	case SOAP_TYPE_PointerTons1__removePolicyResponse:
		return soap_out_PointerTons1__removePolicyResponse(soap, tag, id, (ns1__removePolicyResponse *const*)ptr, "ns1:removePolicyResponse");
	case SOAP_TYPE_PointerTons1__removePolicy:
		return soap_out_PointerTons1__removePolicy(soap, tag, id, (ns1__removePolicy *const*)ptr, "ns1:removePolicy");
	case SOAP_TYPE_PointerTons1__removeEntityResponse:
		return soap_out_PointerTons1__removeEntityResponse(soap, tag, id, (ns1__removeEntityResponse *const*)ptr, "ns1:removeEntityResponse");
	case SOAP_TYPE_PointerTons1__removeEntity:
		return soap_out_PointerTons1__removeEntity(soap, tag, id, (ns1__removeEntity *const*)ptr, "ns1:removeEntity");
	case SOAP_TYPE_PointerTons1__removeCustomEventResponse:
		return soap_out_PointerTons1__removeCustomEventResponse(soap, tag, id, (ns1__removeCustomEventResponse *const*)ptr, "ns1:removeCustomEventResponse");
	case SOAP_TYPE_PointerTons1__removeCustomEvent:
		return soap_out_PointerTons1__removeCustomEvent(soap, tag, id, (ns1__removeCustomEvent *const*)ptr, "ns1:removeCustomEvent");
	case SOAP_TYPE_PointerTons1__rediscoverNodeCapabilitiesResponse:
		return soap_out_PointerTons1__rediscoverNodeCapabilitiesResponse(soap, tag, id, (ns1__rediscoverNodeCapabilitiesResponse *const*)ptr, "ns1:rediscoverNodeCapabilitiesResponse");
	case SOAP_TYPE_PointerTons1__rediscoverNodeCapabilities:
		return soap_out_PointerTons1__rediscoverNodeCapabilities(soap, tag, id, (ns1__rediscoverNodeCapabilities *const*)ptr, "ns1:rediscoverNodeCapabilities");
	case SOAP_TYPE_PointerTons1__isPolicyActiveResponse:
		return soap_out_PointerTons1__isPolicyActiveResponse(soap, tag, id, (ns1__isPolicyActiveResponse *const*)ptr, "ns1:isPolicyActiveResponse");
	case SOAP_TYPE_PointerTons1__isPolicyActive:
		return soap_out_PointerTons1__isPolicyActive(soap, tag, id, (ns1__isPolicyActive *const*)ptr, "ns1:isPolicyActive");
	case SOAP_TYPE_PointerTons1__importHierarchyResponse:
		return soap_out_PointerTons1__importHierarchyResponse(soap, tag, id, (ns1__importHierarchyResponse *const*)ptr, "ns1:importHierarchyResponse");
	case SOAP_TYPE_PointerTons1__importHierarchy:
		return soap_out_PointerTons1__importHierarchy(soap, tag, id, (ns1__importHierarchy *const*)ptr, "ns1:importHierarchy");
	case SOAP_TYPE_PointerTons1__getQueryDataResponse:
		return soap_out_PointerTons1__getQueryDataResponse(soap, tag, id, (ns1__getQueryDataResponse *const*)ptr, "ns1:getQueryDataResponse");
	case SOAP_TYPE_PointerTons1__getQueryData:
		return soap_out_PointerTons1__getQueryData(soap, tag, id, (ns1__getQueryData *const*)ptr, "ns1:getQueryData");
	case SOAP_TYPE_PointerTons1__getQueryAggregationPeriodListResponse:
		return soap_out_PointerTons1__getQueryAggregationPeriodListResponse(soap, tag, id, (ns1__getQueryAggregationPeriodListResponse *const*)ptr, "ns1:getQueryAggregationPeriodListResponse");
	case SOAP_TYPE_PointerTons1__getQueryAggregationPeriodList:
		return soap_out_PointerTons1__getQueryAggregationPeriodList(soap, tag, id, (ns1__getQueryAggregationPeriodList *const*)ptr, "ns1:getQueryAggregationPeriodList");
	case SOAP_TYPE_PointerTons1__getPredefinedEventTypesResponse:
		return soap_out_PointerTons1__getPredefinedEventTypesResponse(soap, tag, id, (ns1__getPredefinedEventTypesResponse *const*)ptr, "ns1:getPredefinedEventTypesResponse");
	case SOAP_TYPE_PointerTons1__getPredefinedEventTypes:
		return soap_out_PointerTons1__getPredefinedEventTypes(soap, tag, id, (ns1__getPredefinedEventTypes *const*)ptr, "ns1:getPredefinedEventTypes");
	case SOAP_TYPE_PointerTons1__getPolicyStateResponse:
		return soap_out_PointerTons1__getPolicyStateResponse(soap, tag, id, (ns1__getPolicyStateResponse *const*)ptr, "ns1:getPolicyStateResponse");
	case SOAP_TYPE_PointerTons1__getPolicyState:
		return soap_out_PointerTons1__getPolicyState(soap, tag, id, (ns1__getPolicyState *const*)ptr, "ns1:getPolicyState");
	case SOAP_TYPE_PointerTons1__getPolicyHistoryResponse:
		return soap_out_PointerTons1__getPolicyHistoryResponse(soap, tag, id, (ns1__getPolicyHistoryResponse *const*)ptr, "ns1:getPolicyHistoryResponse");
	case SOAP_TYPE_PointerTons1__getPolicyHistory:
		return soap_out_PointerTons1__getPolicyHistory(soap, tag, id, (ns1__getPolicyHistory *const*)ptr, "ns1:getPolicyHistory");
	case SOAP_TYPE_PointerTons1__getPolicyDataResponse:
		return soap_out_PointerTons1__getPolicyDataResponse(soap, tag, id, (ns1__getPolicyDataResponse *const*)ptr, "ns1:getPolicyDataResponse");
	case SOAP_TYPE_PointerTons1__getPolicyData:
		return soap_out_PointerTons1__getPolicyData(soap, tag, id, (ns1__getPolicyData *const*)ptr, "ns1:getPolicyData");
	case SOAP_TYPE_PointerTons1__getNextDataResponse:
		return soap_out_PointerTons1__getNextDataResponse(soap, tag, id, (ns1__getNextDataResponse *const*)ptr, "ns1:getNextDataResponse");
	case SOAP_TYPE_PointerTons1__getNextData:
		return soap_out_PointerTons1__getNextData(soap, tag, id, (ns1__getNextData *const*)ptr, "ns1:getNextData");
	case SOAP_TYPE_PointerTons1__getMetricDataResponse:
		return soap_out_PointerTons1__getMetricDataResponse(soap, tag, id, (ns1__getMetricDataResponse *const*)ptr, "ns1:getMetricDataResponse");
	case SOAP_TYPE_PointerTons1__getMetricData:
		return soap_out_PointerTons1__getMetricData(soap, tag, id, (ns1__getMetricData *const*)ptr, "ns1:getMetricData");
	case SOAP_TYPE_PointerTons1__getMetricAggregationPeriodListResponse:
		return soap_out_PointerTons1__getMetricAggregationPeriodListResponse(soap, tag, id, (ns1__getMetricAggregationPeriodListResponse *const*)ptr, "ns1:getMetricAggregationPeriodListResponse");
	case SOAP_TYPE_PointerTons1__getMetricAggregationPeriodList:
		return soap_out_PointerTons1__getMetricAggregationPeriodList(soap, tag, id, (ns1__getMetricAggregationPeriodList *const*)ptr, "ns1:getMetricAggregationPeriodList");
	case SOAP_TYPE_PointerTons1__getGlobalPropertyResponse:
		return soap_out_PointerTons1__getGlobalPropertyResponse(soap, tag, id, (ns1__getGlobalPropertyResponse *const*)ptr, "ns1:getGlobalPropertyResponse");
	case SOAP_TYPE_PointerTons1__getGlobalProperty:
		return soap_out_PointerTons1__getGlobalProperty(soap, tag, id, (ns1__getGlobalProperty *const*)ptr, "ns1:getGlobalProperty");
	case SOAP_TYPE_PointerTons1__getEventStateResponse:
		return soap_out_PointerTons1__getEventStateResponse(soap, tag, id, (ns1__getEventStateResponse *const*)ptr, "ns1:getEventStateResponse");
	case SOAP_TYPE_PointerTons1__getEventState:
		return soap_out_PointerTons1__getEventState(soap, tag, id, (ns1__getEventState *const*)ptr, "ns1:getEventState");
	case SOAP_TYPE_PointerTons1__getEventHandlerResponse:
		return soap_out_PointerTons1__getEventHandlerResponse(soap, tag, id, (ns1__getEventHandlerResponse *const*)ptr, "ns1:getEventHandlerResponse");
	case SOAP_TYPE_PointerTons1__getEventHandler:
		return soap_out_PointerTons1__getEventHandler(soap, tag, id, (ns1__getEventHandler *const*)ptr, "ns1:getEventHandler");
	case SOAP_TYPE_PointerTons1__getEntityPropertiesResponse:
		return soap_out_PointerTons1__getEntityPropertiesResponse(soap, tag, id, (ns1__getEntityPropertiesResponse *const*)ptr, "ns1:getEntityPropertiesResponse");
	case SOAP_TYPE_PointerTons1__getEntityProperties:
		return soap_out_PointerTons1__getEntityProperties(soap, tag, id, (ns1__getEntityProperties *const*)ptr, "ns1:getEntityProperties");
	case SOAP_TYPE_PointerTons1__getCustomEventDataResponse:
		return soap_out_PointerTons1__getCustomEventDataResponse(soap, tag, id, (ns1__getCustomEventDataResponse *const*)ptr, "ns1:getCustomEventDataResponse");
	case SOAP_TYPE_PointerTons1__getCustomEventData:
		return soap_out_PointerTons1__getCustomEventData(soap, tag, id, (ns1__getCustomEventData *const*)ptr, "ns1:getCustomEventData");
	case SOAP_TYPE_PointerTons1__getCollectionStateResponse:
		return soap_out_PointerTons1__getCollectionStateResponse(soap, tag, id, (ns1__getCollectionStateResponse *const*)ptr, "ns1:getCollectionStateResponse");
	case SOAP_TYPE_PointerTons1__getCollectionState:
		return soap_out_PointerTons1__getCollectionState(soap, tag, id, (ns1__getCollectionState *const*)ptr, "ns1:getCollectionState");
	case SOAP_TYPE_PointerTons1__getActionLogRecordsResponse:
		return soap_out_PointerTons1__getActionLogRecordsResponse(soap, tag, id, (ns1__getActionLogRecordsResponse *const*)ptr, "ns1:getActionLogRecordsResponse");
	case SOAP_TYPE_PointerTons1__getActionLogRecords:
		return soap_out_PointerTons1__getActionLogRecords(soap, tag, id, (ns1__getActionLogRecords *const*)ptr, "ns1:getActionLogRecords");
	case SOAP_TYPE_PointerTons1__findEntitiesResponse:
		return soap_out_PointerTons1__findEntitiesResponse(soap, tag, id, (ns1__findEntitiesResponse *const*)ptr, "ns1:findEntitiesResponse");
	case SOAP_TYPE_PointerTons1__findEntities:
		return soap_out_PointerTons1__findEntities(soap, tag, id, (ns1__findEntities *const*)ptr, "ns1:findEntities");
	case SOAP_TYPE_PointerTons1__exportHierarchyResponse:
		return soap_out_PointerTons1__exportHierarchyResponse(soap, tag, id, (ns1__exportHierarchyResponse *const*)ptr, "ns1:exportHierarchyResponse");
	case SOAP_TYPE_PointerTons1__exportHierarchy:
		return soap_out_PointerTons1__exportHierarchy(soap, tag, id, (ns1__exportHierarchy *const*)ptr, "ns1:exportHierarchy");
	case SOAP_TYPE_PointerTons1__enumeratePoliciesResponse:
		return soap_out_PointerTons1__enumeratePoliciesResponse(soap, tag, id, (ns1__enumeratePoliciesResponse *const*)ptr, "ns1:enumeratePoliciesResponse");
	case SOAP_TYPE_PointerTons1__enumeratePolicies:
		return soap_out_PointerTons1__enumeratePolicies(soap, tag, id, (ns1__enumeratePolicies *const*)ptr, "ns1:enumeratePolicies");
	case SOAP_TYPE_PointerTons1__enumerateEventHandlersResponse:
		return soap_out_PointerTons1__enumerateEventHandlersResponse(soap, tag, id, (ns1__enumerateEventHandlersResponse *const*)ptr, "ns1:enumerateEventHandlersResponse");
	case SOAP_TYPE_PointerTons1__enumerateEventHandlers:
		return soap_out_PointerTons1__enumerateEventHandlers(soap, tag, id, (ns1__enumerateEventHandlers *const*)ptr, "ns1:enumerateEventHandlers");
	case SOAP_TYPE_PointerTons1__enumerateEntitiesResponse:
		return soap_out_PointerTons1__enumerateEntitiesResponse(soap, tag, id, (ns1__enumerateEntitiesResponse *const*)ptr, "ns1:enumerateEntitiesResponse");
	case SOAP_TYPE_PointerTons1__enumerateEntities:
		return soap_out_PointerTons1__enumerateEntities(soap, tag, id, (ns1__enumerateEntities *const*)ptr, "ns1:enumerateEntities");
	case SOAP_TYPE_PointerTons1__enumerateCustomEventsResponse:
		return soap_out_PointerTons1__enumerateCustomEventsResponse(soap, tag, id, (ns1__enumerateCustomEventsResponse *const*)ptr, "ns1:enumerateCustomEventsResponse");
	case SOAP_TYPE_PointerTons1__enumerateCustomEvents:
		return soap_out_PointerTons1__enumerateCustomEvents(soap, tag, id, (ns1__enumerateCustomEvents *const*)ptr, "ns1:enumerateCustomEvents");
	case SOAP_TYPE_PointerTons1__disassociateEntityResponse:
		return soap_out_PointerTons1__disassociateEntityResponse(soap, tag, id, (ns1__disassociateEntityResponse *const*)ptr, "ns1:disassociateEntityResponse");
	case SOAP_TYPE_PointerTons1__disassociateEntity:
		return soap_out_PointerTons1__disassociateEntity(soap, tag, id, (ns1__disassociateEntity *const*)ptr, "ns1:disassociateEntity");
	case SOAP_TYPE_PointerTons1__deleteSecretKeyResponse:
		return soap_out_PointerTons1__deleteSecretKeyResponse(soap, tag, id, (ns1__deleteSecretKeyResponse *const*)ptr, "ns1:deleteSecretKeyResponse");
	case SOAP_TYPE_PointerTons1__deleteSecretKey:
		return soap_out_PointerTons1__deleteSecretKey(soap, tag, id, (ns1__deleteSecretKey *const*)ptr, "ns1:deleteSecretKey");
	case SOAP_TYPE_PointerTons1__defineCustomEventResponse:
		return soap_out_PointerTons1__defineCustomEventResponse(soap, tag, id, (ns1__defineCustomEventResponse *const*)ptr, "ns1:defineCustomEventResponse");
	case SOAP_TYPE_PointerTons1__defineCustomEvent:
		return soap_out_PointerTons1__defineCustomEvent(soap, tag, id, (ns1__defineCustomEvent *const*)ptr, "ns1:defineCustomEvent");
	case SOAP_TYPE_PointerTons1__associateEntityResponse:
		return soap_out_PointerTons1__associateEntityResponse(soap, tag, id, (ns1__associateEntityResponse *const*)ptr, "ns1:associateEntityResponse");
	case SOAP_TYPE_PointerTons1__associateEntity:
		return soap_out_PointerTons1__associateEntity(soap, tag, id, (ns1__associateEntity *const*)ptr, "ns1:associateEntity");
	case SOAP_TYPE_PointerTons1__addEntityResponse:
		return soap_out_PointerTons1__addEntityResponse(soap, tag, id, (ns1__addEntityResponse *const*)ptr, "ns1:addEntityResponse");
	case SOAP_TYPE_PointerTons1__addEntity:
		return soap_out_PointerTons1__addEntity(soap, tag, id, (ns1__addEntity *const*)ptr, "ns1:addEntity");
	case SOAP_TYPE_PointerTons1__updatePolicyResponse:
		return soap_out_PointerTons1__updatePolicyResponse(soap, tag, id, (ns1__updatePolicyResponse *const*)ptr, "ns1:updatePolicyResponse");
	case SOAP_TYPE_PointerTons1__updatePolicy:
		return soap_out_PointerTons1__updatePolicy(soap, tag, id, (ns1__updatePolicy *const*)ptr, "ns1:updatePolicy");
	case SOAP_TYPE_PointerTons1__setPolicyResponse:
		return soap_out_PointerTons1__setPolicyResponse(soap, tag, id, (ns1__setPolicyResponse *const*)ptr, "ns1:setPolicyResponse");
	case SOAP_TYPE_PointerTons1__setPolicy:
		return soap_out_PointerTons1__setPolicy(soap, tag, id, (ns1__setPolicy *const*)ptr, "ns1:setPolicy");
	case SOAP_TYPE_PointerTons1__getVersionResponse:
		return soap_out_PointerTons1__getVersionResponse(soap, tag, id, (ns1__getVersionResponse *const*)ptr, "ns1:getVersionResponse");
	case SOAP_TYPE_PointerTons1__getVersion:
		return soap_out_PointerTons1__getVersion(soap, tag, id, (ns1__getVersion *const*)ptr, "ns1:getVersion");
	case SOAP_TYPE_PointerTons1__Exception:
		return soap_out_PointerTons1__Exception(soap, tag, id, (ns1__Exception *const*)ptr, "ns1:Exception");
	case SOAP_TYPE_PointerTons1__historyType:
		return soap_out_PointerTons1__historyType(soap, tag, id, (enum ns1__historyType *const*)ptr, "ns1:historyType");
	case SOAP_TYPE_PointerTons1__actionLogType:
		return soap_out_PointerTons1__actionLogType(soap, tag, id, (enum ns1__actionLogType *const*)ptr, "ns1:actionLogType");
	case SOAP_TYPE_PointerTons1__policyData:
		return soap_out_PointerTons1__policyData(soap, tag, id, (ns1__policyData *const*)ptr, "ns1:policyData");
	case SOAP_TYPE_PointerTons1__customEventType:
		return soap_out_PointerTons1__customEventType(soap, tag, id, (enum ns1__customEventType *const*)ptr, "ns1:customEventType");
	case SOAP_TYPE_PointerTons1__conditionOperator:
		return soap_out_PointerTons1__conditionOperator(soap, tag, id, (enum ns1__conditionOperator *const*)ptr, "ns1:conditionOperator");
	case SOAP_TYPE_PointerTons1__customEventData:
		return soap_out_PointerTons1__customEventData(soap, tag, id, (ns1__customEventData *const*)ptr, "ns1:customEventData");
	case SOAP_TYPE_PointerTons1__entityType:
		return soap_out_PointerTons1__entityType(soap, tag, id, (enum ns1__entityType *const*)ptr, "ns1:entityType");
	case SOAP_TYPE_PointerTons1__metricType:
		return soap_out_PointerTons1__metricType(soap, tag, id, (enum ns1__metricType *const*)ptr, "ns1:metricType");
	case SOAP_TYPE_PointerTons1__property:
		return soap_out_PointerTons1__property(soap, tag, id, (ns1__property *const*)ptr, "ns1:property");
	case SOAP_TYPE_PointerTons1__globalProperty:
		return soap_out_PointerTons1__globalProperty(soap, tag, id, (enum ns1__globalProperty *const*)ptr, "ns1:globalProperty");
	case SOAP_TYPE_PointerTons1__entityProperty:
		return soap_out_PointerTons1__entityProperty(soap, tag, id, (enum ns1__entityProperty *const*)ptr, "ns1:entityProperty");
	case SOAP_TYPE_PointerTons1__aggregationPeriod:
		return soap_out_PointerTons1__aggregationPeriod(soap, tag, id, (ns1__aggregationPeriod *const*)ptr, "ns1:aggregationPeriod");
	case SOAP_TYPE_PointerTons1__policyType:
		return soap_out_PointerTons1__policyType(soap, tag, id, (enum ns1__policyType *const*)ptr, "ns1:policyType");
	case SOAP_TYPE_PointerTons1__ptData:
		return soap_out_PointerTons1__ptData(soap, tag, id, (ns1__ptData *const*)ptr, "ns1:ptData");
	case SOAP_TYPE_PointerTons1__enumerationData:
		return soap_out_PointerTons1__enumerationData(soap, tag, id, (ns1__enumerationData *const*)ptr, "ns1:enumerationData");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTons1__aggregationLevel:
		return soap_out_PointerTons1__aggregationLevel(soap, tag, id, (enum ns1__aggregationLevel *const*)ptr, "ns1:aggregationLevel");
	case SOAP_TYPE_PointerTons1__queryType:
		return soap_out_PointerTons1__queryType(soap, tag, id, (enum ns1__queryType *const*)ptr, "ns1:queryType");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__unsubscribeEventHandlerResponse:
		((ns1__unsubscribeEventHandlerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__unsubscribeEventHandler:
		((ns1__unsubscribeEventHandler *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getEntityPropertiesResponse:
		((ns1__getEntityPropertiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getEntityProperties:
		((ns1__getEntityProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getEventStateResponse:
		((ns1__getEventStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getEventState:
		((ns1__getEventState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__associateEntityResponse:
		((ns1__associateEntityResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__associateEntity:
		((ns1__associateEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPolicyHistoryResponse:
		((ns1__getPolicyHistoryResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPolicyHistory:
		((ns1__getPolicyHistory *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getActionLogRecordsResponse:
		((ns1__getActionLogRecordsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getActionLogRecords:
		((ns1__getActionLogRecords *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setPolicyStateResponse:
		((ns1__setPolicyStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setPolicyState:
		((ns1__setPolicyState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__policyData:
		((ns1__policyData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPolicyDataResponse:
		((ns1__getPolicyDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPolicyData:
		((ns1__getPolicyData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse:
		((ns1__getMetricAggregationPeriodListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMetricAggregationPeriodList:
		((ns1__getMetricAggregationPeriodList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__defineCustomEventResponse:
		((ns1__defineCustomEventResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__defineCustomEvent:
		((ns1__defineCustomEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumerateEntitiesResponse:
		((ns1__enumerateEntitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumerateEntities:
		((ns1__enumerateEntities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCollectionStateResponse:
		((ns1__getCollectionStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCollectionState:
		((ns1__getCollectionState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteSecretKeyResponse:
		((ns1__deleteSecretKeyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__deleteSecretKey:
		((ns1__deleteSecretKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__unsubscribePredefinedEventResponse:
		((ns1__unsubscribePredefinedEventResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__unsubscribePredefinedEvent:
		((ns1__unsubscribePredefinedEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateCustomEventResponse:
		((ns1__updateCustomEventResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateCustomEvent:
		((ns1__updateCustomEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPolicyStateResponse:
		((ns1__getPolicyStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPolicyState:
		((ns1__getPolicyState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumeratePoliciesResponse:
		((ns1__enumeratePoliciesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumeratePolicies:
		((ns1__enumeratePolicies *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumerateCustomEventsResponse:
		((ns1__enumerateCustomEventsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumerateCustomEvents:
		((ns1__enumerateCustomEvents *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPredefinedEventTypesResponse:
		((ns1__getPredefinedEventTypesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getPredefinedEventTypes:
		((ns1__getPredefinedEventTypes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__customEventData:
		((ns1__customEventData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCustomEventDataResponse:
		((ns1__getCustomEventDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getCustomEventData:
		((ns1__getCustomEventData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getEventHandlerResponse:
		((ns1__getEventHandlerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getEventHandler:
		((ns1__getEventHandler *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addEntityResponse:
		((ns1__addEntityResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__addEntity:
		((ns1__addEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMetricDataResponse:
		((ns1__getMetricDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getMetricData:
		((ns1__getMetricData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__disassociateEntityResponse:
		((ns1__disassociateEntityResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__disassociateEntity:
		((ns1__disassociateEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeCustomEventResponse:
		((ns1__removeCustomEventResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeCustomEvent:
		((ns1__removeCustomEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__submitSecretKeyResponse:
		((ns1__submitSecretKeyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__submitSecretKey:
		((ns1__submitSecretKey *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setEntityPropertiesResponse:
		((ns1__setEntityPropertiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__property:
		((ns1__property *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setEntityProperties:
		((ns1__setEntityProperties *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setEventStateResponse:
		((ns1__setEventStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setEventState:
		((ns1__setEventState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__subscribeEventHandlerResponse:
		((ns1__subscribeEventHandlerResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__subscribeEventHandler:
		((ns1__subscribeEventHandler *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getGlobalPropertyResponse:
		((ns1__getGlobalPropertyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getGlobalProperty:
		((ns1__getGlobalProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updatePolicyResponse:
		((ns1__updatePolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updatePolicy:
		((ns1__updatePolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse:
		((ns1__rediscoverNodeCapabilitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__rediscoverNodeCapabilities:
		((ns1__rediscoverNodeCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeEntityResponse:
		((ns1__removeEntityResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removeEntity:
		((ns1__removeEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setCollectionStateResponse:
		((ns1__setCollectionStateResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setCollectionState:
		((ns1__setCollectionState *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setGlobalPropertyResponse:
		((ns1__setGlobalPropertyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setGlobalProperty:
		((ns1__setGlobalProperty *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__subscribePredefinedEventResponse:
		((ns1__subscribePredefinedEventResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__subscribePredefinedEvent:
		((ns1__subscribePredefinedEvent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getVersionResponse:
		((ns1__getVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getVersion:
		((ns1__getVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findEntitiesResponse:
		((ns1__findEntitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__findEntities:
		((ns1__findEntities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__exportHierarchyResponse:
		((ns1__exportHierarchyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__exportHierarchy:
		((ns1__exportHierarchy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumerateEventHandlersResponse:
		((ns1__enumerateEventHandlersResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumerateEventHandlers:
		((ns1__enumerateEventHandlers *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__aggregationPeriod:
		((ns1__aggregationPeriod *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse:
		((ns1__getQueryAggregationPeriodListResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getQueryAggregationPeriodList:
		((ns1__getQueryAggregationPeriodList *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__isPolicyActiveResponse:
		((ns1__isPolicyActiveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__isPolicyActive:
		((ns1__isPolicyActive *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__importHierarchyResponse:
		((ns1__importHierarchyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__importHierarchy:
		((ns1__importHierarchy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getNextDataResponse:
		((ns1__getNextDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getNextData:
		((ns1__getNextData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__schedulePolicyResponse:
		((ns1__schedulePolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__schedulePolicy:
		((ns1__schedulePolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setPolicyResponse:
		((ns1__setPolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__setPolicy:
		((ns1__setPolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ptData:
		((ns1__ptData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__enumerationData:
		((ns1__enumerationData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getQueryDataResponse:
		((ns1__getQueryDataResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__getQueryData:
		((ns1__getQueryData *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Exception:
		((ns1__Exception *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removePolicyResponse:
		((ns1__removePolicyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__removePolicy:
		((ns1__removePolicy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__updateCustomEvent:
		soap_serialize___ns1__updateCustomEvent(soap, (const struct __ns1__updateCustomEvent *)ptr);
		break;
	case SOAP_TYPE___ns1__unsubscribePredefinedEvent:
		soap_serialize___ns1__unsubscribePredefinedEvent(soap, (const struct __ns1__unsubscribePredefinedEvent *)ptr);
		break;
	case SOAP_TYPE___ns1__unsubscribeEventHandler:
		soap_serialize___ns1__unsubscribeEventHandler(soap, (const struct __ns1__unsubscribeEventHandler *)ptr);
		break;
	case SOAP_TYPE___ns1__subscribePredefinedEvent:
		soap_serialize___ns1__subscribePredefinedEvent(soap, (const struct __ns1__subscribePredefinedEvent *)ptr);
		break;
	case SOAP_TYPE___ns1__subscribeEventHandler:
		soap_serialize___ns1__subscribeEventHandler(soap, (const struct __ns1__subscribeEventHandler *)ptr);
		break;
	case SOAP_TYPE___ns1__submitSecretKey:
		soap_serialize___ns1__submitSecretKey(soap, (const struct __ns1__submitSecretKey *)ptr);
		break;
	case SOAP_TYPE___ns1__setPolicyState:
		soap_serialize___ns1__setPolicyState(soap, (const struct __ns1__setPolicyState *)ptr);
		break;
	case SOAP_TYPE___ns1__setGlobalProperty:
		soap_serialize___ns1__setGlobalProperty(soap, (const struct __ns1__setGlobalProperty *)ptr);
		break;
	case SOAP_TYPE___ns1__setEventState:
		soap_serialize___ns1__setEventState(soap, (const struct __ns1__setEventState *)ptr);
		break;
	case SOAP_TYPE___ns1__setEntityProperties:
		soap_serialize___ns1__setEntityProperties(soap, (const struct __ns1__setEntityProperties *)ptr);
		break;
	case SOAP_TYPE___ns1__setCollectionState:
		soap_serialize___ns1__setCollectionState(soap, (const struct __ns1__setCollectionState *)ptr);
		break;
	case SOAP_TYPE___ns1__schedulePolicy:
		soap_serialize___ns1__schedulePolicy(soap, (const struct __ns1__schedulePolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__removePolicy:
		soap_serialize___ns1__removePolicy(soap, (const struct __ns1__removePolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__removeEntity:
		soap_serialize___ns1__removeEntity(soap, (const struct __ns1__removeEntity *)ptr);
		break;
	case SOAP_TYPE___ns1__removeCustomEvent:
		soap_serialize___ns1__removeCustomEvent(soap, (const struct __ns1__removeCustomEvent *)ptr);
		break;
	case SOAP_TYPE___ns1__rediscoverNodeCapabilities:
		soap_serialize___ns1__rediscoverNodeCapabilities(soap, (const struct __ns1__rediscoverNodeCapabilities *)ptr);
		break;
	case SOAP_TYPE___ns1__isPolicyActive:
		soap_serialize___ns1__isPolicyActive(soap, (const struct __ns1__isPolicyActive *)ptr);
		break;
	case SOAP_TYPE___ns1__importHierarchy:
		soap_serialize___ns1__importHierarchy(soap, (const struct __ns1__importHierarchy *)ptr);
		break;
	case SOAP_TYPE___ns1__getQueryData:
		soap_serialize___ns1__getQueryData(soap, (const struct __ns1__getQueryData *)ptr);
		break;
	case SOAP_TYPE___ns1__getQueryAggregationPeriodList:
		soap_serialize___ns1__getQueryAggregationPeriodList(soap, (const struct __ns1__getQueryAggregationPeriodList *)ptr);
		break;
	case SOAP_TYPE___ns1__getPredefinedEventTypes:
		soap_serialize___ns1__getPredefinedEventTypes(soap, (const struct __ns1__getPredefinedEventTypes *)ptr);
		break;
	case SOAP_TYPE___ns1__getPolicyState:
		soap_serialize___ns1__getPolicyState(soap, (const struct __ns1__getPolicyState *)ptr);
		break;
	case SOAP_TYPE___ns1__getPolicyHistory:
		soap_serialize___ns1__getPolicyHistory(soap, (const struct __ns1__getPolicyHistory *)ptr);
		break;
	case SOAP_TYPE___ns1__getPolicyData:
		soap_serialize___ns1__getPolicyData(soap, (const struct __ns1__getPolicyData *)ptr);
		break;
	case SOAP_TYPE___ns1__getNextData:
		soap_serialize___ns1__getNextData(soap, (const struct __ns1__getNextData *)ptr);
		break;
	case SOAP_TYPE___ns1__getMetricData:
		soap_serialize___ns1__getMetricData(soap, (const struct __ns1__getMetricData *)ptr);
		break;
	case SOAP_TYPE___ns1__getMetricAggregationPeriodList:
		soap_serialize___ns1__getMetricAggregationPeriodList(soap, (const struct __ns1__getMetricAggregationPeriodList *)ptr);
		break;
	case SOAP_TYPE___ns1__getGlobalProperty:
		soap_serialize___ns1__getGlobalProperty(soap, (const struct __ns1__getGlobalProperty *)ptr);
		break;
	case SOAP_TYPE___ns1__getEventState:
		soap_serialize___ns1__getEventState(soap, (const struct __ns1__getEventState *)ptr);
		break;
	case SOAP_TYPE___ns1__getEventHandler:
		soap_serialize___ns1__getEventHandler(soap, (const struct __ns1__getEventHandler *)ptr);
		break;
	case SOAP_TYPE___ns1__getEntityProperties:
		soap_serialize___ns1__getEntityProperties(soap, (const struct __ns1__getEntityProperties *)ptr);
		break;
	case SOAP_TYPE___ns1__getCustomEventData:
		soap_serialize___ns1__getCustomEventData(soap, (const struct __ns1__getCustomEventData *)ptr);
		break;
	case SOAP_TYPE___ns1__getCollectionState:
		soap_serialize___ns1__getCollectionState(soap, (const struct __ns1__getCollectionState *)ptr);
		break;
	case SOAP_TYPE___ns1__getActionLogRecords:
		soap_serialize___ns1__getActionLogRecords(soap, (const struct __ns1__getActionLogRecords *)ptr);
		break;
	case SOAP_TYPE___ns1__findEntities:
		soap_serialize___ns1__findEntities(soap, (const struct __ns1__findEntities *)ptr);
		break;
	case SOAP_TYPE___ns1__exportHierarchy:
		soap_serialize___ns1__exportHierarchy(soap, (const struct __ns1__exportHierarchy *)ptr);
		break;
	case SOAP_TYPE___ns1__enumeratePolicies:
		soap_serialize___ns1__enumeratePolicies(soap, (const struct __ns1__enumeratePolicies *)ptr);
		break;
	case SOAP_TYPE___ns1__enumerateEventHandlers:
		soap_serialize___ns1__enumerateEventHandlers(soap, (const struct __ns1__enumerateEventHandlers *)ptr);
		break;
	case SOAP_TYPE___ns1__enumerateEntities:
		soap_serialize___ns1__enumerateEntities(soap, (const struct __ns1__enumerateEntities *)ptr);
		break;
	case SOAP_TYPE___ns1__enumerateCustomEvents:
		soap_serialize___ns1__enumerateCustomEvents(soap, (const struct __ns1__enumerateCustomEvents *)ptr);
		break;
	case SOAP_TYPE___ns1__disassociateEntity:
		soap_serialize___ns1__disassociateEntity(soap, (const struct __ns1__disassociateEntity *)ptr);
		break;
	case SOAP_TYPE___ns1__deleteSecretKey:
		soap_serialize___ns1__deleteSecretKey(soap, (const struct __ns1__deleteSecretKey *)ptr);
		break;
	case SOAP_TYPE___ns1__defineCustomEvent:
		soap_serialize___ns1__defineCustomEvent(soap, (const struct __ns1__defineCustomEvent *)ptr);
		break;
	case SOAP_TYPE___ns1__associateEntity:
		soap_serialize___ns1__associateEntity(soap, (const struct __ns1__associateEntity *)ptr);
		break;
	case SOAP_TYPE___ns1__addEntity:
		soap_serialize___ns1__addEntity(soap, (const struct __ns1__addEntity *)ptr);
		break;
	case SOAP_TYPE___ns1__updatePolicy:
		soap_serialize___ns1__updatePolicy(soap, (const struct __ns1__updatePolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__setPolicy:
		soap_serialize___ns1__setPolicy(soap, (const struct __ns1__setPolicy *)ptr);
		break;
	case SOAP_TYPE___ns1__getVersion:
		soap_serialize___ns1__getVersion(soap, (const struct __ns1__getVersion *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateCustomEventResponse:
		soap_serialize_PointerTons1__updateCustomEventResponse(soap, (ns1__updateCustomEventResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateCustomEvent:
		soap_serialize_PointerTons1__updateCustomEvent(soap, (ns1__updateCustomEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__unsubscribePredefinedEventResponse:
		soap_serialize_PointerTons1__unsubscribePredefinedEventResponse(soap, (ns1__unsubscribePredefinedEventResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__unsubscribePredefinedEvent:
		soap_serialize_PointerTons1__unsubscribePredefinedEvent(soap, (ns1__unsubscribePredefinedEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__unsubscribeEventHandlerResponse:
		soap_serialize_PointerTons1__unsubscribeEventHandlerResponse(soap, (ns1__unsubscribeEventHandlerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__unsubscribeEventHandler:
		soap_serialize_PointerTons1__unsubscribeEventHandler(soap, (ns1__unsubscribeEventHandler *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__subscribePredefinedEventResponse:
		soap_serialize_PointerTons1__subscribePredefinedEventResponse(soap, (ns1__subscribePredefinedEventResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__subscribePredefinedEvent:
		soap_serialize_PointerTons1__subscribePredefinedEvent(soap, (ns1__subscribePredefinedEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__subscribeEventHandlerResponse:
		soap_serialize_PointerTons1__subscribeEventHandlerResponse(soap, (ns1__subscribeEventHandlerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__subscribeEventHandler:
		soap_serialize_PointerTons1__subscribeEventHandler(soap, (ns1__subscribeEventHandler *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__submitSecretKeyResponse:
		soap_serialize_PointerTons1__submitSecretKeyResponse(soap, (ns1__submitSecretKeyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__submitSecretKey:
		soap_serialize_PointerTons1__submitSecretKey(soap, (ns1__submitSecretKey *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setPolicyStateResponse:
		soap_serialize_PointerTons1__setPolicyStateResponse(soap, (ns1__setPolicyStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setPolicyState:
		soap_serialize_PointerTons1__setPolicyState(soap, (ns1__setPolicyState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setGlobalPropertyResponse:
		soap_serialize_PointerTons1__setGlobalPropertyResponse(soap, (ns1__setGlobalPropertyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setGlobalProperty:
		soap_serialize_PointerTons1__setGlobalProperty(soap, (ns1__setGlobalProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setEventStateResponse:
		soap_serialize_PointerTons1__setEventStateResponse(soap, (ns1__setEventStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setEventState:
		soap_serialize_PointerTons1__setEventState(soap, (ns1__setEventState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setEntityPropertiesResponse:
		soap_serialize_PointerTons1__setEntityPropertiesResponse(soap, (ns1__setEntityPropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setEntityProperties:
		soap_serialize_PointerTons1__setEntityProperties(soap, (ns1__setEntityProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setCollectionStateResponse:
		soap_serialize_PointerTons1__setCollectionStateResponse(soap, (ns1__setCollectionStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setCollectionState:
		soap_serialize_PointerTons1__setCollectionState(soap, (ns1__setCollectionState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__schedulePolicyResponse:
		soap_serialize_PointerTons1__schedulePolicyResponse(soap, (ns1__schedulePolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__schedulePolicy:
		soap_serialize_PointerTons1__schedulePolicy(soap, (ns1__schedulePolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removePolicyResponse:
		soap_serialize_PointerTons1__removePolicyResponse(soap, (ns1__removePolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removePolicy:
		soap_serialize_PointerTons1__removePolicy(soap, (ns1__removePolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeEntityResponse:
		soap_serialize_PointerTons1__removeEntityResponse(soap, (ns1__removeEntityResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeEntity:
		soap_serialize_PointerTons1__removeEntity(soap, (ns1__removeEntity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeCustomEventResponse:
		soap_serialize_PointerTons1__removeCustomEventResponse(soap, (ns1__removeCustomEventResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__removeCustomEvent:
		soap_serialize_PointerTons1__removeCustomEvent(soap, (ns1__removeCustomEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__rediscoverNodeCapabilitiesResponse:
		soap_serialize_PointerTons1__rediscoverNodeCapabilitiesResponse(soap, (ns1__rediscoverNodeCapabilitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__rediscoverNodeCapabilities:
		soap_serialize_PointerTons1__rediscoverNodeCapabilities(soap, (ns1__rediscoverNodeCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__isPolicyActiveResponse:
		soap_serialize_PointerTons1__isPolicyActiveResponse(soap, (ns1__isPolicyActiveResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__isPolicyActive:
		soap_serialize_PointerTons1__isPolicyActive(soap, (ns1__isPolicyActive *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__importHierarchyResponse:
		soap_serialize_PointerTons1__importHierarchyResponse(soap, (ns1__importHierarchyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__importHierarchy:
		soap_serialize_PointerTons1__importHierarchy(soap, (ns1__importHierarchy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getQueryDataResponse:
		soap_serialize_PointerTons1__getQueryDataResponse(soap, (ns1__getQueryDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getQueryData:
		soap_serialize_PointerTons1__getQueryData(soap, (ns1__getQueryData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getQueryAggregationPeriodListResponse:
		soap_serialize_PointerTons1__getQueryAggregationPeriodListResponse(soap, (ns1__getQueryAggregationPeriodListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getQueryAggregationPeriodList:
		soap_serialize_PointerTons1__getQueryAggregationPeriodList(soap, (ns1__getQueryAggregationPeriodList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPredefinedEventTypesResponse:
		soap_serialize_PointerTons1__getPredefinedEventTypesResponse(soap, (ns1__getPredefinedEventTypesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPredefinedEventTypes:
		soap_serialize_PointerTons1__getPredefinedEventTypes(soap, (ns1__getPredefinedEventTypes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPolicyStateResponse:
		soap_serialize_PointerTons1__getPolicyStateResponse(soap, (ns1__getPolicyStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPolicyState:
		soap_serialize_PointerTons1__getPolicyState(soap, (ns1__getPolicyState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPolicyHistoryResponse:
		soap_serialize_PointerTons1__getPolicyHistoryResponse(soap, (ns1__getPolicyHistoryResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPolicyHistory:
		soap_serialize_PointerTons1__getPolicyHistory(soap, (ns1__getPolicyHistory *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPolicyDataResponse:
		soap_serialize_PointerTons1__getPolicyDataResponse(soap, (ns1__getPolicyDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getPolicyData:
		soap_serialize_PointerTons1__getPolicyData(soap, (ns1__getPolicyData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getNextDataResponse:
		soap_serialize_PointerTons1__getNextDataResponse(soap, (ns1__getNextDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getNextData:
		soap_serialize_PointerTons1__getNextData(soap, (ns1__getNextData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMetricDataResponse:
		soap_serialize_PointerTons1__getMetricDataResponse(soap, (ns1__getMetricDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMetricData:
		soap_serialize_PointerTons1__getMetricData(soap, (ns1__getMetricData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMetricAggregationPeriodListResponse:
		soap_serialize_PointerTons1__getMetricAggregationPeriodListResponse(soap, (ns1__getMetricAggregationPeriodListResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getMetricAggregationPeriodList:
		soap_serialize_PointerTons1__getMetricAggregationPeriodList(soap, (ns1__getMetricAggregationPeriodList *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getGlobalPropertyResponse:
		soap_serialize_PointerTons1__getGlobalPropertyResponse(soap, (ns1__getGlobalPropertyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getGlobalProperty:
		soap_serialize_PointerTons1__getGlobalProperty(soap, (ns1__getGlobalProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getEventStateResponse:
		soap_serialize_PointerTons1__getEventStateResponse(soap, (ns1__getEventStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getEventState:
		soap_serialize_PointerTons1__getEventState(soap, (ns1__getEventState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getEventHandlerResponse:
		soap_serialize_PointerTons1__getEventHandlerResponse(soap, (ns1__getEventHandlerResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getEventHandler:
		soap_serialize_PointerTons1__getEventHandler(soap, (ns1__getEventHandler *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getEntityPropertiesResponse:
		soap_serialize_PointerTons1__getEntityPropertiesResponse(soap, (ns1__getEntityPropertiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getEntityProperties:
		soap_serialize_PointerTons1__getEntityProperties(soap, (ns1__getEntityProperties *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCustomEventDataResponse:
		soap_serialize_PointerTons1__getCustomEventDataResponse(soap, (ns1__getCustomEventDataResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCustomEventData:
		soap_serialize_PointerTons1__getCustomEventData(soap, (ns1__getCustomEventData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCollectionStateResponse:
		soap_serialize_PointerTons1__getCollectionStateResponse(soap, (ns1__getCollectionStateResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getCollectionState:
		soap_serialize_PointerTons1__getCollectionState(soap, (ns1__getCollectionState *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getActionLogRecordsResponse:
		soap_serialize_PointerTons1__getActionLogRecordsResponse(soap, (ns1__getActionLogRecordsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getActionLogRecords:
		soap_serialize_PointerTons1__getActionLogRecords(soap, (ns1__getActionLogRecords *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findEntitiesResponse:
		soap_serialize_PointerTons1__findEntitiesResponse(soap, (ns1__findEntitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__findEntities:
		soap_serialize_PointerTons1__findEntities(soap, (ns1__findEntities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__exportHierarchyResponse:
		soap_serialize_PointerTons1__exportHierarchyResponse(soap, (ns1__exportHierarchyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__exportHierarchy:
		soap_serialize_PointerTons1__exportHierarchy(soap, (ns1__exportHierarchy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumeratePoliciesResponse:
		soap_serialize_PointerTons1__enumeratePoliciesResponse(soap, (ns1__enumeratePoliciesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumeratePolicies:
		soap_serialize_PointerTons1__enumeratePolicies(soap, (ns1__enumeratePolicies *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumerateEventHandlersResponse:
		soap_serialize_PointerTons1__enumerateEventHandlersResponse(soap, (ns1__enumerateEventHandlersResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumerateEventHandlers:
		soap_serialize_PointerTons1__enumerateEventHandlers(soap, (ns1__enumerateEventHandlers *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumerateEntitiesResponse:
		soap_serialize_PointerTons1__enumerateEntitiesResponse(soap, (ns1__enumerateEntitiesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumerateEntities:
		soap_serialize_PointerTons1__enumerateEntities(soap, (ns1__enumerateEntities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumerateCustomEventsResponse:
		soap_serialize_PointerTons1__enumerateCustomEventsResponse(soap, (ns1__enumerateCustomEventsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumerateCustomEvents:
		soap_serialize_PointerTons1__enumerateCustomEvents(soap, (ns1__enumerateCustomEvents *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__disassociateEntityResponse:
		soap_serialize_PointerTons1__disassociateEntityResponse(soap, (ns1__disassociateEntityResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__disassociateEntity:
		soap_serialize_PointerTons1__disassociateEntity(soap, (ns1__disassociateEntity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteSecretKeyResponse:
		soap_serialize_PointerTons1__deleteSecretKeyResponse(soap, (ns1__deleteSecretKeyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__deleteSecretKey:
		soap_serialize_PointerTons1__deleteSecretKey(soap, (ns1__deleteSecretKey *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__defineCustomEventResponse:
		soap_serialize_PointerTons1__defineCustomEventResponse(soap, (ns1__defineCustomEventResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__defineCustomEvent:
		soap_serialize_PointerTons1__defineCustomEvent(soap, (ns1__defineCustomEvent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__associateEntityResponse:
		soap_serialize_PointerTons1__associateEntityResponse(soap, (ns1__associateEntityResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__associateEntity:
		soap_serialize_PointerTons1__associateEntity(soap, (ns1__associateEntity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addEntityResponse:
		soap_serialize_PointerTons1__addEntityResponse(soap, (ns1__addEntityResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__addEntity:
		soap_serialize_PointerTons1__addEntity(soap, (ns1__addEntity *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updatePolicyResponse:
		soap_serialize_PointerTons1__updatePolicyResponse(soap, (ns1__updatePolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updatePolicy:
		soap_serialize_PointerTons1__updatePolicy(soap, (ns1__updatePolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setPolicyResponse:
		soap_serialize_PointerTons1__setPolicyResponse(soap, (ns1__setPolicyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__setPolicy:
		soap_serialize_PointerTons1__setPolicy(soap, (ns1__setPolicy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getVersionResponse:
		soap_serialize_PointerTons1__getVersionResponse(soap, (ns1__getVersionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__getVersion:
		soap_serialize_PointerTons1__getVersion(soap, (ns1__getVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Exception:
		soap_serialize_PointerTons1__Exception(soap, (ns1__Exception *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__historyType:
		soap_serialize_PointerTons1__historyType(soap, (enum ns1__historyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__actionLogType:
		soap_serialize_PointerTons1__actionLogType(soap, (enum ns1__actionLogType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__policyData:
		soap_serialize_PointerTons1__policyData(soap, (ns1__policyData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__customEventType:
		soap_serialize_PointerTons1__customEventType(soap, (enum ns1__customEventType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__conditionOperator:
		soap_serialize_PointerTons1__conditionOperator(soap, (enum ns1__conditionOperator *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__customEventData:
		soap_serialize_PointerTons1__customEventData(soap, (ns1__customEventData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__entityType:
		soap_serialize_PointerTons1__entityType(soap, (enum ns1__entityType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__metricType:
		soap_serialize_PointerTons1__metricType(soap, (enum ns1__metricType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__property:
		soap_serialize_PointerTons1__property(soap, (ns1__property *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__globalProperty:
		soap_serialize_PointerTons1__globalProperty(soap, (enum ns1__globalProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__entityProperty:
		soap_serialize_PointerTons1__entityProperty(soap, (enum ns1__entityProperty *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__aggregationPeriod:
		soap_serialize_PointerTons1__aggregationPeriod(soap, (ns1__aggregationPeriod *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__policyType:
		soap_serialize_PointerTons1__policyType(soap, (enum ns1__policyType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ptData:
		soap_serialize_PointerTons1__ptData(soap, (ns1__ptData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__enumerationData:
		soap_serialize_PointerTons1__enumerationData(soap, (ns1__enumerationData *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__aggregationLevel:
		soap_serialize_PointerTons1__aggregationLevel(soap, (enum ns1__aggregationLevel *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__queryType:
		soap_serialize_PointerTons1__queryType(soap, (enum ns1__queryType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_ns1__removePolicy:
		return (void*)soap_instantiate_ns1__removePolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removePolicyResponse:
		return (void*)soap_instantiate_ns1__removePolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Exception:
		return (void*)soap_instantiate_ns1__Exception(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getQueryData:
		return (void*)soap_instantiate_ns1__getQueryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getQueryDataResponse:
		return (void*)soap_instantiate_ns1__getQueryDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumerationData:
		return (void*)soap_instantiate_ns1__enumerationData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ptData:
		return (void*)soap_instantiate_ns1__ptData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setPolicy:
		return (void*)soap_instantiate_ns1__setPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setPolicyResponse:
		return (void*)soap_instantiate_ns1__setPolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__schedulePolicy:
		return (void*)soap_instantiate_ns1__schedulePolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__schedulePolicyResponse:
		return (void*)soap_instantiate_ns1__schedulePolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getNextData:
		return (void*)soap_instantiate_ns1__getNextData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getNextDataResponse:
		return (void*)soap_instantiate_ns1__getNextDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__importHierarchy:
		return (void*)soap_instantiate_ns1__importHierarchy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__importHierarchyResponse:
		return (void*)soap_instantiate_ns1__importHierarchyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__isPolicyActive:
		return (void*)soap_instantiate_ns1__isPolicyActive(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__isPolicyActiveResponse:
		return (void*)soap_instantiate_ns1__isPolicyActiveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getQueryAggregationPeriodList:
		return (void*)soap_instantiate_ns1__getQueryAggregationPeriodList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse:
		return (void*)soap_instantiate_ns1__getQueryAggregationPeriodListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__aggregationPeriod:
		return (void*)soap_instantiate_ns1__aggregationPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumerateEventHandlers:
		return (void*)soap_instantiate_ns1__enumerateEventHandlers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumerateEventHandlersResponse:
		return (void*)soap_instantiate_ns1__enumerateEventHandlersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__exportHierarchy:
		return (void*)soap_instantiate_ns1__exportHierarchy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__exportHierarchyResponse:
		return (void*)soap_instantiate_ns1__exportHierarchyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findEntities:
		return (void*)soap_instantiate_ns1__findEntities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__findEntitiesResponse:
		return (void*)soap_instantiate_ns1__findEntitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVersion:
		return (void*)soap_instantiate_ns1__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getVersionResponse:
		return (void*)soap_instantiate_ns1__getVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__subscribePredefinedEvent:
		return (void*)soap_instantiate_ns1__subscribePredefinedEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__subscribePredefinedEventResponse:
		return (void*)soap_instantiate_ns1__subscribePredefinedEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setGlobalProperty:
		return (void*)soap_instantiate_ns1__setGlobalProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setGlobalPropertyResponse:
		return (void*)soap_instantiate_ns1__setGlobalPropertyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setCollectionState:
		return (void*)soap_instantiate_ns1__setCollectionState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setCollectionStateResponse:
		return (void*)soap_instantiate_ns1__setCollectionStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeEntity:
		return (void*)soap_instantiate_ns1__removeEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeEntityResponse:
		return (void*)soap_instantiate_ns1__removeEntityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__rediscoverNodeCapabilities:
		return (void*)soap_instantiate_ns1__rediscoverNodeCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse:
		return (void*)soap_instantiate_ns1__rediscoverNodeCapabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updatePolicy:
		return (void*)soap_instantiate_ns1__updatePolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updatePolicyResponse:
		return (void*)soap_instantiate_ns1__updatePolicyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalProperty:
		return (void*)soap_instantiate_ns1__getGlobalProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getGlobalPropertyResponse:
		return (void*)soap_instantiate_ns1__getGlobalPropertyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__subscribeEventHandler:
		return (void*)soap_instantiate_ns1__subscribeEventHandler(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__subscribeEventHandlerResponse:
		return (void*)soap_instantiate_ns1__subscribeEventHandlerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setEventState:
		return (void*)soap_instantiate_ns1__setEventState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setEventStateResponse:
		return (void*)soap_instantiate_ns1__setEventStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setEntityProperties:
		return (void*)soap_instantiate_ns1__setEntityProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__property:
		return (void*)soap_instantiate_ns1__property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setEntityPropertiesResponse:
		return (void*)soap_instantiate_ns1__setEntityPropertiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__submitSecretKey:
		return (void*)soap_instantiate_ns1__submitSecretKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__submitSecretKeyResponse:
		return (void*)soap_instantiate_ns1__submitSecretKeyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeCustomEvent:
		return (void*)soap_instantiate_ns1__removeCustomEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__removeCustomEventResponse:
		return (void*)soap_instantiate_ns1__removeCustomEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__disassociateEntity:
		return (void*)soap_instantiate_ns1__disassociateEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__disassociateEntityResponse:
		return (void*)soap_instantiate_ns1__disassociateEntityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetricData:
		return (void*)soap_instantiate_ns1__getMetricData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetricDataResponse:
		return (void*)soap_instantiate_ns1__getMetricDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addEntity:
		return (void*)soap_instantiate_ns1__addEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__addEntityResponse:
		return (void*)soap_instantiate_ns1__addEntityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEventHandler:
		return (void*)soap_instantiate_ns1__getEventHandler(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEventHandlerResponse:
		return (void*)soap_instantiate_ns1__getEventHandlerResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomEventData:
		return (void*)soap_instantiate_ns1__getCustomEventData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCustomEventDataResponse:
		return (void*)soap_instantiate_ns1__getCustomEventDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__customEventData:
		return (void*)soap_instantiate_ns1__customEventData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPredefinedEventTypes:
		return (void*)soap_instantiate_ns1__getPredefinedEventTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPredefinedEventTypesResponse:
		return (void*)soap_instantiate_ns1__getPredefinedEventTypesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumerateCustomEvents:
		return (void*)soap_instantiate_ns1__enumerateCustomEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumerateCustomEventsResponse:
		return (void*)soap_instantiate_ns1__enumerateCustomEventsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumeratePolicies:
		return (void*)soap_instantiate_ns1__enumeratePolicies(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumeratePoliciesResponse:
		return (void*)soap_instantiate_ns1__enumeratePoliciesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPolicyState:
		return (void*)soap_instantiate_ns1__getPolicyState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPolicyStateResponse:
		return (void*)soap_instantiate_ns1__getPolicyStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateCustomEvent:
		return (void*)soap_instantiate_ns1__updateCustomEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateCustomEventResponse:
		return (void*)soap_instantiate_ns1__updateCustomEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unsubscribePredefinedEvent:
		return (void*)soap_instantiate_ns1__unsubscribePredefinedEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unsubscribePredefinedEventResponse:
		return (void*)soap_instantiate_ns1__unsubscribePredefinedEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteSecretKey:
		return (void*)soap_instantiate_ns1__deleteSecretKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__deleteSecretKeyResponse:
		return (void*)soap_instantiate_ns1__deleteSecretKeyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCollectionState:
		return (void*)soap_instantiate_ns1__getCollectionState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getCollectionStateResponse:
		return (void*)soap_instantiate_ns1__getCollectionStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumerateEntities:
		return (void*)soap_instantiate_ns1__enumerateEntities(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__enumerateEntitiesResponse:
		return (void*)soap_instantiate_ns1__enumerateEntitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__defineCustomEvent:
		return (void*)soap_instantiate_ns1__defineCustomEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__defineCustomEventResponse:
		return (void*)soap_instantiate_ns1__defineCustomEventResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetricAggregationPeriodList:
		return (void*)soap_instantiate_ns1__getMetricAggregationPeriodList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse:
		return (void*)soap_instantiate_ns1__getMetricAggregationPeriodListResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPolicyData:
		return (void*)soap_instantiate_ns1__getPolicyData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPolicyDataResponse:
		return (void*)soap_instantiate_ns1__getPolicyDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__policyData:
		return (void*)soap_instantiate_ns1__policyData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setPolicyState:
		return (void*)soap_instantiate_ns1__setPolicyState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__setPolicyStateResponse:
		return (void*)soap_instantiate_ns1__setPolicyStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getActionLogRecords:
		return (void*)soap_instantiate_ns1__getActionLogRecords(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getActionLogRecordsResponse:
		return (void*)soap_instantiate_ns1__getActionLogRecordsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPolicyHistory:
		return (void*)soap_instantiate_ns1__getPolicyHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getPolicyHistoryResponse:
		return (void*)soap_instantiate_ns1__getPolicyHistoryResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__associateEntity:
		return (void*)soap_instantiate_ns1__associateEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__associateEntityResponse:
		return (void*)soap_instantiate_ns1__associateEntityResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEventState:
		return (void*)soap_instantiate_ns1__getEventState(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEventStateResponse:
		return (void*)soap_instantiate_ns1__getEventStateResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEntityProperties:
		return (void*)soap_instantiate_ns1__getEntityProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__getEntityPropertiesResponse:
		return (void*)soap_instantiate_ns1__getEntityPropertiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unsubscribeEventHandler:
		return (void*)soap_instantiate_ns1__unsubscribeEventHandler(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__unsubscribeEventHandlerResponse:
		return (void*)soap_instantiate_ns1__unsubscribeEventHandlerResponse(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE___ns1__getVersion:
		return (void*)soap_instantiate___ns1__getVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setPolicy:
		return (void*)soap_instantiate___ns1__setPolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updatePolicy:
		return (void*)soap_instantiate___ns1__updatePolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__addEntity:
		return (void*)soap_instantiate___ns1__addEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__associateEntity:
		return (void*)soap_instantiate___ns1__associateEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__defineCustomEvent:
		return (void*)soap_instantiate___ns1__defineCustomEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__deleteSecretKey:
		return (void*)soap_instantiate___ns1__deleteSecretKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__disassociateEntity:
		return (void*)soap_instantiate___ns1__disassociateEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enumerateCustomEvents:
		return (void*)soap_instantiate___ns1__enumerateCustomEvents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enumerateEntities:
		return (void*)soap_instantiate___ns1__enumerateEntities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enumerateEventHandlers:
		return (void*)soap_instantiate___ns1__enumerateEventHandlers(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__enumeratePolicies:
		return (void*)soap_instantiate___ns1__enumeratePolicies(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__exportHierarchy:
		return (void*)soap_instantiate___ns1__exportHierarchy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__findEntities:
		return (void*)soap_instantiate___ns1__findEntities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getActionLogRecords:
		return (void*)soap_instantiate___ns1__getActionLogRecords(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCollectionState:
		return (void*)soap_instantiate___ns1__getCollectionState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getCustomEventData:
		return (void*)soap_instantiate___ns1__getCustomEventData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getEntityProperties:
		return (void*)soap_instantiate___ns1__getEntityProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getEventHandler:
		return (void*)soap_instantiate___ns1__getEventHandler(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getEventState:
		return (void*)soap_instantiate___ns1__getEventState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getGlobalProperty:
		return (void*)soap_instantiate___ns1__getGlobalProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMetricAggregationPeriodList:
		return (void*)soap_instantiate___ns1__getMetricAggregationPeriodList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getMetricData:
		return (void*)soap_instantiate___ns1__getMetricData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getNextData:
		return (void*)soap_instantiate___ns1__getNextData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPolicyData:
		return (void*)soap_instantiate___ns1__getPolicyData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPolicyHistory:
		return (void*)soap_instantiate___ns1__getPolicyHistory(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPolicyState:
		return (void*)soap_instantiate___ns1__getPolicyState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getPredefinedEventTypes:
		return (void*)soap_instantiate___ns1__getPredefinedEventTypes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getQueryAggregationPeriodList:
		return (void*)soap_instantiate___ns1__getQueryAggregationPeriodList(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__getQueryData:
		return (void*)soap_instantiate___ns1__getQueryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__importHierarchy:
		return (void*)soap_instantiate___ns1__importHierarchy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__isPolicyActive:
		return (void*)soap_instantiate___ns1__isPolicyActive(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__rediscoverNodeCapabilities:
		return (void*)soap_instantiate___ns1__rediscoverNodeCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeCustomEvent:
		return (void*)soap_instantiate___ns1__removeCustomEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removeEntity:
		return (void*)soap_instantiate___ns1__removeEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__removePolicy:
		return (void*)soap_instantiate___ns1__removePolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__schedulePolicy:
		return (void*)soap_instantiate___ns1__schedulePolicy(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setCollectionState:
		return (void*)soap_instantiate___ns1__setCollectionState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setEntityProperties:
		return (void*)soap_instantiate___ns1__setEntityProperties(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setEventState:
		return (void*)soap_instantiate___ns1__setEventState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setGlobalProperty:
		return (void*)soap_instantiate___ns1__setGlobalProperty(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__setPolicyState:
		return (void*)soap_instantiate___ns1__setPolicyState(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__submitSecretKey:
		return (void*)soap_instantiate___ns1__submitSecretKey(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__subscribeEventHandler:
		return (void*)soap_instantiate___ns1__subscribeEventHandler(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__subscribePredefinedEvent:
		return (void*)soap_instantiate___ns1__subscribePredefinedEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__unsubscribeEventHandler:
		return (void*)soap_instantiate___ns1__unsubscribeEventHandler(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__unsubscribePredefinedEvent:
		return (void*)soap_instantiate___ns1__unsubscribePredefinedEvent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateCustomEvent:
		return (void*)soap_instantiate___ns1__updateCustomEvent(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		return (void*)soap_instantiate_std__vectorTemplateOfstd__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__property:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__property(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__predefinedEventType:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__predefinedEventType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__aggregationPeriod:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfns1__day:
		return (void*)soap_instantiate_std__vectorTemplateOfns1__day(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfint:
		return (void*)soap_instantiate_std__vectorTemplateOfint(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ptData:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__ptData(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_ns1__removePolicy:
		if (p->size < 0)
			delete (ns1__removePolicy*)p->ptr;
		else
			delete[] (ns1__removePolicy*)p->ptr;
		break;
	case SOAP_TYPE_ns1__removePolicyResponse:
		if (p->size < 0)
			delete (ns1__removePolicyResponse*)p->ptr;
		else
			delete[] (ns1__removePolicyResponse*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__Exception:
		if (p->size < 0)
			delete (ns1__Exception*)p->ptr;
		else
			delete[] (ns1__Exception*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getQueryData:
		if (p->size < 0)
			delete (ns1__getQueryData*)p->ptr;
		else
			delete[] (ns1__getQueryData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getQueryDataResponse:
		if (p->size < 0)
			delete (ns1__getQueryDataResponse*)p->ptr;
		else
			delete[] (ns1__getQueryDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumerationData:
		if (p->size < 0)
			delete (ns1__enumerationData*)p->ptr;
		else
			delete[] (ns1__enumerationData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ptData:
		if (p->size < 0)
			delete (ns1__ptData*)p->ptr;
		else
			delete[] (ns1__ptData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setPolicy:
		if (p->size < 0)
			delete (ns1__setPolicy*)p->ptr;
		else
			delete[] (ns1__setPolicy*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setPolicyResponse:
		if (p->size < 0)
			delete (ns1__setPolicyResponse*)p->ptr;
		else
			delete[] (ns1__setPolicyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__schedulePolicy:
		if (p->size < 0)
			delete (ns1__schedulePolicy*)p->ptr;
		else
			delete[] (ns1__schedulePolicy*)p->ptr;
		break;
	case SOAP_TYPE_ns1__schedulePolicyResponse:
		if (p->size < 0)
			delete (ns1__schedulePolicyResponse*)p->ptr;
		else
			delete[] (ns1__schedulePolicyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getNextData:
		if (p->size < 0)
			delete (ns1__getNextData*)p->ptr;
		else
			delete[] (ns1__getNextData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getNextDataResponse:
		if (p->size < 0)
			delete (ns1__getNextDataResponse*)p->ptr;
		else
			delete[] (ns1__getNextDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__importHierarchy:
		if (p->size < 0)
			delete (ns1__importHierarchy*)p->ptr;
		else
			delete[] (ns1__importHierarchy*)p->ptr;
		break;
	case SOAP_TYPE_ns1__importHierarchyResponse:
		if (p->size < 0)
			delete (ns1__importHierarchyResponse*)p->ptr;
		else
			delete[] (ns1__importHierarchyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__isPolicyActive:
		if (p->size < 0)
			delete (ns1__isPolicyActive*)p->ptr;
		else
			delete[] (ns1__isPolicyActive*)p->ptr;
		break;
	case SOAP_TYPE_ns1__isPolicyActiveResponse:
		if (p->size < 0)
			delete (ns1__isPolicyActiveResponse*)p->ptr;
		else
			delete[] (ns1__isPolicyActiveResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getQueryAggregationPeriodList:
		if (p->size < 0)
			delete (ns1__getQueryAggregationPeriodList*)p->ptr;
		else
			delete[] (ns1__getQueryAggregationPeriodList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse:
		if (p->size < 0)
			delete (ns1__getQueryAggregationPeriodListResponse*)p->ptr;
		else
			delete[] (ns1__getQueryAggregationPeriodListResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__aggregationPeriod:
		if (p->size < 0)
			delete (ns1__aggregationPeriod*)p->ptr;
		else
			delete[] (ns1__aggregationPeriod*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumerateEventHandlers:
		if (p->size < 0)
			delete (ns1__enumerateEventHandlers*)p->ptr;
		else
			delete[] (ns1__enumerateEventHandlers*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumerateEventHandlersResponse:
		if (p->size < 0)
			delete (ns1__enumerateEventHandlersResponse*)p->ptr;
		else
			delete[] (ns1__enumerateEventHandlersResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__exportHierarchy:
		if (p->size < 0)
			delete (ns1__exportHierarchy*)p->ptr;
		else
			delete[] (ns1__exportHierarchy*)p->ptr;
		break;
	case SOAP_TYPE_ns1__exportHierarchyResponse:
		if (p->size < 0)
			delete (ns1__exportHierarchyResponse*)p->ptr;
		else
			delete[] (ns1__exportHierarchyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findEntities:
		if (p->size < 0)
			delete (ns1__findEntities*)p->ptr;
		else
			delete[] (ns1__findEntities*)p->ptr;
		break;
	case SOAP_TYPE_ns1__findEntitiesResponse:
		if (p->size < 0)
			delete (ns1__findEntitiesResponse*)p->ptr;
		else
			delete[] (ns1__findEntitiesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getVersion:
		if (p->size < 0)
			delete (ns1__getVersion*)p->ptr;
		else
			delete[] (ns1__getVersion*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getVersionResponse:
		if (p->size < 0)
			delete (ns1__getVersionResponse*)p->ptr;
		else
			delete[] (ns1__getVersionResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__subscribePredefinedEvent:
		if (p->size < 0)
			delete (ns1__subscribePredefinedEvent*)p->ptr;
		else
			delete[] (ns1__subscribePredefinedEvent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__subscribePredefinedEventResponse:
		if (p->size < 0)
			delete (ns1__subscribePredefinedEventResponse*)p->ptr;
		else
			delete[] (ns1__subscribePredefinedEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setGlobalProperty:
		if (p->size < 0)
			delete (ns1__setGlobalProperty*)p->ptr;
		else
			delete[] (ns1__setGlobalProperty*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setGlobalPropertyResponse:
		if (p->size < 0)
			delete (ns1__setGlobalPropertyResponse*)p->ptr;
		else
			delete[] (ns1__setGlobalPropertyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setCollectionState:
		if (p->size < 0)
			delete (ns1__setCollectionState*)p->ptr;
		else
			delete[] (ns1__setCollectionState*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setCollectionStateResponse:
		if (p->size < 0)
			delete (ns1__setCollectionStateResponse*)p->ptr;
		else
			delete[] (ns1__setCollectionStateResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__removeEntity:
		if (p->size < 0)
			delete (ns1__removeEntity*)p->ptr;
		else
			delete[] (ns1__removeEntity*)p->ptr;
		break;
	case SOAP_TYPE_ns1__removeEntityResponse:
		if (p->size < 0)
			delete (ns1__removeEntityResponse*)p->ptr;
		else
			delete[] (ns1__removeEntityResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__rediscoverNodeCapabilities:
		if (p->size < 0)
			delete (ns1__rediscoverNodeCapabilities*)p->ptr;
		else
			delete[] (ns1__rediscoverNodeCapabilities*)p->ptr;
		break;
	case SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse:
		if (p->size < 0)
			delete (ns1__rediscoverNodeCapabilitiesResponse*)p->ptr;
		else
			delete[] (ns1__rediscoverNodeCapabilitiesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__updatePolicy:
		if (p->size < 0)
			delete (ns1__updatePolicy*)p->ptr;
		else
			delete[] (ns1__updatePolicy*)p->ptr;
		break;
	case SOAP_TYPE_ns1__updatePolicyResponse:
		if (p->size < 0)
			delete (ns1__updatePolicyResponse*)p->ptr;
		else
			delete[] (ns1__updatePolicyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getGlobalProperty:
		if (p->size < 0)
			delete (ns1__getGlobalProperty*)p->ptr;
		else
			delete[] (ns1__getGlobalProperty*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getGlobalPropertyResponse:
		if (p->size < 0)
			delete (ns1__getGlobalPropertyResponse*)p->ptr;
		else
			delete[] (ns1__getGlobalPropertyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__subscribeEventHandler:
		if (p->size < 0)
			delete (ns1__subscribeEventHandler*)p->ptr;
		else
			delete[] (ns1__subscribeEventHandler*)p->ptr;
		break;
	case SOAP_TYPE_ns1__subscribeEventHandlerResponse:
		if (p->size < 0)
			delete (ns1__subscribeEventHandlerResponse*)p->ptr;
		else
			delete[] (ns1__subscribeEventHandlerResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setEventState:
		if (p->size < 0)
			delete (ns1__setEventState*)p->ptr;
		else
			delete[] (ns1__setEventState*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setEventStateResponse:
		if (p->size < 0)
			delete (ns1__setEventStateResponse*)p->ptr;
		else
			delete[] (ns1__setEventStateResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setEntityProperties:
		if (p->size < 0)
			delete (ns1__setEntityProperties*)p->ptr;
		else
			delete[] (ns1__setEntityProperties*)p->ptr;
		break;
	case SOAP_TYPE_ns1__property:
		if (p->size < 0)
			delete (ns1__property*)p->ptr;
		else
			delete[] (ns1__property*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setEntityPropertiesResponse:
		if (p->size < 0)
			delete (ns1__setEntityPropertiesResponse*)p->ptr;
		else
			delete[] (ns1__setEntityPropertiesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__submitSecretKey:
		if (p->size < 0)
			delete (ns1__submitSecretKey*)p->ptr;
		else
			delete[] (ns1__submitSecretKey*)p->ptr;
		break;
	case SOAP_TYPE_ns1__submitSecretKeyResponse:
		if (p->size < 0)
			delete (ns1__submitSecretKeyResponse*)p->ptr;
		else
			delete[] (ns1__submitSecretKeyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__removeCustomEvent:
		if (p->size < 0)
			delete (ns1__removeCustomEvent*)p->ptr;
		else
			delete[] (ns1__removeCustomEvent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__removeCustomEventResponse:
		if (p->size < 0)
			delete (ns1__removeCustomEventResponse*)p->ptr;
		else
			delete[] (ns1__removeCustomEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__disassociateEntity:
		if (p->size < 0)
			delete (ns1__disassociateEntity*)p->ptr;
		else
			delete[] (ns1__disassociateEntity*)p->ptr;
		break;
	case SOAP_TYPE_ns1__disassociateEntityResponse:
		if (p->size < 0)
			delete (ns1__disassociateEntityResponse*)p->ptr;
		else
			delete[] (ns1__disassociateEntityResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getMetricData:
		if (p->size < 0)
			delete (ns1__getMetricData*)p->ptr;
		else
			delete[] (ns1__getMetricData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getMetricDataResponse:
		if (p->size < 0)
			delete (ns1__getMetricDataResponse*)p->ptr;
		else
			delete[] (ns1__getMetricDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__addEntity:
		if (p->size < 0)
			delete (ns1__addEntity*)p->ptr;
		else
			delete[] (ns1__addEntity*)p->ptr;
		break;
	case SOAP_TYPE_ns1__addEntityResponse:
		if (p->size < 0)
			delete (ns1__addEntityResponse*)p->ptr;
		else
			delete[] (ns1__addEntityResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getEventHandler:
		if (p->size < 0)
			delete (ns1__getEventHandler*)p->ptr;
		else
			delete[] (ns1__getEventHandler*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getEventHandlerResponse:
		if (p->size < 0)
			delete (ns1__getEventHandlerResponse*)p->ptr;
		else
			delete[] (ns1__getEventHandlerResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getCustomEventData:
		if (p->size < 0)
			delete (ns1__getCustomEventData*)p->ptr;
		else
			delete[] (ns1__getCustomEventData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getCustomEventDataResponse:
		if (p->size < 0)
			delete (ns1__getCustomEventDataResponse*)p->ptr;
		else
			delete[] (ns1__getCustomEventDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__customEventData:
		if (p->size < 0)
			delete (ns1__customEventData*)p->ptr;
		else
			delete[] (ns1__customEventData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPredefinedEventTypes:
		if (p->size < 0)
			delete (ns1__getPredefinedEventTypes*)p->ptr;
		else
			delete[] (ns1__getPredefinedEventTypes*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPredefinedEventTypesResponse:
		if (p->size < 0)
			delete (ns1__getPredefinedEventTypesResponse*)p->ptr;
		else
			delete[] (ns1__getPredefinedEventTypesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumerateCustomEvents:
		if (p->size < 0)
			delete (ns1__enumerateCustomEvents*)p->ptr;
		else
			delete[] (ns1__enumerateCustomEvents*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumerateCustomEventsResponse:
		if (p->size < 0)
			delete (ns1__enumerateCustomEventsResponse*)p->ptr;
		else
			delete[] (ns1__enumerateCustomEventsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumeratePolicies:
		if (p->size < 0)
			delete (ns1__enumeratePolicies*)p->ptr;
		else
			delete[] (ns1__enumeratePolicies*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumeratePoliciesResponse:
		if (p->size < 0)
			delete (ns1__enumeratePoliciesResponse*)p->ptr;
		else
			delete[] (ns1__enumeratePoliciesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPolicyState:
		if (p->size < 0)
			delete (ns1__getPolicyState*)p->ptr;
		else
			delete[] (ns1__getPolicyState*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPolicyStateResponse:
		if (p->size < 0)
			delete (ns1__getPolicyStateResponse*)p->ptr;
		else
			delete[] (ns1__getPolicyStateResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__updateCustomEvent:
		if (p->size < 0)
			delete (ns1__updateCustomEvent*)p->ptr;
		else
			delete[] (ns1__updateCustomEvent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__updateCustomEventResponse:
		if (p->size < 0)
			delete (ns1__updateCustomEventResponse*)p->ptr;
		else
			delete[] (ns1__updateCustomEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__unsubscribePredefinedEvent:
		if (p->size < 0)
			delete (ns1__unsubscribePredefinedEvent*)p->ptr;
		else
			delete[] (ns1__unsubscribePredefinedEvent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__unsubscribePredefinedEventResponse:
		if (p->size < 0)
			delete (ns1__unsubscribePredefinedEventResponse*)p->ptr;
		else
			delete[] (ns1__unsubscribePredefinedEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__deleteSecretKey:
		if (p->size < 0)
			delete (ns1__deleteSecretKey*)p->ptr;
		else
			delete[] (ns1__deleteSecretKey*)p->ptr;
		break;
	case SOAP_TYPE_ns1__deleteSecretKeyResponse:
		if (p->size < 0)
			delete (ns1__deleteSecretKeyResponse*)p->ptr;
		else
			delete[] (ns1__deleteSecretKeyResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getCollectionState:
		if (p->size < 0)
			delete (ns1__getCollectionState*)p->ptr;
		else
			delete[] (ns1__getCollectionState*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getCollectionStateResponse:
		if (p->size < 0)
			delete (ns1__getCollectionStateResponse*)p->ptr;
		else
			delete[] (ns1__getCollectionStateResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumerateEntities:
		if (p->size < 0)
			delete (ns1__enumerateEntities*)p->ptr;
		else
			delete[] (ns1__enumerateEntities*)p->ptr;
		break;
	case SOAP_TYPE_ns1__enumerateEntitiesResponse:
		if (p->size < 0)
			delete (ns1__enumerateEntitiesResponse*)p->ptr;
		else
			delete[] (ns1__enumerateEntitiesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__defineCustomEvent:
		if (p->size < 0)
			delete (ns1__defineCustomEvent*)p->ptr;
		else
			delete[] (ns1__defineCustomEvent*)p->ptr;
		break;
	case SOAP_TYPE_ns1__defineCustomEventResponse:
		if (p->size < 0)
			delete (ns1__defineCustomEventResponse*)p->ptr;
		else
			delete[] (ns1__defineCustomEventResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getMetricAggregationPeriodList:
		if (p->size < 0)
			delete (ns1__getMetricAggregationPeriodList*)p->ptr;
		else
			delete[] (ns1__getMetricAggregationPeriodList*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse:
		if (p->size < 0)
			delete (ns1__getMetricAggregationPeriodListResponse*)p->ptr;
		else
			delete[] (ns1__getMetricAggregationPeriodListResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPolicyData:
		if (p->size < 0)
			delete (ns1__getPolicyData*)p->ptr;
		else
			delete[] (ns1__getPolicyData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPolicyDataResponse:
		if (p->size < 0)
			delete (ns1__getPolicyDataResponse*)p->ptr;
		else
			delete[] (ns1__getPolicyDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__policyData:
		if (p->size < 0)
			delete (ns1__policyData*)p->ptr;
		else
			delete[] (ns1__policyData*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setPolicyState:
		if (p->size < 0)
			delete (ns1__setPolicyState*)p->ptr;
		else
			delete[] (ns1__setPolicyState*)p->ptr;
		break;
	case SOAP_TYPE_ns1__setPolicyStateResponse:
		if (p->size < 0)
			delete (ns1__setPolicyStateResponse*)p->ptr;
		else
			delete[] (ns1__setPolicyStateResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getActionLogRecords:
		if (p->size < 0)
			delete (ns1__getActionLogRecords*)p->ptr;
		else
			delete[] (ns1__getActionLogRecords*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getActionLogRecordsResponse:
		if (p->size < 0)
			delete (ns1__getActionLogRecordsResponse*)p->ptr;
		else
			delete[] (ns1__getActionLogRecordsResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPolicyHistory:
		if (p->size < 0)
			delete (ns1__getPolicyHistory*)p->ptr;
		else
			delete[] (ns1__getPolicyHistory*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getPolicyHistoryResponse:
		if (p->size < 0)
			delete (ns1__getPolicyHistoryResponse*)p->ptr;
		else
			delete[] (ns1__getPolicyHistoryResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__associateEntity:
		if (p->size < 0)
			delete (ns1__associateEntity*)p->ptr;
		else
			delete[] (ns1__associateEntity*)p->ptr;
		break;
	case SOAP_TYPE_ns1__associateEntityResponse:
		if (p->size < 0)
			delete (ns1__associateEntityResponse*)p->ptr;
		else
			delete[] (ns1__associateEntityResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getEventState:
		if (p->size < 0)
			delete (ns1__getEventState*)p->ptr;
		else
			delete[] (ns1__getEventState*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getEventStateResponse:
		if (p->size < 0)
			delete (ns1__getEventStateResponse*)p->ptr;
		else
			delete[] (ns1__getEventStateResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getEntityProperties:
		if (p->size < 0)
			delete (ns1__getEntityProperties*)p->ptr;
		else
			delete[] (ns1__getEntityProperties*)p->ptr;
		break;
	case SOAP_TYPE_ns1__getEntityPropertiesResponse:
		if (p->size < 0)
			delete (ns1__getEntityPropertiesResponse*)p->ptr;
		else
			delete[] (ns1__getEntityPropertiesResponse*)p->ptr;
		break;
	case SOAP_TYPE_ns1__unsubscribeEventHandler:
		if (p->size < 0)
			delete (ns1__unsubscribeEventHandler*)p->ptr;
		else
			delete[] (ns1__unsubscribeEventHandler*)p->ptr;
		break;
	case SOAP_TYPE_ns1__unsubscribeEventHandlerResponse:
		if (p->size < 0)
			delete (ns1__unsubscribeEventHandlerResponse*)p->ptr;
		else
			delete[] (ns1__unsubscribeEventHandlerResponse*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getVersion:
		if (p->size < 0)
			delete (struct __ns1__getVersion*)p->ptr;
		else
			delete[] (struct __ns1__getVersion*)p->ptr;
		break;
	case SOAP_TYPE___ns1__setPolicy:
		if (p->size < 0)
			delete (struct __ns1__setPolicy*)p->ptr;
		else
			delete[] (struct __ns1__setPolicy*)p->ptr;
		break;
	case SOAP_TYPE___ns1__updatePolicy:
		if (p->size < 0)
			delete (struct __ns1__updatePolicy*)p->ptr;
		else
			delete[] (struct __ns1__updatePolicy*)p->ptr;
		break;
	case SOAP_TYPE___ns1__addEntity:
		if (p->size < 0)
			delete (struct __ns1__addEntity*)p->ptr;
		else
			delete[] (struct __ns1__addEntity*)p->ptr;
		break;
	case SOAP_TYPE___ns1__associateEntity:
		if (p->size < 0)
			delete (struct __ns1__associateEntity*)p->ptr;
		else
			delete[] (struct __ns1__associateEntity*)p->ptr;
		break;
	case SOAP_TYPE___ns1__defineCustomEvent:
		if (p->size < 0)
			delete (struct __ns1__defineCustomEvent*)p->ptr;
		else
			delete[] (struct __ns1__defineCustomEvent*)p->ptr;
		break;
	case SOAP_TYPE___ns1__deleteSecretKey:
		if (p->size < 0)
			delete (struct __ns1__deleteSecretKey*)p->ptr;
		else
			delete[] (struct __ns1__deleteSecretKey*)p->ptr;
		break;
	case SOAP_TYPE___ns1__disassociateEntity:
		if (p->size < 0)
			delete (struct __ns1__disassociateEntity*)p->ptr;
		else
			delete[] (struct __ns1__disassociateEntity*)p->ptr;
		break;
	case SOAP_TYPE___ns1__enumerateCustomEvents:
		if (p->size < 0)
			delete (struct __ns1__enumerateCustomEvents*)p->ptr;
		else
			delete[] (struct __ns1__enumerateCustomEvents*)p->ptr;
		break;
	case SOAP_TYPE___ns1__enumerateEntities:
		if (p->size < 0)
			delete (struct __ns1__enumerateEntities*)p->ptr;
		else
			delete[] (struct __ns1__enumerateEntities*)p->ptr;
		break;
	case SOAP_TYPE___ns1__enumerateEventHandlers:
		if (p->size < 0)
			delete (struct __ns1__enumerateEventHandlers*)p->ptr;
		else
			delete[] (struct __ns1__enumerateEventHandlers*)p->ptr;
		break;
	case SOAP_TYPE___ns1__enumeratePolicies:
		if (p->size < 0)
			delete (struct __ns1__enumeratePolicies*)p->ptr;
		else
			delete[] (struct __ns1__enumeratePolicies*)p->ptr;
		break;
	case SOAP_TYPE___ns1__exportHierarchy:
		if (p->size < 0)
			delete (struct __ns1__exportHierarchy*)p->ptr;
		else
			delete[] (struct __ns1__exportHierarchy*)p->ptr;
		break;
	case SOAP_TYPE___ns1__findEntities:
		if (p->size < 0)
			delete (struct __ns1__findEntities*)p->ptr;
		else
			delete[] (struct __ns1__findEntities*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getActionLogRecords:
		if (p->size < 0)
			delete (struct __ns1__getActionLogRecords*)p->ptr;
		else
			delete[] (struct __ns1__getActionLogRecords*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getCollectionState:
		if (p->size < 0)
			delete (struct __ns1__getCollectionState*)p->ptr;
		else
			delete[] (struct __ns1__getCollectionState*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getCustomEventData:
		if (p->size < 0)
			delete (struct __ns1__getCustomEventData*)p->ptr;
		else
			delete[] (struct __ns1__getCustomEventData*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getEntityProperties:
		if (p->size < 0)
			delete (struct __ns1__getEntityProperties*)p->ptr;
		else
			delete[] (struct __ns1__getEntityProperties*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getEventHandler:
		if (p->size < 0)
			delete (struct __ns1__getEventHandler*)p->ptr;
		else
			delete[] (struct __ns1__getEventHandler*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getEventState:
		if (p->size < 0)
			delete (struct __ns1__getEventState*)p->ptr;
		else
			delete[] (struct __ns1__getEventState*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getGlobalProperty:
		if (p->size < 0)
			delete (struct __ns1__getGlobalProperty*)p->ptr;
		else
			delete[] (struct __ns1__getGlobalProperty*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getMetricAggregationPeriodList:
		if (p->size < 0)
			delete (struct __ns1__getMetricAggregationPeriodList*)p->ptr;
		else
			delete[] (struct __ns1__getMetricAggregationPeriodList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getMetricData:
		if (p->size < 0)
			delete (struct __ns1__getMetricData*)p->ptr;
		else
			delete[] (struct __ns1__getMetricData*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getNextData:
		if (p->size < 0)
			delete (struct __ns1__getNextData*)p->ptr;
		else
			delete[] (struct __ns1__getNextData*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getPolicyData:
		if (p->size < 0)
			delete (struct __ns1__getPolicyData*)p->ptr;
		else
			delete[] (struct __ns1__getPolicyData*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getPolicyHistory:
		if (p->size < 0)
			delete (struct __ns1__getPolicyHistory*)p->ptr;
		else
			delete[] (struct __ns1__getPolicyHistory*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getPolicyState:
		if (p->size < 0)
			delete (struct __ns1__getPolicyState*)p->ptr;
		else
			delete[] (struct __ns1__getPolicyState*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getPredefinedEventTypes:
		if (p->size < 0)
			delete (struct __ns1__getPredefinedEventTypes*)p->ptr;
		else
			delete[] (struct __ns1__getPredefinedEventTypes*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getQueryAggregationPeriodList:
		if (p->size < 0)
			delete (struct __ns1__getQueryAggregationPeriodList*)p->ptr;
		else
			delete[] (struct __ns1__getQueryAggregationPeriodList*)p->ptr;
		break;
	case SOAP_TYPE___ns1__getQueryData:
		if (p->size < 0)
			delete (struct __ns1__getQueryData*)p->ptr;
		else
			delete[] (struct __ns1__getQueryData*)p->ptr;
		break;
	case SOAP_TYPE___ns1__importHierarchy:
		if (p->size < 0)
			delete (struct __ns1__importHierarchy*)p->ptr;
		else
			delete[] (struct __ns1__importHierarchy*)p->ptr;
		break;
	case SOAP_TYPE___ns1__isPolicyActive:
		if (p->size < 0)
			delete (struct __ns1__isPolicyActive*)p->ptr;
		else
			delete[] (struct __ns1__isPolicyActive*)p->ptr;
		break;
	case SOAP_TYPE___ns1__rediscoverNodeCapabilities:
		if (p->size < 0)
			delete (struct __ns1__rediscoverNodeCapabilities*)p->ptr;
		else
			delete[] (struct __ns1__rediscoverNodeCapabilities*)p->ptr;
		break;
	case SOAP_TYPE___ns1__removeCustomEvent:
		if (p->size < 0)
			delete (struct __ns1__removeCustomEvent*)p->ptr;
		else
			delete[] (struct __ns1__removeCustomEvent*)p->ptr;
		break;
	case SOAP_TYPE___ns1__removeEntity:
		if (p->size < 0)
			delete (struct __ns1__removeEntity*)p->ptr;
		else
			delete[] (struct __ns1__removeEntity*)p->ptr;
		break;
	case SOAP_TYPE___ns1__removePolicy:
		if (p->size < 0)
			delete (struct __ns1__removePolicy*)p->ptr;
		else
			delete[] (struct __ns1__removePolicy*)p->ptr;
		break;
	case SOAP_TYPE___ns1__schedulePolicy:
		if (p->size < 0)
			delete (struct __ns1__schedulePolicy*)p->ptr;
		else
			delete[] (struct __ns1__schedulePolicy*)p->ptr;
		break;
	case SOAP_TYPE___ns1__setCollectionState:
		if (p->size < 0)
			delete (struct __ns1__setCollectionState*)p->ptr;
		else
			delete[] (struct __ns1__setCollectionState*)p->ptr;
		break;
	case SOAP_TYPE___ns1__setEntityProperties:
		if (p->size < 0)
			delete (struct __ns1__setEntityProperties*)p->ptr;
		else
			delete[] (struct __ns1__setEntityProperties*)p->ptr;
		break;
	case SOAP_TYPE___ns1__setEventState:
		if (p->size < 0)
			delete (struct __ns1__setEventState*)p->ptr;
		else
			delete[] (struct __ns1__setEventState*)p->ptr;
		break;
	case SOAP_TYPE___ns1__setGlobalProperty:
		if (p->size < 0)
			delete (struct __ns1__setGlobalProperty*)p->ptr;
		else
			delete[] (struct __ns1__setGlobalProperty*)p->ptr;
		break;
	case SOAP_TYPE___ns1__setPolicyState:
		if (p->size < 0)
			delete (struct __ns1__setPolicyState*)p->ptr;
		else
			delete[] (struct __ns1__setPolicyState*)p->ptr;
		break;
	case SOAP_TYPE___ns1__submitSecretKey:
		if (p->size < 0)
			delete (struct __ns1__submitSecretKey*)p->ptr;
		else
			delete[] (struct __ns1__submitSecretKey*)p->ptr;
		break;
	case SOAP_TYPE___ns1__subscribeEventHandler:
		if (p->size < 0)
			delete (struct __ns1__subscribeEventHandler*)p->ptr;
		else
			delete[] (struct __ns1__subscribeEventHandler*)p->ptr;
		break;
	case SOAP_TYPE___ns1__subscribePredefinedEvent:
		if (p->size < 0)
			delete (struct __ns1__subscribePredefinedEvent*)p->ptr;
		else
			delete[] (struct __ns1__subscribePredefinedEvent*)p->ptr;
		break;
	case SOAP_TYPE___ns1__unsubscribeEventHandler:
		if (p->size < 0)
			delete (struct __ns1__unsubscribeEventHandler*)p->ptr;
		else
			delete[] (struct __ns1__unsubscribeEventHandler*)p->ptr;
		break;
	case SOAP_TYPE___ns1__unsubscribePredefinedEvent:
		if (p->size < 0)
			delete (struct __ns1__unsubscribePredefinedEvent*)p->ptr;
		else
			delete[] (struct __ns1__unsubscribePredefinedEvent*)p->ptr;
		break;
	case SOAP_TYPE___ns1__updateCustomEvent:
		if (p->size < 0)
			delete (struct __ns1__updateCustomEvent*)p->ptr;
		else
			delete[] (struct __ns1__updateCustomEvent*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		if (p->size < 0)
			delete (std::vector<std::string >*)p->ptr;
		else
			delete[] (std::vector<std::string >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__property:
		if (p->size < 0)
			delete (std::vector<ns1__property * >*)p->ptr;
		else
			delete[] (std::vector<ns1__property * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__predefinedEventType:
		if (p->size < 0)
			delete (std::vector<enum ns1__predefinedEventType >*)p->ptr;
		else
			delete[] (std::vector<enum ns1__predefinedEventType >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__aggregationPeriod:
		if (p->size < 0)
			delete (std::vector<ns1__aggregationPeriod * >*)p->ptr;
		else
			delete[] (std::vector<ns1__aggregationPeriod * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__day:
		if (p->size < 0)
			delete (std::vector<enum ns1__day >*)p->ptr;
		else
			delete[] (std::vector<enum ns1__day >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		if (p->size < 0)
			delete (std::vector<int >*)p->ptr;
		else
			delete[] (std::vector<int >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ptData:
		if (p->size < 0)
			delete (std::vector<ns1__ptData * >*)p->ptr;
		else
			delete[] (std::vector<ns1__ptData * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfstd__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<std::string >*)p)[len] = *(std::string *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__property:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__property * >*)p)[len] = *(ns1__property **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__predefinedEventType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns1__predefinedEventType >*)p)[len] = *(enum ns1__predefinedEventType *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__aggregationPeriod:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__aggregationPeriod * >*)p)[len] = *(ns1__aggregationPeriod **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfns1__day:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<enum ns1__day >*)p)[len] = *(enum ns1__day *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfint:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<int >*)p)[len] = *(int *)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__ptData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__ptData * >*)p)[len] = *(ns1__ptData **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__byte(struct soap *soap, char *a)
{	soap_default_byte(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__byte);
	if (soap_out_xsd__byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_xsd__byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_xsd__byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_xsd__byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_xsd__byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__historyType(struct soap *soap, enum ns1__historyType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__historyType
	*a = SOAP_DEFAULT_ns1__historyType;
#else
	*a = (enum ns1__historyType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__historyType(struct soap *soap, const enum ns1__historyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__historyType);
	if (soap_out_ns1__historyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__historyType[] =
{	{ (long)ns1__historyType__POWER_USCORECAP_USCOREREQUESTED, "POWER_CAP_REQUESTED" },
	{ (long)ns1__historyType__POWER_USCORECAP_USCOREACTUAL, "POWER_CAP_ACTUAL" },
	{ (long)ns1__historyType__THERMAL_USCORETRIGGER, "THERMAL_TRIGGER" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__historyType2s(struct soap *soap, enum ns1__historyType n)
{	const char *s = soap_code_str(soap_codes_ns1__historyType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__historyType(struct soap *soap, const char *tag, int id, const enum ns1__historyType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__historyType), type) || soap_send(soap, soap_ns1__historyType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__historyType * SOAP_FMAC4 soap_get_ns1__historyType(struct soap *soap, enum ns1__historyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__historyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__historyType(struct soap *soap, const char *s, enum ns1__historyType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__historyType, s);
	if (map)
		*a = (enum ns1__historyType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__historyType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__historyType * SOAP_FMAC4 soap_in_ns1__historyType(struct soap *soap, const char *tag, enum ns1__historyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__historyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__historyType, sizeof(enum ns1__historyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__historyType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__historyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__historyType, 0, sizeof(enum ns1__historyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__actionLogType(struct soap *soap, enum ns1__actionLogType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__actionLogType
	*a = SOAP_DEFAULT_ns1__actionLogType;
#else
	*a = (enum ns1__actionLogType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__actionLogType(struct soap *soap, const enum ns1__actionLogType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__actionLogType);
	if (soap_out_ns1__actionLogType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__actionLogType[] =
{	{ (long)ns1__actionLogType__ALL, "ALL" },
	{ (long)ns1__actionLogType__EVENT_USCORECHANGE, "EVENT_CHANGE" },
	{ (long)ns1__actionLogType__CONFIGURATION_USCORECHANGE, "CONFIGURATION_CHANGE" },
	{ (long)ns1__actionLogType__HIERARCHY_USCORECHANGE, "HIERARCHY_CHANGE" },
	{ (long)ns1__actionLogType__CONTROL_USCOREPOLICY_USCORECHANGE, "CONTROL_POLICY_CHANGE" },
	{ (long)ns1__actionLogType__EXTERNAL_USCOREACTION_USCORESUCCEEDED, "EXTERNAL_ACTION_SUCCEEDED" },
	{ (long)ns1__actionLogType__EXTERNAL_USCOREACTION_USCOREFAILED, "EXTERNAL_ACTION_FAILED" },
	{ (long)ns1__actionLogType__SYSTEM_USCORECHANGE, "SYSTEM_CHANGE" },
	{ (long)ns1__actionLogType__POLICY_USCOREWARNING, "POLICY_WARNING" },
	{ (long)ns1__actionLogType__EVENT, "EVENT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__actionLogType2s(struct soap *soap, enum ns1__actionLogType n)
{	const char *s = soap_code_str(soap_codes_ns1__actionLogType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__actionLogType(struct soap *soap, const char *tag, int id, const enum ns1__actionLogType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__actionLogType), type) || soap_send(soap, soap_ns1__actionLogType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__actionLogType * SOAP_FMAC4 soap_get_ns1__actionLogType(struct soap *soap, enum ns1__actionLogType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__actionLogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__actionLogType(struct soap *soap, const char *s, enum ns1__actionLogType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__actionLogType, s);
	if (map)
		*a = (enum ns1__actionLogType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 9)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__actionLogType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__actionLogType * SOAP_FMAC4 soap_in_ns1__actionLogType(struct soap *soap, const char *tag, enum ns1__actionLogType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__actionLogType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__actionLogType, sizeof(enum ns1__actionLogType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__actionLogType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__actionLogType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__actionLogType, 0, sizeof(enum ns1__actionLogType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__customEventType(struct soap *soap, enum ns1__customEventType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__customEventType
	*a = SOAP_DEFAULT_ns1__customEventType;
#else
	*a = (enum ns1__customEventType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__customEventType(struct soap *soap, const enum ns1__customEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__customEventType);
	if (soap_out_ns1__customEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__customEventType[] =
{	{ (long)ns1__customEventType__MAX_USCOREPWR, "MAX_PWR" },
	{ (long)ns1__customEventType__AVG_USCOREPWR, "AVG_PWR" },
	{ (long)ns1__customEventType__MIN_USCOREPWR, "MIN_PWR" },
	{ (long)ns1__customEventType__TOTAL_USCOREMAX_USCOREPWR, "TOTAL_MAX_PWR" },
	{ (long)ns1__customEventType__TOTAL_USCOREAVG_USCOREPWR, "TOTAL_AVG_PWR" },
	{ (long)ns1__customEventType__TOTAL_USCOREMIN_USCOREPWR, "TOTAL_MIN_PWR" },
	{ (long)ns1__customEventType__MAX_USCOREINLET_USCORETEMP, "MAX_INLET_TEMP" },
	{ (long)ns1__customEventType__AVG_USCOREINLET_USCORETEMP, "AVG_INLET_TEMP" },
	{ (long)ns1__customEventType__MIN_USCOREINLET_USCORETEMP, "MIN_INLET_TEMP" },
	{ (long)ns1__customEventType__AVG_USCOREWATTS_USCOREPER_USCOREDIMENSION, "AVG_WATTS_PER_DIMENSION" },
	{ (long)ns1__customEventType__AVG_USCORECOOLING_USCOREPWR, "AVG_COOLING_PWR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__customEventType2s(struct soap *soap, enum ns1__customEventType n)
{	const char *s = soap_code_str(soap_codes_ns1__customEventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__customEventType(struct soap *soap, const char *tag, int id, const enum ns1__customEventType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__customEventType), type) || soap_send(soap, soap_ns1__customEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__customEventType * SOAP_FMAC4 soap_get_ns1__customEventType(struct soap *soap, enum ns1__customEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__customEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__customEventType(struct soap *soap, const char *s, enum ns1__customEventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__customEventType, s);
	if (map)
		*a = (enum ns1__customEventType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__customEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__customEventType * SOAP_FMAC4 soap_in_ns1__customEventType(struct soap *soap, const char *tag, enum ns1__customEventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__customEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__customEventType, sizeof(enum ns1__customEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__customEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__customEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__customEventType, 0, sizeof(enum ns1__customEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__conditionOperator(struct soap *soap, enum ns1__conditionOperator *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__conditionOperator
	*a = SOAP_DEFAULT_ns1__conditionOperator;
#else
	*a = (enum ns1__conditionOperator)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__conditionOperator(struct soap *soap, const enum ns1__conditionOperator *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__conditionOperator);
	if (soap_out_ns1__conditionOperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__conditionOperator[] =
{	{ (long)ns1__conditionOperator__GREATER_USCORETHAN, "GREATER_THAN" },
	{ (long)ns1__conditionOperator__LESS_USCORETHAN, "LESS_THAN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__conditionOperator2s(struct soap *soap, enum ns1__conditionOperator n)
{	const char *s = soap_code_str(soap_codes_ns1__conditionOperator, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__conditionOperator(struct soap *soap, const char *tag, int id, const enum ns1__conditionOperator *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__conditionOperator), type) || soap_send(soap, soap_ns1__conditionOperator2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__conditionOperator * SOAP_FMAC4 soap_get_ns1__conditionOperator(struct soap *soap, enum ns1__conditionOperator *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__conditionOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__conditionOperator(struct soap *soap, const char *s, enum ns1__conditionOperator *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__conditionOperator, s);
	if (map)
		*a = (enum ns1__conditionOperator)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__conditionOperator)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__conditionOperator * SOAP_FMAC4 soap_in_ns1__conditionOperator(struct soap *soap, const char *tag, enum ns1__conditionOperator *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__conditionOperator *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__conditionOperator, sizeof(enum ns1__conditionOperator), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__conditionOperator(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__conditionOperator *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__conditionOperator, 0, sizeof(enum ns1__conditionOperator), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__entityType(struct soap *soap, enum ns1__entityType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__entityType
	*a = SOAP_DEFAULT_ns1__entityType;
#else
	*a = (enum ns1__entityType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__entityType(struct soap *soap, const enum ns1__entityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__entityType);
	if (soap_out_ns1__entityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__entityType[] =
{	{ (long)ns1__entityType__NODE, "NODE" },
	{ (long)ns1__entityType__RACK, "RACK" },
	{ (long)ns1__entityType__ROW, "ROW" },
	{ (long)ns1__entityType__ROOM, "ROOM" },
	{ (long)ns1__entityType__DATACENTER, "DATACENTER" },
	{ (long)ns1__entityType__LOGICAL_USCOREGROUP, "LOGICAL_GROUP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__entityType2s(struct soap *soap, enum ns1__entityType n)
{	const char *s = soap_code_str(soap_codes_ns1__entityType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entityType(struct soap *soap, const char *tag, int id, const enum ns1__entityType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__entityType), type) || soap_send(soap, soap_ns1__entityType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__entityType * SOAP_FMAC4 soap_get_ns1__entityType(struct soap *soap, enum ns1__entityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__entityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__entityType(struct soap *soap, const char *s, enum ns1__entityType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__entityType, s);
	if (map)
		*a = (enum ns1__entityType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__entityType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__entityType * SOAP_FMAC4 soap_in_ns1__entityType(struct soap *soap, const char *tag, enum ns1__entityType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__entityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__entityType, sizeof(enum ns1__entityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__entityType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__entityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__entityType, 0, sizeof(enum ns1__entityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__metricType(struct soap *soap, enum ns1__metricType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__metricType
	*a = SOAP_DEFAULT_ns1__metricType;
#else
	*a = (enum ns1__metricType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__metricType(struct soap *soap, const enum ns1__metricType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__metricType);
	if (soap_out_ns1__metricType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__metricType[] =
{	{ (long)ns1__metricType__MNGED_USCORENODES_USCOREENERGY, "MNGED_NODES_ENERGY" },
	{ (long)ns1__metricType__MNGED_USCORENODES_USCOREENERGY_USCOREBILL, "MNGED_NODES_ENERGY_BILL" },
	{ (long)ns1__metricType__IT_USCOREEQPMNT_USCOREENERGY, "IT_EQPMNT_ENERGY" },
	{ (long)ns1__metricType__IT_USCOREEQPMNT_USCOREENERGY_USCOREBILL, "IT_EQPMNT_ENERGY_BILL" },
	{ (long)ns1__metricType__CALC_USCORECOOLING_USCOREENERGY, "CALC_COOLING_ENERGY" },
	{ (long)ns1__metricType__CALC_USCORECOOLING_USCOREENERGY_USCOREBILL, "CALC_COOLING_ENERGY_BILL" },
	{ (long)ns1__metricType__MNGED_USCORENODES_USCOREPWR, "MNGED_NODES_PWR" },
	{ (long)ns1__metricType__IT_USCOREEQPMNT_USCOREPWR, "IT_EQPMNT_PWR" },
	{ (long)ns1__metricType__CALC_USCORECOOLING_USCOREPWR, "CALC_COOLING_PWR" },
	{ (long)ns1__metricType__AVG_USCOREPWR_USCOREPER_USCOREDIMENSION, "AVG_PWR_PER_DIMENSION" },
	{ (long)ns1__metricType__DERATED_USCOREPWR, "DERATED_PWR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__metricType2s(struct soap *soap, enum ns1__metricType n)
{	const char *s = soap_code_str(soap_codes_ns1__metricType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__metricType(struct soap *soap, const char *tag, int id, const enum ns1__metricType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__metricType), type) || soap_send(soap, soap_ns1__metricType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__metricType * SOAP_FMAC4 soap_get_ns1__metricType(struct soap *soap, enum ns1__metricType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__metricType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__metricType(struct soap *soap, const char *s, enum ns1__metricType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__metricType, s);
	if (map)
		*a = (enum ns1__metricType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__metricType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__metricType * SOAP_FMAC4 soap_in_ns1__metricType(struct soap *soap, const char *tag, enum ns1__metricType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__metricType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__metricType, sizeof(enum ns1__metricType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__metricType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__metricType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__metricType, 0, sizeof(enum ns1__metricType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__globalProperty(struct soap *soap, enum ns1__globalProperty *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__globalProperty
	*a = SOAP_DEFAULT_ns1__globalProperty;
#else
	*a = (enum ns1__globalProperty)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__globalProperty(struct soap *soap, const enum ns1__globalProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__globalProperty);
	if (soap_out_ns1__globalProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__globalProperty[] =
{	{ (long)ns1__globalProperty__NODE_USCOREPOWER_USCORESAMPLING_USCOREFREQUENCY, "NODE_POWER_SAMPLING_FREQUENCY" },
	{ (long)ns1__globalProperty__NODE_USCORETHERMAL_USCORESAMPLING_USCOREFREQUENCY, "NODE_THERMAL_SAMPLING_FREQUENCY" },
	{ (long)ns1__globalProperty__ACTION_USCORELOG_USCOREBACK_USCORETRACKING_USCOREPERIOD, "ACTION_LOG_BACK_TRACKING_PERIOD" },
	{ (long)ns1__globalProperty__APP_USCORELOG_USCOREMAX_USCORESIZE, "APP_LOG_MAX_SIZE" },
	{ (long)ns1__globalProperty__APP_USCORELOG_USCORELEVEL, "APP_LOG_LEVEL" },
	{ (long)ns1__globalProperty__COOLING_USCOREMULT, "COOLING_MULT" },
	{ (long)ns1__globalProperty__COST_USCOREPER_USCOREKW_USCOREHR, "COST_PER_KW_HR" },
	{ (long)ns1__globalProperty__TIME_USCOREUNTIL_USCOREDB_USCORECOMPRESSION, "TIME_UNTIL_DB_COMPRESSION" },
	{ (long)ns1__globalProperty__MAX_USCORENUM_USCORERECORDS_USCOREINVOLVED, "MAX_NUM_RECORDS_INVOLVED" },
	{ (long)ns1__globalProperty__TIME_USCOREUNTIL_USCOREDB_USCOREDELETION, "TIME_UNTIL_DB_DELETION" },
	{ (long)ns1__globalProperty__DB_USCOREMAINTENANCE_USCOREHOUR, "DB_MAINTENANCE_HOUR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__globalProperty2s(struct soap *soap, enum ns1__globalProperty n)
{	const char *s = soap_code_str(soap_codes_ns1__globalProperty, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__globalProperty(struct soap *soap, const char *tag, int id, const enum ns1__globalProperty *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__globalProperty), type) || soap_send(soap, soap_ns1__globalProperty2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__globalProperty * SOAP_FMAC4 soap_get_ns1__globalProperty(struct soap *soap, enum ns1__globalProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__globalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__globalProperty(struct soap *soap, const char *s, enum ns1__globalProperty *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__globalProperty, s);
	if (map)
		*a = (enum ns1__globalProperty)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 10)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__globalProperty)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__globalProperty * SOAP_FMAC4 soap_in_ns1__globalProperty(struct soap *soap, const char *tag, enum ns1__globalProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__globalProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__globalProperty, sizeof(enum ns1__globalProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__globalProperty(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__globalProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__globalProperty, 0, sizeof(enum ns1__globalProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__predefinedEventType(struct soap *soap, enum ns1__predefinedEventType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__predefinedEventType
	*a = SOAP_DEFAULT_ns1__predefinedEventType;
#else
	*a = (enum ns1__predefinedEventType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__predefinedEventType(struct soap *soap, const enum ns1__predefinedEventType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__predefinedEventType);
	if (soap_out_ns1__predefinedEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__predefinedEventType[] =
{	{ (long)ns1__predefinedEventType__IPMI_USCOREPWR_USCOREUNIT, "IPMI_PWR_UNIT" },
	{ (long)ns1__predefinedEventType__IPMI_USCOREPWR_USCORESUPPLY, "IPMI_PWR_SUPPLY" },
	{ (long)ns1__predefinedEventType__IPMI_USCOREPROCESSOR_USCORETHERMAL_USCORETRIP, "IPMI_PROCESSOR_THERMAL_TRIP" },
	{ (long)ns1__predefinedEventType__IPMI_USCOREFAN, "IPMI_FAN" },
	{ (long)ns1__predefinedEventType__BMC_USCORESEL_USCOREREACHING_USCOREFULL_USCORECAPACITY, "BMC_SEL_REACHING_FULL_CAPACITY" },
	{ (long)ns1__predefinedEventType__BMC_USCORESEL_USCOREAT_USCOREFULL_USCORECAPACITY, "BMC_SEL_AT_FULL_CAPACITY" },
	{ (long)ns1__predefinedEventType__ENTITY_USCOREPROPERTY_USCORECHANGED, "ENTITY_PROPERTY_CHANGED" },
	{ (long)ns1__predefinedEventType__COMMUNICATION_USCOREWITH_USCORENODE_USCOREFAILED, "COMMUNICATION_WITH_NODE_FAILED" },
	{ (long)ns1__predefinedEventType__COMMUNICATION_USCOREWITH_USCORENODE_USCORERESTORED, "COMMUNICATION_WITH_NODE_RESTORED" },
	{ (long)ns1__predefinedEventType__INSUFFICIENT_USCORENODE_USCOREPERMISSION, "INSUFFICIENT_NODE_PERMISSION" },
	{ (long)ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCORECANNOT_USCOREBE_USCOREMAINTAINED, "CONTROL_POLICY_CANNOT_BE_MAINTAINED" },
	{ (long)ns1__predefinedEventType__CANT_USCORESET_USCORENODE_USCOREEVENT, "CANT_SET_NODE_EVENT" },
	{ (long)ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCOREAPPLIED, "CONTROL_POLICY_APPLIED" },
	{ (long)ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCOREENDED, "CONTROL_POLICY_ENDED" },
	{ (long)ns1__predefinedEventType__INTERNAL_USCOREERROR, "INTERNAL_ERROR" },
	{ (long)ns1__predefinedEventType__CONFIGURATION_USCORECHANGED, "CONFIGURATION_CHANGED" },
	{ (long)ns1__predefinedEventType__HIERARCHY_USCORECHANGED, "HIERARCHY_CHANGED" },
	{ (long)ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCORECHANGED, "CONTROL_POLICY_CHANGED" },
	{ (long)ns1__predefinedEventType__CUSTOM_USCOREEVENT_USCORECHANGED, "CUSTOM_EVENT_CHANGED" },
	{ (long)ns1__predefinedEventType__CUSTOM_USCOREEVENT_USCOREEVALUATION_USCOREFAILURE, "CUSTOM_EVENT_EVALUATION_FAILURE" },
	{ (long)ns1__predefinedEventType__COLLECTION_USCORESTATE_USCORECHANGED, "COLLECTION_STATE_CHANGED" },
	{ (long)ns1__predefinedEventType__IMPORTHIERARCHY_USCORECOMPLETED, "IMPORTHIERARCHY_COMPLETED" },
	{ (long)ns1__predefinedEventType__DB_USCOREMAINTENANCE_USCORESTARTING, "DB_MAINTENANCE_STARTING" },
	{ (long)ns1__predefinedEventType__DB_USCOREMAINTENANCE_USCOREENDED, "DB_MAINTENANCE_ENDED" },
	{ (long)ns1__predefinedEventType__DB_USCORECONNECTION_USCOREFAILED, "DB_CONNECTION_FAILED" },
	{ (long)ns1__predefinedEventType__DB_USCORECONNECTION_USCORERESTORED, "DB_CONNECTION_RESTORED" },
	{ (long)ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCOREPRIORITY_USCORECONFLICT, "CONTROL_POLICY_PRIORITY_CONFLICT" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__predefinedEventType2s(struct soap *soap, enum ns1__predefinedEventType n)
{	const char *s = soap_code_str(soap_codes_ns1__predefinedEventType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__predefinedEventType(struct soap *soap, const char *tag, int id, const enum ns1__predefinedEventType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__predefinedEventType), type) || soap_send(soap, soap_ns1__predefinedEventType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__predefinedEventType * SOAP_FMAC4 soap_get_ns1__predefinedEventType(struct soap *soap, enum ns1__predefinedEventType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__predefinedEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__predefinedEventType(struct soap *soap, const char *s, enum ns1__predefinedEventType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__predefinedEventType, s);
	if (map)
		*a = (enum ns1__predefinedEventType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 26)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__predefinedEventType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__predefinedEventType * SOAP_FMAC4 soap_in_ns1__predefinedEventType(struct soap *soap, const char *tag, enum ns1__predefinedEventType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__predefinedEventType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__predefinedEventType, sizeof(enum ns1__predefinedEventType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__predefinedEventType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__predefinedEventType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__predefinedEventType, 0, sizeof(enum ns1__predefinedEventType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__entityProperty(struct soap *soap, enum ns1__entityProperty *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__entityProperty
	*a = SOAP_DEFAULT_ns1__entityProperty;
#else
	*a = (enum ns1__entityProperty)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__entityProperty(struct soap *soap, const enum ns1__entityProperty *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__entityProperty);
	if (soap_out_ns1__entityProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__entityProperty[] =
{	{ (long)ns1__entityProperty__BMC_USCOREADDRESS, "BMC_ADDRESS" },
	{ (long)ns1__entityProperty__NAME, "NAME" },
	{ (long)ns1__entityProperty__DESCRIPTION, "DESCRIPTION" },
	{ (long)ns1__entityProperty__BMC_USCOREUSER, "BMC_USER" },
	{ (long)ns1__entityProperty__BMC_USCOREPASSWORD, "BMC_PASSWORD" },
	{ (long)ns1__entityProperty__BMC_USCOREKEY, "BMC_KEY" },
	{ (long)ns1__entityProperty__CAPABILITIES, "CAPABILITIES" },
	{ (long)ns1__entityProperty__LOCATION, "LOCATION" },
	{ (long)ns1__entityProperty__DIMENSION, "DIMENSION" },
	{ (long)ns1__entityProperty__ENTITY_USCORETYPE, "ENTITY_TYPE" },
	{ (long)ns1__entityProperty__NAMEPLATE_USCOREPWR, "NAMEPLATE_PWR" },
	{ (long)ns1__entityProperty__DERATED_USCOREPWR, "DERATED_PWR" },
	{ (long)ns1__entityProperty__NAMEPLATE_USCOREPWR_USCOREUNMNGD_USCOREEQPMNT, "NAMEPLATE_PWR_UNMNGD_EQPMNT" },
	{ (long)ns1__entityProperty__PDU_USCOREPWR_USCORELIMIT, "PDU_PWR_LIMIT" },
	{ (long)ns1__entityProperty__NODE_USCORESTATUS, "NODE_STATUS" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__entityProperty2s(struct soap *soap, enum ns1__entityProperty n)
{	const char *s = soap_code_str(soap_codes_ns1__entityProperty, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__entityProperty(struct soap *soap, const char *tag, int id, const enum ns1__entityProperty *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__entityProperty), type) || soap_send(soap, soap_ns1__entityProperty2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__entityProperty * SOAP_FMAC4 soap_get_ns1__entityProperty(struct soap *soap, enum ns1__entityProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__entityProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__entityProperty(struct soap *soap, const char *s, enum ns1__entityProperty *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__entityProperty, s);
	if (map)
		*a = (enum ns1__entityProperty)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 14)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__entityProperty)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__entityProperty * SOAP_FMAC4 soap_in_ns1__entityProperty(struct soap *soap, const char *tag, enum ns1__entityProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__entityProperty *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__entityProperty, sizeof(enum ns1__entityProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__entityProperty(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__entityProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__entityProperty, 0, sizeof(enum ns1__entityProperty), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__day(struct soap *soap, enum ns1__day *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__day
	*a = SOAP_DEFAULT_ns1__day;
#else
	*a = (enum ns1__day)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__day(struct soap *soap, const enum ns1__day *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__day);
	if (soap_out_ns1__day(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__day[] =
{	{ (long)ns1__day__SUNDAY, "SUNDAY" },
	{ (long)ns1__day__MONDAY, "MONDAY" },
	{ (long)ns1__day__TUESDAY, "TUESDAY" },
	{ (long)ns1__day__WEDNESDAY, "WEDNESDAY" },
	{ (long)ns1__day__THURSDAY, "THURSDAY" },
	{ (long)ns1__day__FRIDAY, "FRIDAY" },
	{ (long)ns1__day__SATURDAY, "SATURDAY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__day2s(struct soap *soap, enum ns1__day n)
{	const char *s = soap_code_str(soap_codes_ns1__day, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__day(struct soap *soap, const char *tag, int id, const enum ns1__day *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__day), type) || soap_send(soap, soap_ns1__day2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__day * SOAP_FMAC4 soap_get_ns1__day(struct soap *soap, enum ns1__day *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__day(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__day(struct soap *soap, const char *s, enum ns1__day *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__day, s);
	if (map)
		*a = (enum ns1__day)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 6)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__day)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__day * SOAP_FMAC4 soap_in_ns1__day(struct soap *soap, const char *tag, enum ns1__day *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__day *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__day, sizeof(enum ns1__day), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__day(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__day *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__day, 0, sizeof(enum ns1__day), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__policyType(struct soap *soap, enum ns1__policyType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__policyType
	*a = SOAP_DEFAULT_ns1__policyType;
#else
	*a = (enum ns1__policyType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__policyType(struct soap *soap, const enum ns1__policyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__policyType);
	if (soap_out_ns1__policyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__policyType[] =
{	{ (long)ns1__policyType__CUSTOM_USCOREPWR_USCORELIMIT, "CUSTOM_PWR_LIMIT" },
	{ (long)ns1__policyType__MIN_USCOREPWR, "MIN_PWR" },
	{ (long)ns1__policyType__MIN_USCOREPWR_USCOREON_USCOREINLET_USCORETEMP_USCORETRIGGER, "MIN_PWR_ON_INLET_TEMP_TRIGGER" },
	{ (long)ns1__policyType__STATIC_USCOREPOWER_USCOREPOLICY, "STATIC_POWER_POLICY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__policyType2s(struct soap *soap, enum ns1__policyType n)
{	const char *s = soap_code_str(soap_codes_ns1__policyType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__policyType(struct soap *soap, const char *tag, int id, const enum ns1__policyType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__policyType), type) || soap_send(soap, soap_ns1__policyType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__policyType * SOAP_FMAC4 soap_get_ns1__policyType(struct soap *soap, enum ns1__policyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__policyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__policyType(struct soap *soap, const char *s, enum ns1__policyType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__policyType, s);
	if (map)
		*a = (enum ns1__policyType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__policyType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__policyType * SOAP_FMAC4 soap_in_ns1__policyType(struct soap *soap, const char *tag, enum ns1__policyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__policyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__policyType, sizeof(enum ns1__policyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__policyType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__policyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__policyType, 0, sizeof(enum ns1__policyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__aggregationLevel(struct soap *soap, enum ns1__aggregationLevel *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__aggregationLevel
	*a = SOAP_DEFAULT_ns1__aggregationLevel;
#else
	*a = (enum ns1__aggregationLevel)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__aggregationLevel(struct soap *soap, const enum ns1__aggregationLevel *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__aggregationLevel);
	if (soap_out_ns1__aggregationLevel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__aggregationLevel[] =
{	{ (long)ns1__aggregationLevel__SELF, "SELF" },
	{ (long)ns1__aggregationLevel__NODE, "NODE" },
	{ (long)ns1__aggregationLevel__RACK, "RACK" },
	{ (long)ns1__aggregationLevel__ROW, "ROW" },
	{ (long)ns1__aggregationLevel__ROOM, "ROOM" },
	{ (long)ns1__aggregationLevel__IMMEDIATE_USCORECHILDREN, "IMMEDIATE_CHILDREN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__aggregationLevel2s(struct soap *soap, enum ns1__aggregationLevel n)
{	const char *s = soap_code_str(soap_codes_ns1__aggregationLevel, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__aggregationLevel(struct soap *soap, const char *tag, int id, const enum ns1__aggregationLevel *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__aggregationLevel), type) || soap_send(soap, soap_ns1__aggregationLevel2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__aggregationLevel * SOAP_FMAC4 soap_get_ns1__aggregationLevel(struct soap *soap, enum ns1__aggregationLevel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__aggregationLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__aggregationLevel(struct soap *soap, const char *s, enum ns1__aggregationLevel *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__aggregationLevel, s);
	if (map)
		*a = (enum ns1__aggregationLevel)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__aggregationLevel)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__aggregationLevel * SOAP_FMAC4 soap_in_ns1__aggregationLevel(struct soap *soap, const char *tag, enum ns1__aggregationLevel *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__aggregationLevel *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__aggregationLevel, sizeof(enum ns1__aggregationLevel), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__aggregationLevel(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__aggregationLevel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__aggregationLevel, 0, sizeof(enum ns1__aggregationLevel), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__queryType(struct soap *soap, enum ns1__queryType *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__queryType
	*a = SOAP_DEFAULT_ns1__queryType;
#else
	*a = (enum ns1__queryType)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__queryType(struct soap *soap, const enum ns1__queryType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__queryType);
	if (soap_out_ns1__queryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__queryType[] =
{	{ (long)ns1__queryType__MAX_USCOREPWR, "MAX_PWR" },
	{ (long)ns1__queryType__AVG_USCOREPWR, "AVG_PWR" },
	{ (long)ns1__queryType__MIN_USCOREPWR, "MIN_PWR" },
	{ (long)ns1__queryType__TOTAL_USCOREMAX_USCOREPWR, "TOTAL_MAX_PWR" },
	{ (long)ns1__queryType__TOTAL_USCOREAVG_USCOREPWR, "TOTAL_AVG_PWR" },
	{ (long)ns1__queryType__TOTAL_USCOREMIN_USCOREPWR, "TOTAL_MIN_PWR" },
	{ (long)ns1__queryType__MAX_USCOREINLET_USCORETEMP, "MAX_INLET_TEMP" },
	{ (long)ns1__queryType__AVG_USCOREINLET_USCORETEMP, "AVG_INLET_TEMP" },
	{ (long)ns1__queryType__MIN_USCOREINLET_USCORETEMP, "MIN_INLET_TEMP" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__queryType2s(struct soap *soap, enum ns1__queryType n)
{	const char *s = soap_code_str(soap_codes_ns1__queryType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__queryType(struct soap *soap, const char *tag, int id, const enum ns1__queryType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__queryType), type) || soap_send(soap, soap_ns1__queryType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__queryType * SOAP_FMAC4 soap_get_ns1__queryType(struct soap *soap, enum ns1__queryType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__queryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__queryType(struct soap *soap, const char *s, enum ns1__queryType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__queryType, s);
	if (map)
		*a = (enum ns1__queryType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__queryType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__queryType * SOAP_FMAC4 soap_in_ns1__queryType(struct soap *soap, const char *tag, enum ns1__queryType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__queryType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__queryType, sizeof(enum ns1__queryType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__queryType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__queryType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__queryType, 0, sizeof(enum ns1__queryType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns1__unsubscribeEventHandlerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__unsubscribeEventHandlerResponse::return_);
	/* transient soap skipped */
}

void ns1__unsubscribeEventHandlerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__unsubscribeEventHandlerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__unsubscribeEventHandlerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__unsubscribeEventHandlerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unsubscribeEventHandlerResponse(struct soap *soap, const char *tag, int id, const ns1__unsubscribeEventHandlerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__unsubscribeEventHandlerResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__unsubscribeEventHandlerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__unsubscribeEventHandlerResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__unsubscribeEventHandlerResponse * SOAP_FMAC4 soap_get_ns1__unsubscribeEventHandlerResponse(struct soap *soap, ns1__unsubscribeEventHandlerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unsubscribeEventHandlerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__unsubscribeEventHandlerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__unsubscribeEventHandlerResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__unsubscribeEventHandlerResponse * SOAP_FMAC4 soap_in_ns1__unsubscribeEventHandlerResponse(struct soap *soap, const char *tag, ns1__unsubscribeEventHandlerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__unsubscribeEventHandlerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse, sizeof(ns1__unsubscribeEventHandlerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__unsubscribeEventHandlerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__unsubscribeEventHandlerResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__unsubscribeEventHandlerResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__unsubscribeEventHandlerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse, 0, sizeof(ns1__unsubscribeEventHandlerResponse), 0, soap_copy_ns1__unsubscribeEventHandlerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__unsubscribeEventHandlerResponse * SOAP_FMAC6 soap_new_ns1__unsubscribeEventHandlerResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__unsubscribeEventHandlerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__unsubscribeEventHandlerResponse(struct soap *soap, ns1__unsubscribeEventHandlerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__unsubscribeEventHandlerResponse * SOAP_FMAC4 soap_instantiate_ns1__unsubscribeEventHandlerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unsubscribeEventHandlerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__unsubscribeEventHandlerResponse;
		if (size)
			*size = sizeof(ns1__unsubscribeEventHandlerResponse);
		((ns1__unsubscribeEventHandlerResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__unsubscribeEventHandlerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__unsubscribeEventHandlerResponse);
		for (int i = 0; i < n; i++)
			((ns1__unsubscribeEventHandlerResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__unsubscribeEventHandlerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unsubscribeEventHandlerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__unsubscribeEventHandlerResponse %p -> %p\n", q, p));
	*(ns1__unsubscribeEventHandlerResponse*)p = *(ns1__unsubscribeEventHandlerResponse*)q;
}

void ns1__unsubscribeEventHandler::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__unsubscribeEventHandler::handlerId);
	/* transient soap skipped */
}

void ns1__unsubscribeEventHandler::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__unsubscribeEventHandler::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__unsubscribeEventHandler);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__unsubscribeEventHandler::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__unsubscribeEventHandler(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unsubscribeEventHandler(struct soap *soap, const char *tag, int id, const ns1__unsubscribeEventHandler *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unsubscribeEventHandler), type))
		return soap->error;
	if (soap_out_int(soap, "handlerId", -1, &(a->ns1__unsubscribeEventHandler::handlerId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__unsubscribeEventHandler::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__unsubscribeEventHandler(soap, this, tag, type);
}

SOAP_FMAC3 ns1__unsubscribeEventHandler * SOAP_FMAC4 soap_get_ns1__unsubscribeEventHandler(struct soap *soap, ns1__unsubscribeEventHandler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unsubscribeEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__unsubscribeEventHandler::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__unsubscribeEventHandler(soap, tag, this, type);
}

SOAP_FMAC3 ns1__unsubscribeEventHandler * SOAP_FMAC4 soap_in_ns1__unsubscribeEventHandler(struct soap *soap, const char *tag, ns1__unsubscribeEventHandler *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__unsubscribeEventHandler *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unsubscribeEventHandler, sizeof(ns1__unsubscribeEventHandler), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__unsubscribeEventHandler)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__unsubscribeEventHandler *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_handlerId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_handlerId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "handlerId", &(a->ns1__unsubscribeEventHandler::handlerId), "xsd:int"))
				{	soap_flag_handlerId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__unsubscribeEventHandler *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unsubscribeEventHandler, 0, sizeof(ns1__unsubscribeEventHandler), 0, soap_copy_ns1__unsubscribeEventHandler);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_handlerId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__unsubscribeEventHandler * SOAP_FMAC6 soap_new_ns1__unsubscribeEventHandler(struct soap *soap, int n)
{	return soap_instantiate_ns1__unsubscribeEventHandler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__unsubscribeEventHandler(struct soap *soap, ns1__unsubscribeEventHandler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__unsubscribeEventHandler * SOAP_FMAC4 soap_instantiate_ns1__unsubscribeEventHandler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unsubscribeEventHandler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unsubscribeEventHandler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__unsubscribeEventHandler;
		if (size)
			*size = sizeof(ns1__unsubscribeEventHandler);
		((ns1__unsubscribeEventHandler*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__unsubscribeEventHandler[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__unsubscribeEventHandler);
		for (int i = 0; i < n; i++)
			((ns1__unsubscribeEventHandler*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__unsubscribeEventHandler*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unsubscribeEventHandler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__unsubscribeEventHandler %p -> %p\n", q, p));
	*(ns1__unsubscribeEventHandler*)p = *(ns1__unsubscribeEventHandler*)q;
}

void ns1__getEntityPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__property(soap, &this->ns1__getEntityPropertiesResponse::return_);
	/* transient soap skipped */
}

void ns1__getEntityPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__property(soap, &this->ns1__getEntityPropertiesResponse::return_);
	/* transient soap skipped */
}

int ns1__getEntityPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getEntityPropertiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getEntityPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getEntityPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityPropertiesResponse(struct soap *soap, const char *tag, int id, const ns1__getEntityPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEntityPropertiesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__property(soap, "return", -1, &(a->ns1__getEntityPropertiesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getEntityPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getEntityPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEntityPropertiesResponse * SOAP_FMAC4 soap_get_ns1__getEntityPropertiesResponse(struct soap *soap, ns1__getEntityPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEntityPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getEntityPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getEntityPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEntityPropertiesResponse * SOAP_FMAC4 soap_in_ns1__getEntityPropertiesResponse(struct soap *soap, const char *tag, ns1__getEntityPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getEntityPropertiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEntityPropertiesResponse, sizeof(ns1__getEntityPropertiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getEntityPropertiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getEntityPropertiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__property(soap, "return", &(a->ns1__getEntityPropertiesResponse::return_), "ns1:property"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getEntityPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEntityPropertiesResponse, 0, sizeof(ns1__getEntityPropertiesResponse), 0, soap_copy_ns1__getEntityPropertiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getEntityPropertiesResponse * SOAP_FMAC6 soap_new_ns1__getEntityPropertiesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getEntityPropertiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getEntityPropertiesResponse(struct soap *soap, ns1__getEntityPropertiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getEntityPropertiesResponse * SOAP_FMAC4 soap_instantiate_ns1__getEntityPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityPropertiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEntityPropertiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getEntityPropertiesResponse;
		if (size)
			*size = sizeof(ns1__getEntityPropertiesResponse);
		((ns1__getEntityPropertiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getEntityPropertiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getEntityPropertiesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getEntityPropertiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getEntityPropertiesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityPropertiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEntityPropertiesResponse %p -> %p\n", q, p));
	*(ns1__getEntityPropertiesResponse*)p = *(ns1__getEntityPropertiesResponse*)q;
}

void ns1__getEntityProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getEntityProperties::entityId);
	/* transient soap skipped */
}

void ns1__getEntityProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getEntityProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getEntityProperties);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getEntityProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getEntityProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEntityProperties(struct soap *soap, const char *tag, int id, const ns1__getEntityProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEntityProperties), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__getEntityProperties::entityId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getEntityProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getEntityProperties(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEntityProperties * SOAP_FMAC4 soap_get_ns1__getEntityProperties(struct soap *soap, ns1__getEntityProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEntityProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getEntityProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getEntityProperties(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEntityProperties * SOAP_FMAC4 soap_in_ns1__getEntityProperties(struct soap *soap, const char *tag, ns1__getEntityProperties *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getEntityProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEntityProperties, sizeof(ns1__getEntityProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getEntityProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getEntityProperties *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__getEntityProperties::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getEntityProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEntityProperties, 0, sizeof(ns1__getEntityProperties), 0, soap_copy_ns1__getEntityProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getEntityProperties * SOAP_FMAC6 soap_new_ns1__getEntityProperties(struct soap *soap, int n)
{	return soap_instantiate_ns1__getEntityProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getEntityProperties(struct soap *soap, ns1__getEntityProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getEntityProperties * SOAP_FMAC4 soap_instantiate_ns1__getEntityProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEntityProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEntityProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getEntityProperties;
		if (size)
			*size = sizeof(ns1__getEntityProperties);
		((ns1__getEntityProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getEntityProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getEntityProperties);
		for (int i = 0; i < n; i++)
			((ns1__getEntityProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getEntityProperties*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEntityProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEntityProperties %p -> %p\n", q, p));
	*(ns1__getEntityProperties*)p = *(ns1__getEntityProperties*)q;
}

void ns1__getEventStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__getEventStateResponse::return_);
	/* transient soap skipped */
}

void ns1__getEventStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getEventStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getEventStateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getEventStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getEventStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEventStateResponse(struct soap *soap, const char *tag, int id, const ns1__getEventStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEventStateResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__getEventStateResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getEventStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getEventStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEventStateResponse * SOAP_FMAC4 soap_get_ns1__getEventStateResponse(struct soap *soap, ns1__getEventStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEventStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getEventStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getEventStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEventStateResponse * SOAP_FMAC4 soap_in_ns1__getEventStateResponse(struct soap *soap, const char *tag, ns1__getEventStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getEventStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEventStateResponse, sizeof(ns1__getEventStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getEventStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getEventStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__getEventStateResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getEventStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEventStateResponse, 0, sizeof(ns1__getEventStateResponse), 0, soap_copy_ns1__getEventStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getEventStateResponse * SOAP_FMAC6 soap_new_ns1__getEventStateResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getEventStateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getEventStateResponse(struct soap *soap, ns1__getEventStateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getEventStateResponse * SOAP_FMAC4 soap_instantiate_ns1__getEventStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEventStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEventStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getEventStateResponse;
		if (size)
			*size = sizeof(ns1__getEventStateResponse);
		((ns1__getEventStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getEventStateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getEventStateResponse);
		for (int i = 0; i < n; i++)
			((ns1__getEventStateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getEventStateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEventStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEventStateResponse %p -> %p\n", q, p));
	*(ns1__getEventStateResponse*)p = *(ns1__getEventStateResponse*)q;
}

void ns1__getEventState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getEventState::eventId);
	/* transient soap skipped */
}

void ns1__getEventState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getEventState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getEventState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getEventState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getEventState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEventState(struct soap *soap, const char *tag, int id, const ns1__getEventState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEventState), type))
		return soap->error;
	if (soap_out_int(soap, "eventId", -1, &(a->ns1__getEventState::eventId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getEventState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getEventState(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEventState * SOAP_FMAC4 soap_get_ns1__getEventState(struct soap *soap, ns1__getEventState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getEventState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getEventState(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEventState * SOAP_FMAC4 soap_in_ns1__getEventState(struct soap *soap, const char *tag, ns1__getEventState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getEventState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEventState, sizeof(ns1__getEventState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getEventState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getEventState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_eventId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eventId", &(a->ns1__getEventState::eventId), "xsd:int"))
				{	soap_flag_eventId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getEventState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEventState, 0, sizeof(ns1__getEventState), 0, soap_copy_ns1__getEventState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getEventState * SOAP_FMAC6 soap_new_ns1__getEventState(struct soap *soap, int n)
{	return soap_instantiate_ns1__getEventState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getEventState(struct soap *soap, ns1__getEventState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getEventState * SOAP_FMAC4 soap_instantiate_ns1__getEventState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEventState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEventState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getEventState;
		if (size)
			*size = sizeof(ns1__getEventState);
		((ns1__getEventState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getEventState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getEventState);
		for (int i = 0; i < n; i++)
			((ns1__getEventState*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getEventState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEventState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEventState %p -> %p\n", q, p));
	*(ns1__getEventState*)p = *(ns1__getEventState*)q;
}

void ns1__associateEntityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__associateEntityResponse::return_);
	/* transient soap skipped */
}

void ns1__associateEntityResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__associateEntityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__associateEntityResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__associateEntityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__associateEntityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__associateEntityResponse(struct soap *soap, const char *tag, int id, const ns1__associateEntityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__associateEntityResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__associateEntityResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__associateEntityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__associateEntityResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__associateEntityResponse * SOAP_FMAC4 soap_get_ns1__associateEntityResponse(struct soap *soap, ns1__associateEntityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__associateEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__associateEntityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__associateEntityResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__associateEntityResponse * SOAP_FMAC4 soap_in_ns1__associateEntityResponse(struct soap *soap, const char *tag, ns1__associateEntityResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__associateEntityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__associateEntityResponse, sizeof(ns1__associateEntityResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__associateEntityResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__associateEntityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__associateEntityResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__associateEntityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__associateEntityResponse, 0, sizeof(ns1__associateEntityResponse), 0, soap_copy_ns1__associateEntityResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__associateEntityResponse * SOAP_FMAC6 soap_new_ns1__associateEntityResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__associateEntityResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__associateEntityResponse(struct soap *soap, ns1__associateEntityResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__associateEntityResponse * SOAP_FMAC4 soap_instantiate_ns1__associateEntityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__associateEntityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__associateEntityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__associateEntityResponse;
		if (size)
			*size = sizeof(ns1__associateEntityResponse);
		((ns1__associateEntityResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__associateEntityResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__associateEntityResponse);
		for (int i = 0; i < n; i++)
			((ns1__associateEntityResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__associateEntityResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__associateEntityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__associateEntityResponse %p -> %p\n", q, p));
	*(ns1__associateEntityResponse*)p = *(ns1__associateEntityResponse*)q;
}

void ns1__associateEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__associateEntity::groupId);
	soap_default_int(soap, &this->ns1__associateEntity::entityId);
	/* transient soap skipped */
}

void ns1__associateEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__associateEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__associateEntity);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__associateEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__associateEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__associateEntity(struct soap *soap, const char *tag, int id, const ns1__associateEntity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__associateEntity), type))
		return soap->error;
	if (soap_out_int(soap, "groupId", -1, &(a->ns1__associateEntity::groupId), ""))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__associateEntity::entityId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__associateEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__associateEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns1__associateEntity * SOAP_FMAC4 soap_get_ns1__associateEntity(struct soap *soap, ns1__associateEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__associateEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__associateEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__associateEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns1__associateEntity * SOAP_FMAC4 soap_in_ns1__associateEntity(struct soap *soap, const char *tag, ns1__associateEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__associateEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__associateEntity, sizeof(ns1__associateEntity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__associateEntity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__associateEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_groupId1 = 1;
	size_t soap_flag_entityId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupId", &(a->ns1__associateEntity::groupId), "xsd:int"))
				{	soap_flag_groupId1--;
					continue;
				}
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__associateEntity::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__associateEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__associateEntity, 0, sizeof(ns1__associateEntity), 0, soap_copy_ns1__associateEntity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupId1 > 0 || soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__associateEntity * SOAP_FMAC6 soap_new_ns1__associateEntity(struct soap *soap, int n)
{	return soap_instantiate_ns1__associateEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__associateEntity(struct soap *soap, ns1__associateEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__associateEntity * SOAP_FMAC4 soap_instantiate_ns1__associateEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__associateEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__associateEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__associateEntity;
		if (size)
			*size = sizeof(ns1__associateEntity);
		((ns1__associateEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__associateEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__associateEntity);
		for (int i = 0; i < n; i++)
			((ns1__associateEntity*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__associateEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__associateEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__associateEntity %p -> %p\n", q, p));
	*(ns1__associateEntity*)p = *(ns1__associateEntity*)q;
}

void ns1__getPolicyHistoryResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getPolicyHistoryResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getPolicyHistoryResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumerationData(soap, &this->ns1__getPolicyHistoryResponse::return_);
	/* transient soap skipped */
}

int ns1__getPolicyHistoryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPolicyHistoryResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPolicyHistoryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPolicyHistoryResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPolicyHistoryResponse(struct soap *soap, const char *tag, int id, const ns1__getPolicyHistoryResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPolicyHistoryResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__enumerationData(soap, "return", -1, &(a->ns1__getPolicyHistoryResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPolicyHistoryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPolicyHistoryResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPolicyHistoryResponse * SOAP_FMAC4 soap_get_ns1__getPolicyHistoryResponse(struct soap *soap, ns1__getPolicyHistoryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPolicyHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPolicyHistoryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPolicyHistoryResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPolicyHistoryResponse * SOAP_FMAC4 soap_in_ns1__getPolicyHistoryResponse(struct soap *soap, const char *tag, ns1__getPolicyHistoryResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPolicyHistoryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPolicyHistoryResponse, sizeof(ns1__getPolicyHistoryResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPolicyHistoryResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPolicyHistoryResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumerationData(soap, "return", &(a->ns1__getPolicyHistoryResponse::return_), "ns1:enumerationData"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPolicyHistoryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPolicyHistoryResponse, 0, sizeof(ns1__getPolicyHistoryResponse), 0, soap_copy_ns1__getPolicyHistoryResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPolicyHistoryResponse * SOAP_FMAC6 soap_new_ns1__getPolicyHistoryResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPolicyHistoryResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPolicyHistoryResponse(struct soap *soap, ns1__getPolicyHistoryResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPolicyHistoryResponse * SOAP_FMAC4 soap_instantiate_ns1__getPolicyHistoryResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPolicyHistoryResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPolicyHistoryResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPolicyHistoryResponse;
		if (size)
			*size = sizeof(ns1__getPolicyHistoryResponse);
		((ns1__getPolicyHistoryResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPolicyHistoryResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPolicyHistoryResponse);
		for (int i = 0; i < n; i++)
			((ns1__getPolicyHistoryResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPolicyHistoryResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPolicyHistoryResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPolicyHistoryResponse %p -> %p\n", q, p));
	*(ns1__getPolicyHistoryResponse*)p = *(ns1__getPolicyHistoryResponse*)q;
}

void ns1__getPolicyHistory::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getPolicyHistory::entityId);
	this->ns1__getPolicyHistory::historyType = NULL;
	this->ns1__getPolicyHistory::aggregationLevel = NULL;
	this->ns1__getPolicyHistory::startTime = NULL;
	this->ns1__getPolicyHistory::endTime = NULL;
	/* transient soap skipped */
}

void ns1__getPolicyHistory::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__historyType(soap, &this->ns1__getPolicyHistory::historyType);
	soap_serialize_PointerTons1__aggregationLevel(soap, &this->ns1__getPolicyHistory::aggregationLevel);
	soap_serialize_PointerTotime(soap, &this->ns1__getPolicyHistory::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__getPolicyHistory::endTime);
	/* transient soap skipped */
}

int ns1__getPolicyHistory::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPolicyHistory);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPolicyHistory::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPolicyHistory(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPolicyHistory(struct soap *soap, const char *tag, int id, const ns1__getPolicyHistory *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPolicyHistory), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__getPolicyHistory::entityId), ""))
		return soap->error;
	if (soap_out_PointerTons1__historyType(soap, "historyType", -1, &(a->ns1__getPolicyHistory::historyType), ""))
		return soap->error;
	if (soap_out_PointerTons1__aggregationLevel(soap, "aggregationLevel", -1, &(a->ns1__getPolicyHistory::aggregationLevel), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__getPolicyHistory::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__getPolicyHistory::endTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPolicyHistory::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPolicyHistory(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPolicyHistory * SOAP_FMAC4 soap_get_ns1__getPolicyHistory(struct soap *soap, ns1__getPolicyHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPolicyHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPolicyHistory::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPolicyHistory(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPolicyHistory * SOAP_FMAC4 soap_in_ns1__getPolicyHistory(struct soap *soap, const char *tag, ns1__getPolicyHistory *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPolicyHistory *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPolicyHistory, sizeof(ns1__getPolicyHistory), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPolicyHistory)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPolicyHistory *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_historyType1 = 1;
	size_t soap_flag_aggregationLevel1 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_endTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__getPolicyHistory::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_historyType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__historyType(soap, "historyType", &(a->ns1__getPolicyHistory::historyType), "ns1:historyType"))
				{	soap_flag_historyType1--;
					continue;
				}
			if (soap_flag_aggregationLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__aggregationLevel(soap, "aggregationLevel", &(a->ns1__getPolicyHistory::aggregationLevel), "ns1:aggregationLevel"))
				{	soap_flag_aggregationLevel1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__getPolicyHistory::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__getPolicyHistory::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPolicyHistory *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPolicyHistory, 0, sizeof(ns1__getPolicyHistory), 0, soap_copy_ns1__getPolicyHistory);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPolicyHistory * SOAP_FMAC6 soap_new_ns1__getPolicyHistory(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPolicyHistory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPolicyHistory(struct soap *soap, ns1__getPolicyHistory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPolicyHistory * SOAP_FMAC4 soap_instantiate_ns1__getPolicyHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPolicyHistory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPolicyHistory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPolicyHistory;
		if (size)
			*size = sizeof(ns1__getPolicyHistory);
		((ns1__getPolicyHistory*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPolicyHistory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPolicyHistory);
		for (int i = 0; i < n; i++)
			((ns1__getPolicyHistory*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPolicyHistory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPolicyHistory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPolicyHistory %p -> %p\n", q, p));
	*(ns1__getPolicyHistory*)p = *(ns1__getPolicyHistory*)q;
}

void ns1__getActionLogRecordsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfstd__string(soap, &this->ns1__getActionLogRecordsResponse::return_);
	/* transient soap skipped */
}

void ns1__getActionLogRecordsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfstd__string(soap, &this->ns1__getActionLogRecordsResponse::return_);
	/* transient soap skipped */
}

int ns1__getActionLogRecordsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getActionLogRecordsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getActionLogRecordsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getActionLogRecordsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getActionLogRecordsResponse(struct soap *soap, const char *tag, int id, const ns1__getActionLogRecordsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getActionLogRecordsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfstd__string(soap, "return", -1, &(a->ns1__getActionLogRecordsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getActionLogRecordsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getActionLogRecordsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getActionLogRecordsResponse * SOAP_FMAC4 soap_get_ns1__getActionLogRecordsResponse(struct soap *soap, ns1__getActionLogRecordsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getActionLogRecordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getActionLogRecordsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getActionLogRecordsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getActionLogRecordsResponse * SOAP_FMAC4 soap_in_ns1__getActionLogRecordsResponse(struct soap *soap, const char *tag, ns1__getActionLogRecordsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getActionLogRecordsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getActionLogRecordsResponse, sizeof(ns1__getActionLogRecordsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getActionLogRecordsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getActionLogRecordsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfstd__string(soap, "return", &(a->ns1__getActionLogRecordsResponse::return_), "xsd:string"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getActionLogRecordsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getActionLogRecordsResponse, 0, sizeof(ns1__getActionLogRecordsResponse), 0, soap_copy_ns1__getActionLogRecordsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getActionLogRecordsResponse * SOAP_FMAC6 soap_new_ns1__getActionLogRecordsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getActionLogRecordsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getActionLogRecordsResponse(struct soap *soap, ns1__getActionLogRecordsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getActionLogRecordsResponse * SOAP_FMAC4 soap_instantiate_ns1__getActionLogRecordsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getActionLogRecordsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getActionLogRecordsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getActionLogRecordsResponse;
		if (size)
			*size = sizeof(ns1__getActionLogRecordsResponse);
		((ns1__getActionLogRecordsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getActionLogRecordsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getActionLogRecordsResponse);
		for (int i = 0; i < n; i++)
			((ns1__getActionLogRecordsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getActionLogRecordsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getActionLogRecordsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getActionLogRecordsResponse %p -> %p\n", q, p));
	*(ns1__getActionLogRecordsResponse*)p = *(ns1__getActionLogRecordsResponse*)q;
}

void ns1__getActionLogRecords::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getActionLogRecords::logType = NULL;
	this->ns1__getActionLogRecords::startTime = NULL;
	this->ns1__getActionLogRecords::endTime = NULL;
	/* transient soap skipped */
}

void ns1__getActionLogRecords::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__actionLogType(soap, &this->ns1__getActionLogRecords::logType);
	soap_serialize_PointerTotime(soap, &this->ns1__getActionLogRecords::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__getActionLogRecords::endTime);
	/* transient soap skipped */
}

int ns1__getActionLogRecords::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getActionLogRecords);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getActionLogRecords::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getActionLogRecords(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getActionLogRecords(struct soap *soap, const char *tag, int id, const ns1__getActionLogRecords *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getActionLogRecords), type))
		return soap->error;
	if (soap_out_PointerTons1__actionLogType(soap, "logType", -1, &(a->ns1__getActionLogRecords::logType), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__getActionLogRecords::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__getActionLogRecords::endTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getActionLogRecords::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getActionLogRecords(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getActionLogRecords * SOAP_FMAC4 soap_get_ns1__getActionLogRecords(struct soap *soap, ns1__getActionLogRecords *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getActionLogRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getActionLogRecords::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getActionLogRecords(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getActionLogRecords * SOAP_FMAC4 soap_in_ns1__getActionLogRecords(struct soap *soap, const char *tag, ns1__getActionLogRecords *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getActionLogRecords *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getActionLogRecords, sizeof(ns1__getActionLogRecords), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getActionLogRecords)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getActionLogRecords *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_logType1 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_endTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_logType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__actionLogType(soap, "logType", &(a->ns1__getActionLogRecords::logType), "ns1:actionLogType"))
				{	soap_flag_logType1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__getActionLogRecords::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__getActionLogRecords::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getActionLogRecords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getActionLogRecords, 0, sizeof(ns1__getActionLogRecords), 0, soap_copy_ns1__getActionLogRecords);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getActionLogRecords * SOAP_FMAC6 soap_new_ns1__getActionLogRecords(struct soap *soap, int n)
{	return soap_instantiate_ns1__getActionLogRecords(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getActionLogRecords(struct soap *soap, ns1__getActionLogRecords *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getActionLogRecords * SOAP_FMAC4 soap_instantiate_ns1__getActionLogRecords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getActionLogRecords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getActionLogRecords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getActionLogRecords;
		if (size)
			*size = sizeof(ns1__getActionLogRecords);
		((ns1__getActionLogRecords*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getActionLogRecords[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getActionLogRecords);
		for (int i = 0; i < n; i++)
			((ns1__getActionLogRecords*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getActionLogRecords*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getActionLogRecords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getActionLogRecords %p -> %p\n", q, p));
	*(ns1__getActionLogRecords*)p = *(ns1__getActionLogRecords*)q;
}

void ns1__setPolicyStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__setPolicyStateResponse::return_);
	/* transient soap skipped */
}

void ns1__setPolicyStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setPolicyStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setPolicyStateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setPolicyStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setPolicyStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setPolicyStateResponse(struct soap *soap, const char *tag, int id, const ns1__setPolicyStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setPolicyStateResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__setPolicyStateResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setPolicyStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setPolicyStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setPolicyStateResponse * SOAP_FMAC4 soap_get_ns1__setPolicyStateResponse(struct soap *soap, ns1__setPolicyStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setPolicyStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setPolicyStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setPolicyStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setPolicyStateResponse * SOAP_FMAC4 soap_in_ns1__setPolicyStateResponse(struct soap *soap, const char *tag, ns1__setPolicyStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setPolicyStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setPolicyStateResponse, sizeof(ns1__setPolicyStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setPolicyStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setPolicyStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__setPolicyStateResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setPolicyStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setPolicyStateResponse, 0, sizeof(ns1__setPolicyStateResponse), 0, soap_copy_ns1__setPolicyStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setPolicyStateResponse * SOAP_FMAC6 soap_new_ns1__setPolicyStateResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__setPolicyStateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setPolicyStateResponse(struct soap *soap, ns1__setPolicyStateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setPolicyStateResponse * SOAP_FMAC4 soap_instantiate_ns1__setPolicyStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setPolicyStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setPolicyStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setPolicyStateResponse;
		if (size)
			*size = sizeof(ns1__setPolicyStateResponse);
		((ns1__setPolicyStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setPolicyStateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setPolicyStateResponse);
		for (int i = 0; i < n; i++)
			((ns1__setPolicyStateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setPolicyStateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setPolicyStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setPolicyStateResponse %p -> %p\n", q, p));
	*(ns1__setPolicyStateResponse*)p = *(ns1__setPolicyStateResponse*)q;
}

void ns1__setPolicyState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__setPolicyState::policyId);
	soap_default_bool(soap, &this->ns1__setPolicyState::enable);
	/* transient soap skipped */
}

void ns1__setPolicyState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setPolicyState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setPolicyState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setPolicyState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setPolicyState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setPolicyState(struct soap *soap, const char *tag, int id, const ns1__setPolicyState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setPolicyState), type))
		return soap->error;
	if (soap_out_int(soap, "policyId", -1, &(a->ns1__setPolicyState::policyId), ""))
		return soap->error;
	if (soap_out_bool(soap, "enable", -1, &(a->ns1__setPolicyState::enable), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setPolicyState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setPolicyState(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setPolicyState * SOAP_FMAC4 soap_get_ns1__setPolicyState(struct soap *soap, ns1__setPolicyState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setPolicyState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setPolicyState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setPolicyState(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setPolicyState * SOAP_FMAC4 soap_in_ns1__setPolicyState(struct soap *soap, const char *tag, ns1__setPolicyState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setPolicyState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setPolicyState, sizeof(ns1__setPolicyState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setPolicyState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setPolicyState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_policyId1 = 1;
	size_t soap_flag_enable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_policyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "policyId", &(a->ns1__setPolicyState::policyId), "xsd:int"))
				{	soap_flag_policyId1--;
					continue;
				}
			if (soap_flag_enable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enable", &(a->ns1__setPolicyState::enable), "xsd:boolean"))
				{	soap_flag_enable1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setPolicyState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setPolicyState, 0, sizeof(ns1__setPolicyState), 0, soap_copy_ns1__setPolicyState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_policyId1 > 0 || soap_flag_enable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setPolicyState * SOAP_FMAC6 soap_new_ns1__setPolicyState(struct soap *soap, int n)
{	return soap_instantiate_ns1__setPolicyState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setPolicyState(struct soap *soap, ns1__setPolicyState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setPolicyState * SOAP_FMAC4 soap_instantiate_ns1__setPolicyState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setPolicyState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setPolicyState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setPolicyState;
		if (size)
			*size = sizeof(ns1__setPolicyState);
		((ns1__setPolicyState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setPolicyState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setPolicyState);
		for (int i = 0; i < n; i++)
			((ns1__setPolicyState*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setPolicyState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setPolicyState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setPolicyState %p -> %p\n", q, p));
	*(ns1__setPolicyState*)p = *(ns1__setPolicyState*)q;
}

void ns1__policyData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns1__day(soap, &this->ns1__policyData::days);
	soap_default_int(soap, &this->ns1__policyData::endHour);
	this->ns1__policyData::endTime = NULL;
	soap_default_int(soap, &this->ns1__policyData::entityId);
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__policyData::highPriorityList);
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__policyData::lowPriorityList);
	this->ns1__policyData::policyDescription = NULL;
	this->ns1__policyData::policyType = NULL;
	soap_default_int(soap, &this->ns1__policyData::startHour);
	this->ns1__policyData::startTime = NULL;
	soap_default_int(soap, &this->ns1__policyData::threshold);
	/* transient soap skipped */
}

void ns1__policyData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns1__day(soap, &this->ns1__policyData::days);
	soap_serialize_PointerTotime(soap, &this->ns1__policyData::endTime);
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__policyData::highPriorityList);
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__policyData::lowPriorityList);
	soap_serialize_PointerTostd__string(soap, &this->ns1__policyData::policyDescription);
	soap_serialize_PointerTons1__policyType(soap, &this->ns1__policyData::policyType);
	soap_serialize_PointerTotime(soap, &this->ns1__policyData::startTime);
	/* transient soap skipped */
}

int ns1__policyData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__policyData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__policyData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__policyData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__policyData(struct soap *soap, const char *tag, int id, const ns1__policyData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__policyData), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__day(soap, "days", -1, &(a->ns1__policyData::days), ""))
		return soap->error;
	if (soap_out_int(soap, "endHour", -1, &(a->ns1__policyData::endHour), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__policyData::endTime), ""))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__policyData::entityId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "highPriorityList", -1, &(a->ns1__policyData::highPriorityList), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "lowPriorityList", -1, &(a->ns1__policyData::lowPriorityList), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "policyDescription", -1, &(a->ns1__policyData::policyDescription), ""))
		return soap->error;
	if (soap_out_PointerTons1__policyType(soap, "policyType", -1, &(a->ns1__policyData::policyType), ""))
		return soap->error;
	if (soap_out_int(soap, "startHour", -1, &(a->ns1__policyData::startHour), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__policyData::startTime), ""))
		return soap->error;
	if (soap_out_int(soap, "threshold", -1, &(a->ns1__policyData::threshold), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__policyData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__policyData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__policyData * SOAP_FMAC4 soap_get_ns1__policyData(struct soap *soap, ns1__policyData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__policyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__policyData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__policyData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__policyData * SOAP_FMAC4 soap_in_ns1__policyData(struct soap *soap, const char *tag, ns1__policyData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__policyData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__policyData, sizeof(ns1__policyData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__policyData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__policyData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_endHour1 = 1;
	size_t soap_flag_endTime1 = 1;
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_policyDescription1 = 1;
	size_t soap_flag_policyType1 = 1;
	size_t soap_flag_startHour1 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_threshold1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__day(soap, "days", &(a->ns1__policyData::days), "ns1:day"))
					continue;
			if (soap_flag_endHour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "endHour", &(a->ns1__policyData::endHour), "xsd:int"))
				{	soap_flag_endHour1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__policyData::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__policyData::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "highPriorityList", &(a->ns1__policyData::highPriorityList), "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "lowPriorityList", &(a->ns1__policyData::lowPriorityList), "xsd:int"))
					continue;
			if (soap_flag_policyDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "policyDescription", &(a->ns1__policyData::policyDescription), "xsd:string"))
				{	soap_flag_policyDescription1--;
					continue;
				}
			if (soap_flag_policyType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__policyType(soap, "policyType", &(a->ns1__policyData::policyType), "ns1:policyType"))
				{	soap_flag_policyType1--;
					continue;
				}
			if (soap_flag_startHour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startHour", &(a->ns1__policyData::startHour), "xsd:int"))
				{	soap_flag_startHour1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__policyData::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_threshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "threshold", &(a->ns1__policyData::threshold), "xsd:int"))
				{	soap_flag_threshold1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__policyData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__policyData, 0, sizeof(ns1__policyData), 0, soap_copy_ns1__policyData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_endHour1 > 0 || soap_flag_entityId1 > 0 || soap_flag_startHour1 > 0 || soap_flag_threshold1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__policyData * SOAP_FMAC6 soap_new_ns1__policyData(struct soap *soap, int n)
{	return soap_instantiate_ns1__policyData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__policyData(struct soap *soap, ns1__policyData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__policyData * SOAP_FMAC4 soap_instantiate_ns1__policyData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__policyData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__policyData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__policyData;
		if (size)
			*size = sizeof(ns1__policyData);
		((ns1__policyData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__policyData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__policyData);
		for (int i = 0; i < n; i++)
			((ns1__policyData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__policyData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__policyData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__policyData %p -> %p\n", q, p));
	*(ns1__policyData*)p = *(ns1__policyData*)q;
}

void ns1__getPolicyDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getPolicyDataResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getPolicyDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__policyData(soap, &this->ns1__getPolicyDataResponse::return_);
	/* transient soap skipped */
}

int ns1__getPolicyDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPolicyDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPolicyDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPolicyDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPolicyDataResponse(struct soap *soap, const char *tag, int id, const ns1__getPolicyDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPolicyDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__policyData(soap, "return", -1, &(a->ns1__getPolicyDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPolicyDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPolicyDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPolicyDataResponse * SOAP_FMAC4 soap_get_ns1__getPolicyDataResponse(struct soap *soap, ns1__getPolicyDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPolicyDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPolicyDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPolicyDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPolicyDataResponse * SOAP_FMAC4 soap_in_ns1__getPolicyDataResponse(struct soap *soap, const char *tag, ns1__getPolicyDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPolicyDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPolicyDataResponse, sizeof(ns1__getPolicyDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPolicyDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPolicyDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__policyData(soap, "return", &(a->ns1__getPolicyDataResponse::return_), "ns1:policyData"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPolicyDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPolicyDataResponse, 0, sizeof(ns1__getPolicyDataResponse), 0, soap_copy_ns1__getPolicyDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPolicyDataResponse * SOAP_FMAC6 soap_new_ns1__getPolicyDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPolicyDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPolicyDataResponse(struct soap *soap, ns1__getPolicyDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPolicyDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getPolicyDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPolicyDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPolicyDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPolicyDataResponse;
		if (size)
			*size = sizeof(ns1__getPolicyDataResponse);
		((ns1__getPolicyDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPolicyDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPolicyDataResponse);
		for (int i = 0; i < n; i++)
			((ns1__getPolicyDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPolicyDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPolicyDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPolicyDataResponse %p -> %p\n", q, p));
	*(ns1__getPolicyDataResponse*)p = *(ns1__getPolicyDataResponse*)q;
}

void ns1__getPolicyData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getPolicyData::policyId);
	/* transient soap skipped */
}

void ns1__getPolicyData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getPolicyData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPolicyData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPolicyData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPolicyData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPolicyData(struct soap *soap, const char *tag, int id, const ns1__getPolicyData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPolicyData), type))
		return soap->error;
	if (soap_out_int(soap, "policyId", -1, &(a->ns1__getPolicyData::policyId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPolicyData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPolicyData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPolicyData * SOAP_FMAC4 soap_get_ns1__getPolicyData(struct soap *soap, ns1__getPolicyData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPolicyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPolicyData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPolicyData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPolicyData * SOAP_FMAC4 soap_in_ns1__getPolicyData(struct soap *soap, const char *tag, ns1__getPolicyData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPolicyData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPolicyData, sizeof(ns1__getPolicyData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPolicyData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPolicyData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_policyId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_policyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "policyId", &(a->ns1__getPolicyData::policyId), "xsd:int"))
				{	soap_flag_policyId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPolicyData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPolicyData, 0, sizeof(ns1__getPolicyData), 0, soap_copy_ns1__getPolicyData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_policyId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPolicyData * SOAP_FMAC6 soap_new_ns1__getPolicyData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPolicyData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPolicyData(struct soap *soap, ns1__getPolicyData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPolicyData * SOAP_FMAC4 soap_instantiate_ns1__getPolicyData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPolicyData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPolicyData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPolicyData;
		if (size)
			*size = sizeof(ns1__getPolicyData);
		((ns1__getPolicyData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPolicyData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPolicyData);
		for (int i = 0; i < n; i++)
			((ns1__getPolicyData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPolicyData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPolicyData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPolicyData %p -> %p\n", q, p));
	*(ns1__getPolicyData*)p = *(ns1__getPolicyData*)q;
}

void ns1__getMetricAggregationPeriodListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, &this->ns1__getMetricAggregationPeriodListResponse::return_);
	/* transient soap skipped */
}

void ns1__getMetricAggregationPeriodListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, &this->ns1__getMetricAggregationPeriodListResponse::return_);
	/* transient soap skipped */
}

int ns1__getMetricAggregationPeriodListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getMetricAggregationPeriodListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMetricAggregationPeriodListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetricAggregationPeriodListResponse(struct soap *soap, const char *tag, int id, const ns1__getMetricAggregationPeriodListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, "return", -1, &(a->ns1__getMetricAggregationPeriodListResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getMetricAggregationPeriodListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMetricAggregationPeriodListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodListResponse * SOAP_FMAC4 soap_get_ns1__getMetricAggregationPeriodListResponse(struct soap *soap, ns1__getMetricAggregationPeriodListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetricAggregationPeriodListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getMetricAggregationPeriodListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMetricAggregationPeriodListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodListResponse * SOAP_FMAC4 soap_in_ns1__getMetricAggregationPeriodListResponse(struct soap *soap, const char *tag, ns1__getMetricAggregationPeriodListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMetricAggregationPeriodListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse, sizeof(ns1__getMetricAggregationPeriodListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMetricAggregationPeriodListResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, "return", &(a->ns1__getMetricAggregationPeriodListResponse::return_), "ns1:aggregationPeriod"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMetricAggregationPeriodListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse, 0, sizeof(ns1__getMetricAggregationPeriodListResponse), 0, soap_copy_ns1__getMetricAggregationPeriodListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getMetricAggregationPeriodListResponse * SOAP_FMAC6 soap_new_ns1__getMetricAggregationPeriodListResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getMetricAggregationPeriodListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getMetricAggregationPeriodListResponse(struct soap *soap, ns1__getMetricAggregationPeriodListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodListResponse * SOAP_FMAC4 soap_instantiate_ns1__getMetricAggregationPeriodListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMetricAggregationPeriodListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getMetricAggregationPeriodListResponse;
		if (size)
			*size = sizeof(ns1__getMetricAggregationPeriodListResponse);
		((ns1__getMetricAggregationPeriodListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getMetricAggregationPeriodListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMetricAggregationPeriodListResponse);
		for (int i = 0; i < n; i++)
			((ns1__getMetricAggregationPeriodListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMetricAggregationPeriodListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMetricAggregationPeriodListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMetricAggregationPeriodListResponse %p -> %p\n", q, p));
	*(ns1__getMetricAggregationPeriodListResponse*)p = *(ns1__getMetricAggregationPeriodListResponse*)q;
}

void ns1__getMetricAggregationPeriodList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getMetricAggregationPeriodList::startTime = NULL;
	this->ns1__getMetricAggregationPeriodList::endTime = NULL;
	this->ns1__getMetricAggregationPeriodList::metricType = NULL;
	/* transient soap skipped */
}

void ns1__getMetricAggregationPeriodList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__getMetricAggregationPeriodList::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__getMetricAggregationPeriodList::endTime);
	soap_serialize_PointerTons1__metricType(soap, &this->ns1__getMetricAggregationPeriodList::metricType);
	/* transient soap skipped */
}

int ns1__getMetricAggregationPeriodList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMetricAggregationPeriodList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getMetricAggregationPeriodList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMetricAggregationPeriodList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetricAggregationPeriodList(struct soap *soap, const char *tag, int id, const ns1__getMetricAggregationPeriodList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetricAggregationPeriodList), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__getMetricAggregationPeriodList::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__getMetricAggregationPeriodList::endTime), ""))
		return soap->error;
	if (soap_out_PointerTons1__metricType(soap, "metricType", -1, &(a->ns1__getMetricAggregationPeriodList::metricType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getMetricAggregationPeriodList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMetricAggregationPeriodList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodList * SOAP_FMAC4 soap_get_ns1__getMetricAggregationPeriodList(struct soap *soap, ns1__getMetricAggregationPeriodList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetricAggregationPeriodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getMetricAggregationPeriodList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMetricAggregationPeriodList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodList * SOAP_FMAC4 soap_in_ns1__getMetricAggregationPeriodList(struct soap *soap, const char *tag, ns1__getMetricAggregationPeriodList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMetricAggregationPeriodList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetricAggregationPeriodList, sizeof(ns1__getMetricAggregationPeriodList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMetricAggregationPeriodList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMetricAggregationPeriodList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_endTime1 = 1;
	size_t soap_flag_metricType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__getMetricAggregationPeriodList::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__getMetricAggregationPeriodList::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_metricType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__metricType(soap, "metricType", &(a->ns1__getMetricAggregationPeriodList::metricType), "ns1:metricType"))
				{	soap_flag_metricType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMetricAggregationPeriodList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetricAggregationPeriodList, 0, sizeof(ns1__getMetricAggregationPeriodList), 0, soap_copy_ns1__getMetricAggregationPeriodList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getMetricAggregationPeriodList * SOAP_FMAC6 soap_new_ns1__getMetricAggregationPeriodList(struct soap *soap, int n)
{	return soap_instantiate_ns1__getMetricAggregationPeriodList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getMetricAggregationPeriodList(struct soap *soap, ns1__getMetricAggregationPeriodList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodList * SOAP_FMAC4 soap_instantiate_ns1__getMetricAggregationPeriodList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMetricAggregationPeriodList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMetricAggregationPeriodList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getMetricAggregationPeriodList;
		if (size)
			*size = sizeof(ns1__getMetricAggregationPeriodList);
		((ns1__getMetricAggregationPeriodList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getMetricAggregationPeriodList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMetricAggregationPeriodList);
		for (int i = 0; i < n; i++)
			((ns1__getMetricAggregationPeriodList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMetricAggregationPeriodList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMetricAggregationPeriodList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMetricAggregationPeriodList %p -> %p\n", q, p));
	*(ns1__getMetricAggregationPeriodList*)p = *(ns1__getMetricAggregationPeriodList*)q;
}

void ns1__defineCustomEventResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__defineCustomEventResponse::return_);
	/* transient soap skipped */
}

void ns1__defineCustomEventResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__defineCustomEventResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__defineCustomEventResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__defineCustomEventResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__defineCustomEventResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__defineCustomEventResponse(struct soap *soap, const char *tag, int id, const ns1__defineCustomEventResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__defineCustomEventResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &(a->ns1__defineCustomEventResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__defineCustomEventResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__defineCustomEventResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__defineCustomEventResponse * SOAP_FMAC4 soap_get_ns1__defineCustomEventResponse(struct soap *soap, ns1__defineCustomEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__defineCustomEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__defineCustomEventResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__defineCustomEventResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__defineCustomEventResponse * SOAP_FMAC4 soap_in_ns1__defineCustomEventResponse(struct soap *soap, const char *tag, ns1__defineCustomEventResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__defineCustomEventResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__defineCustomEventResponse, sizeof(ns1__defineCustomEventResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__defineCustomEventResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__defineCustomEventResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &(a->ns1__defineCustomEventResponse::return_), "xsd:int"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__defineCustomEventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__defineCustomEventResponse, 0, sizeof(ns1__defineCustomEventResponse), 0, soap_copy_ns1__defineCustomEventResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__defineCustomEventResponse * SOAP_FMAC6 soap_new_ns1__defineCustomEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__defineCustomEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__defineCustomEventResponse(struct soap *soap, ns1__defineCustomEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__defineCustomEventResponse * SOAP_FMAC4 soap_instantiate_ns1__defineCustomEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__defineCustomEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__defineCustomEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__defineCustomEventResponse;
		if (size)
			*size = sizeof(ns1__defineCustomEventResponse);
		((ns1__defineCustomEventResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__defineCustomEventResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__defineCustomEventResponse);
		for (int i = 0; i < n; i++)
			((ns1__defineCustomEventResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__defineCustomEventResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__defineCustomEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__defineCustomEventResponse %p -> %p\n", q, p));
	*(ns1__defineCustomEventResponse*)p = *(ns1__defineCustomEventResponse*)q;
}

void ns1__defineCustomEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__defineCustomEvent::entityId);
	this->ns1__defineCustomEvent::eventType = NULL;
	this->ns1__defineCustomEvent::conditionOperator = NULL;
	soap_default_int(soap, &this->ns1__defineCustomEvent::threshold);
	soap_default_int(soap, &this->ns1__defineCustomEvent::evalPeriod);
	this->ns1__defineCustomEvent::eventDescription = NULL;
	soap_default_bool(soap, &this->ns1__defineCustomEvent::enabled);
	/* transient soap skipped */
}

void ns1__defineCustomEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__customEventType(soap, &this->ns1__defineCustomEvent::eventType);
	soap_serialize_PointerTons1__conditionOperator(soap, &this->ns1__defineCustomEvent::conditionOperator);
	soap_serialize_PointerTostd__string(soap, &this->ns1__defineCustomEvent::eventDescription);
	/* transient soap skipped */
}

int ns1__defineCustomEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__defineCustomEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__defineCustomEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__defineCustomEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__defineCustomEvent(struct soap *soap, const char *tag, int id, const ns1__defineCustomEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__defineCustomEvent), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__defineCustomEvent::entityId), ""))
		return soap->error;
	if (soap_out_PointerTons1__customEventType(soap, "eventType", -1, &(a->ns1__defineCustomEvent::eventType), ""))
		return soap->error;
	if (soap_out_PointerTons1__conditionOperator(soap, "conditionOperator", -1, &(a->ns1__defineCustomEvent::conditionOperator), ""))
		return soap->error;
	if (soap_out_int(soap, "threshold", -1, &(a->ns1__defineCustomEvent::threshold), ""))
		return soap->error;
	if (soap_out_int(soap, "evalPeriod", -1, &(a->ns1__defineCustomEvent::evalPeriod), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eventDescription", -1, &(a->ns1__defineCustomEvent::eventDescription), ""))
		return soap->error;
	if (soap_out_bool(soap, "enabled", -1, &(a->ns1__defineCustomEvent::enabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__defineCustomEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__defineCustomEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__defineCustomEvent * SOAP_FMAC4 soap_get_ns1__defineCustomEvent(struct soap *soap, ns1__defineCustomEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__defineCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__defineCustomEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__defineCustomEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__defineCustomEvent * SOAP_FMAC4 soap_in_ns1__defineCustomEvent(struct soap *soap, const char *tag, ns1__defineCustomEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__defineCustomEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__defineCustomEvent, sizeof(ns1__defineCustomEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__defineCustomEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__defineCustomEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_eventType1 = 1;
	size_t soap_flag_conditionOperator1 = 1;
	size_t soap_flag_threshold1 = 1;
	size_t soap_flag_evalPeriod1 = 1;
	size_t soap_flag_eventDescription1 = 1;
	size_t soap_flag_enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__defineCustomEvent::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_eventType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__customEventType(soap, "eventType", &(a->ns1__defineCustomEvent::eventType), "ns1:customEventType"))
				{	soap_flag_eventType1--;
					continue;
				}
			if (soap_flag_conditionOperator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__conditionOperator(soap, "conditionOperator", &(a->ns1__defineCustomEvent::conditionOperator), "ns1:conditionOperator"))
				{	soap_flag_conditionOperator1--;
					continue;
				}
			if (soap_flag_threshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "threshold", &(a->ns1__defineCustomEvent::threshold), "xsd:int"))
				{	soap_flag_threshold1--;
					continue;
				}
			if (soap_flag_evalPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "evalPeriod", &(a->ns1__defineCustomEvent::evalPeriod), "xsd:int"))
				{	soap_flag_evalPeriod1--;
					continue;
				}
			if (soap_flag_eventDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eventDescription", &(a->ns1__defineCustomEvent::eventDescription), "xsd:string"))
				{	soap_flag_eventDescription1--;
					continue;
				}
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enabled", &(a->ns1__defineCustomEvent::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__defineCustomEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__defineCustomEvent, 0, sizeof(ns1__defineCustomEvent), 0, soap_copy_ns1__defineCustomEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_threshold1 > 0 || soap_flag_evalPeriod1 > 0 || soap_flag_enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__defineCustomEvent * SOAP_FMAC6 soap_new_ns1__defineCustomEvent(struct soap *soap, int n)
{	return soap_instantiate_ns1__defineCustomEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__defineCustomEvent(struct soap *soap, ns1__defineCustomEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__defineCustomEvent * SOAP_FMAC4 soap_instantiate_ns1__defineCustomEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__defineCustomEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__defineCustomEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__defineCustomEvent;
		if (size)
			*size = sizeof(ns1__defineCustomEvent);
		((ns1__defineCustomEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__defineCustomEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__defineCustomEvent);
		for (int i = 0; i < n; i++)
			((ns1__defineCustomEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__defineCustomEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__defineCustomEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__defineCustomEvent %p -> %p\n", q, p));
	*(ns1__defineCustomEvent*)p = *(ns1__defineCustomEvent*)q;
}

void ns1__enumerateEntitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__enumerateEntitiesResponse::return_);
	/* transient soap skipped */
}

void ns1__enumerateEntitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__enumerateEntitiesResponse::return_);
	/* transient soap skipped */
}

int ns1__enumerateEntitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumerateEntitiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumerateEntitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumerateEntitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumerateEntitiesResponse(struct soap *soap, const char *tag, int id, const ns1__enumerateEntitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumerateEntitiesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "return", -1, &(a->ns1__enumerateEntitiesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumerateEntitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumerateEntitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumerateEntitiesResponse * SOAP_FMAC4 soap_get_ns1__enumerateEntitiesResponse(struct soap *soap, ns1__enumerateEntitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumerateEntitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumerateEntitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumerateEntitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumerateEntitiesResponse * SOAP_FMAC4 soap_in_ns1__enumerateEntitiesResponse(struct soap *soap, const char *tag, ns1__enumerateEntitiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumerateEntitiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumerateEntitiesResponse, sizeof(ns1__enumerateEntitiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumerateEntitiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumerateEntitiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "return", &(a->ns1__enumerateEntitiesResponse::return_), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumerateEntitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumerateEntitiesResponse, 0, sizeof(ns1__enumerateEntitiesResponse), 0, soap_copy_ns1__enumerateEntitiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumerateEntitiesResponse * SOAP_FMAC6 soap_new_ns1__enumerateEntitiesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumerateEntitiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumerateEntitiesResponse(struct soap *soap, ns1__enumerateEntitiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumerateEntitiesResponse * SOAP_FMAC4 soap_instantiate_ns1__enumerateEntitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumerateEntitiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumerateEntitiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumerateEntitiesResponse;
		if (size)
			*size = sizeof(ns1__enumerateEntitiesResponse);
		((ns1__enumerateEntitiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumerateEntitiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumerateEntitiesResponse);
		for (int i = 0; i < n; i++)
			((ns1__enumerateEntitiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumerateEntitiesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumerateEntitiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumerateEntitiesResponse %p -> %p\n", q, p));
	*(ns1__enumerateEntitiesResponse*)p = *(ns1__enumerateEntitiesResponse*)q;
}

void ns1__enumerateEntities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__enumerateEntities::entityId);
	this->ns1__enumerateEntities::entityType = NULL;
	/* transient soap skipped */
}

void ns1__enumerateEntities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__entityType(soap, &this->ns1__enumerateEntities::entityType);
	/* transient soap skipped */
}

int ns1__enumerateEntities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumerateEntities);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumerateEntities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumerateEntities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumerateEntities(struct soap *soap, const char *tag, int id, const ns1__enumerateEntities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumerateEntities), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__enumerateEntities::entityId), ""))
		return soap->error;
	if (soap_out_PointerTons1__entityType(soap, "entityType", -1, &(a->ns1__enumerateEntities::entityType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumerateEntities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumerateEntities(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumerateEntities * SOAP_FMAC4 soap_get_ns1__enumerateEntities(struct soap *soap, ns1__enumerateEntities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumerateEntities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumerateEntities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumerateEntities(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumerateEntities * SOAP_FMAC4 soap_in_ns1__enumerateEntities(struct soap *soap, const char *tag, ns1__enumerateEntities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumerateEntities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumerateEntities, sizeof(ns1__enumerateEntities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumerateEntities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumerateEntities *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_entityType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__enumerateEntities::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_entityType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__entityType(soap, "entityType", &(a->ns1__enumerateEntities::entityType), "ns1:entityType"))
				{	soap_flag_entityType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumerateEntities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumerateEntities, 0, sizeof(ns1__enumerateEntities), 0, soap_copy_ns1__enumerateEntities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumerateEntities * SOAP_FMAC6 soap_new_ns1__enumerateEntities(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumerateEntities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumerateEntities(struct soap *soap, ns1__enumerateEntities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumerateEntities * SOAP_FMAC4 soap_instantiate_ns1__enumerateEntities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumerateEntities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumerateEntities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumerateEntities;
		if (size)
			*size = sizeof(ns1__enumerateEntities);
		((ns1__enumerateEntities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumerateEntities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumerateEntities);
		for (int i = 0; i < n; i++)
			((ns1__enumerateEntities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumerateEntities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumerateEntities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumerateEntities %p -> %p\n", q, p));
	*(ns1__enumerateEntities*)p = *(ns1__enumerateEntities*)q;
}

void ns1__getCollectionStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__getCollectionStateResponse::return_);
	/* transient soap skipped */
}

void ns1__getCollectionStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getCollectionStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getCollectionStateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getCollectionStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCollectionStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCollectionStateResponse(struct soap *soap, const char *tag, int id, const ns1__getCollectionStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCollectionStateResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__getCollectionStateResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCollectionStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCollectionStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCollectionStateResponse * SOAP_FMAC4 soap_get_ns1__getCollectionStateResponse(struct soap *soap, ns1__getCollectionStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCollectionStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getCollectionStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCollectionStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCollectionStateResponse * SOAP_FMAC4 soap_in_ns1__getCollectionStateResponse(struct soap *soap, const char *tag, ns1__getCollectionStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCollectionStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCollectionStateResponse, sizeof(ns1__getCollectionStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCollectionStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCollectionStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__getCollectionStateResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCollectionStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCollectionStateResponse, 0, sizeof(ns1__getCollectionStateResponse), 0, soap_copy_ns1__getCollectionStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getCollectionStateResponse * SOAP_FMAC6 soap_new_ns1__getCollectionStateResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getCollectionStateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getCollectionStateResponse(struct soap *soap, ns1__getCollectionStateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getCollectionStateResponse * SOAP_FMAC4 soap_instantiate_ns1__getCollectionStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCollectionStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCollectionStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getCollectionStateResponse;
		if (size)
			*size = sizeof(ns1__getCollectionStateResponse);
		((ns1__getCollectionStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getCollectionStateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getCollectionStateResponse);
		for (int i = 0; i < n; i++)
			((ns1__getCollectionStateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getCollectionStateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCollectionStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCollectionStateResponse %p -> %p\n", q, p));
	*(ns1__getCollectionStateResponse*)p = *(ns1__getCollectionStateResponse*)q;
}

void ns1__getCollectionState::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__getCollectionState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getCollectionState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getCollectionState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getCollectionState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCollectionState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCollectionState(struct soap *soap, const char *tag, int id, const ns1__getCollectionState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCollectionState), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCollectionState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCollectionState(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCollectionState * SOAP_FMAC4 soap_get_ns1__getCollectionState(struct soap *soap, ns1__getCollectionState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCollectionState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getCollectionState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCollectionState(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCollectionState * SOAP_FMAC4 soap_in_ns1__getCollectionState(struct soap *soap, const char *tag, ns1__getCollectionState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCollectionState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCollectionState, sizeof(ns1__getCollectionState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCollectionState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCollectionState *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCollectionState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCollectionState, 0, sizeof(ns1__getCollectionState), 0, soap_copy_ns1__getCollectionState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getCollectionState * SOAP_FMAC6 soap_new_ns1__getCollectionState(struct soap *soap, int n)
{	return soap_instantiate_ns1__getCollectionState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getCollectionState(struct soap *soap, ns1__getCollectionState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getCollectionState * SOAP_FMAC4 soap_instantiate_ns1__getCollectionState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCollectionState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCollectionState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getCollectionState;
		if (size)
			*size = sizeof(ns1__getCollectionState);
		((ns1__getCollectionState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getCollectionState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getCollectionState);
		for (int i = 0; i < n; i++)
			((ns1__getCollectionState*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getCollectionState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCollectionState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCollectionState %p -> %p\n", q, p));
	*(ns1__getCollectionState*)p = *(ns1__getCollectionState*)q;
}

void ns1__deleteSecretKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__deleteSecretKeyResponse::return_);
	/* transient soap skipped */
}

void ns1__deleteSecretKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__deleteSecretKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteSecretKeyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__deleteSecretKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteSecretKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteSecretKeyResponse(struct soap *soap, const char *tag, int id, const ns1__deleteSecretKeyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteSecretKeyResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__deleteSecretKeyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteSecretKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteSecretKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteSecretKeyResponse * SOAP_FMAC4 soap_get_ns1__deleteSecretKeyResponse(struct soap *soap, ns1__deleteSecretKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteSecretKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__deleteSecretKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteSecretKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteSecretKeyResponse * SOAP_FMAC4 soap_in_ns1__deleteSecretKeyResponse(struct soap *soap, const char *tag, ns1__deleteSecretKeyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteSecretKeyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteSecretKeyResponse, sizeof(ns1__deleteSecretKeyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteSecretKeyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteSecretKeyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__deleteSecretKeyResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteSecretKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteSecretKeyResponse, 0, sizeof(ns1__deleteSecretKeyResponse), 0, soap_copy_ns1__deleteSecretKeyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__deleteSecretKeyResponse * SOAP_FMAC6 soap_new_ns1__deleteSecretKeyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__deleteSecretKeyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__deleteSecretKeyResponse(struct soap *soap, ns1__deleteSecretKeyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__deleteSecretKeyResponse * SOAP_FMAC4 soap_instantiate_ns1__deleteSecretKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteSecretKeyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteSecretKeyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__deleteSecretKeyResponse;
		if (size)
			*size = sizeof(ns1__deleteSecretKeyResponse);
		((ns1__deleteSecretKeyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__deleteSecretKeyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteSecretKeyResponse);
		for (int i = 0; i < n; i++)
			((ns1__deleteSecretKeyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteSecretKeyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteSecretKeyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteSecretKeyResponse %p -> %p\n", q, p));
	*(ns1__deleteSecretKeyResponse*)p = *(ns1__deleteSecretKeyResponse*)q;
}

void ns1__deleteSecretKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__deleteSecretKey::keyHandle = NULL;
	/* transient soap skipped */
}

void ns1__deleteSecretKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__deleteSecretKey::keyHandle);
	/* transient soap skipped */
}

int ns1__deleteSecretKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__deleteSecretKey);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__deleteSecretKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__deleteSecretKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__deleteSecretKey(struct soap *soap, const char *tag, int id, const ns1__deleteSecretKey *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__deleteSecretKey), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "keyHandle", -1, &(a->ns1__deleteSecretKey::keyHandle), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__deleteSecretKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__deleteSecretKey(soap, this, tag, type);
}

SOAP_FMAC3 ns1__deleteSecretKey * SOAP_FMAC4 soap_get_ns1__deleteSecretKey(struct soap *soap, ns1__deleteSecretKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__deleteSecretKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__deleteSecretKey::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__deleteSecretKey(soap, tag, this, type);
}

SOAP_FMAC3 ns1__deleteSecretKey * SOAP_FMAC4 soap_in_ns1__deleteSecretKey(struct soap *soap, const char *tag, ns1__deleteSecretKey *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__deleteSecretKey *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__deleteSecretKey, sizeof(ns1__deleteSecretKey), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__deleteSecretKey)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__deleteSecretKey *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_keyHandle1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_keyHandle1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "keyHandle", &(a->ns1__deleteSecretKey::keyHandle), "xsd:string"))
				{	soap_flag_keyHandle1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__deleteSecretKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__deleteSecretKey, 0, sizeof(ns1__deleteSecretKey), 0, soap_copy_ns1__deleteSecretKey);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__deleteSecretKey * SOAP_FMAC6 soap_new_ns1__deleteSecretKey(struct soap *soap, int n)
{	return soap_instantiate_ns1__deleteSecretKey(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__deleteSecretKey(struct soap *soap, ns1__deleteSecretKey *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__deleteSecretKey * SOAP_FMAC4 soap_instantiate_ns1__deleteSecretKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__deleteSecretKey(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__deleteSecretKey, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__deleteSecretKey;
		if (size)
			*size = sizeof(ns1__deleteSecretKey);
		((ns1__deleteSecretKey*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__deleteSecretKey[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__deleteSecretKey);
		for (int i = 0; i < n; i++)
			((ns1__deleteSecretKey*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__deleteSecretKey*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__deleteSecretKey(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__deleteSecretKey %p -> %p\n", q, p));
	*(ns1__deleteSecretKey*)p = *(ns1__deleteSecretKey*)q;
}

void ns1__unsubscribePredefinedEventResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__unsubscribePredefinedEventResponse::return_);
	/* transient soap skipped */
}

void ns1__unsubscribePredefinedEventResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__unsubscribePredefinedEventResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__unsubscribePredefinedEventResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__unsubscribePredefinedEventResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unsubscribePredefinedEventResponse(struct soap *soap, const char *tag, int id, const ns1__unsubscribePredefinedEventResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__unsubscribePredefinedEventResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__unsubscribePredefinedEventResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__unsubscribePredefinedEventResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEventResponse * SOAP_FMAC4 soap_get_ns1__unsubscribePredefinedEventResponse(struct soap *soap, ns1__unsubscribePredefinedEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unsubscribePredefinedEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__unsubscribePredefinedEventResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__unsubscribePredefinedEventResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEventResponse * SOAP_FMAC4 soap_in_ns1__unsubscribePredefinedEventResponse(struct soap *soap, const char *tag, ns1__unsubscribePredefinedEventResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__unsubscribePredefinedEventResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse, sizeof(ns1__unsubscribePredefinedEventResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__unsubscribePredefinedEventResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__unsubscribePredefinedEventResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__unsubscribePredefinedEventResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__unsubscribePredefinedEventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse, 0, sizeof(ns1__unsubscribePredefinedEventResponse), 0, soap_copy_ns1__unsubscribePredefinedEventResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__unsubscribePredefinedEventResponse * SOAP_FMAC6 soap_new_ns1__unsubscribePredefinedEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__unsubscribePredefinedEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__unsubscribePredefinedEventResponse(struct soap *soap, ns1__unsubscribePredefinedEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEventResponse * SOAP_FMAC4 soap_instantiate_ns1__unsubscribePredefinedEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unsubscribePredefinedEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__unsubscribePredefinedEventResponse;
		if (size)
			*size = sizeof(ns1__unsubscribePredefinedEventResponse);
		((ns1__unsubscribePredefinedEventResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__unsubscribePredefinedEventResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__unsubscribePredefinedEventResponse);
		for (int i = 0; i < n; i++)
			((ns1__unsubscribePredefinedEventResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__unsubscribePredefinedEventResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unsubscribePredefinedEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__unsubscribePredefinedEventResponse %p -> %p\n", q, p));
	*(ns1__unsubscribePredefinedEventResponse*)p = *(ns1__unsubscribePredefinedEventResponse*)q;
}

void ns1__unsubscribePredefinedEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns1__predefinedEventType(soap, &this->ns1__unsubscribePredefinedEvent::eventTypes);
	/* transient soap skipped */
}

void ns1__unsubscribePredefinedEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns1__predefinedEventType(soap, &this->ns1__unsubscribePredefinedEvent::eventTypes);
	/* transient soap skipped */
}

int ns1__unsubscribePredefinedEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__unsubscribePredefinedEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__unsubscribePredefinedEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__unsubscribePredefinedEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__unsubscribePredefinedEvent(struct soap *soap, const char *tag, int id, const ns1__unsubscribePredefinedEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__unsubscribePredefinedEvent), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__predefinedEventType(soap, "eventTypes", -1, &(a->ns1__unsubscribePredefinedEvent::eventTypes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__unsubscribePredefinedEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__unsubscribePredefinedEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEvent * SOAP_FMAC4 soap_get_ns1__unsubscribePredefinedEvent(struct soap *soap, ns1__unsubscribePredefinedEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__unsubscribePredefinedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__unsubscribePredefinedEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__unsubscribePredefinedEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEvent * SOAP_FMAC4 soap_in_ns1__unsubscribePredefinedEvent(struct soap *soap, const char *tag, ns1__unsubscribePredefinedEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__unsubscribePredefinedEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__unsubscribePredefinedEvent, sizeof(ns1__unsubscribePredefinedEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__unsubscribePredefinedEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__unsubscribePredefinedEvent *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__predefinedEventType(soap, "eventTypes", &(a->ns1__unsubscribePredefinedEvent::eventTypes), "ns1:predefinedEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__unsubscribePredefinedEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__unsubscribePredefinedEvent, 0, sizeof(ns1__unsubscribePredefinedEvent), 0, soap_copy_ns1__unsubscribePredefinedEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__unsubscribePredefinedEvent * SOAP_FMAC6 soap_new_ns1__unsubscribePredefinedEvent(struct soap *soap, int n)
{	return soap_instantiate_ns1__unsubscribePredefinedEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__unsubscribePredefinedEvent(struct soap *soap, ns1__unsubscribePredefinedEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEvent * SOAP_FMAC4 soap_instantiate_ns1__unsubscribePredefinedEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__unsubscribePredefinedEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__unsubscribePredefinedEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__unsubscribePredefinedEvent;
		if (size)
			*size = sizeof(ns1__unsubscribePredefinedEvent);
		((ns1__unsubscribePredefinedEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__unsubscribePredefinedEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__unsubscribePredefinedEvent);
		for (int i = 0; i < n; i++)
			((ns1__unsubscribePredefinedEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__unsubscribePredefinedEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__unsubscribePredefinedEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__unsubscribePredefinedEvent %p -> %p\n", q, p));
	*(ns1__unsubscribePredefinedEvent*)p = *(ns1__unsubscribePredefinedEvent*)q;
}

void ns1__updateCustomEventResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__updateCustomEventResponse::return_);
	/* transient soap skipped */
}

void ns1__updateCustomEventResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__updateCustomEventResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateCustomEventResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__updateCustomEventResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateCustomEventResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateCustomEventResponse(struct soap *soap, const char *tag, int id, const ns1__updateCustomEventResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateCustomEventResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__updateCustomEventResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateCustomEventResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateCustomEventResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateCustomEventResponse * SOAP_FMAC4 soap_get_ns1__updateCustomEventResponse(struct soap *soap, ns1__updateCustomEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateCustomEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__updateCustomEventResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateCustomEventResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateCustomEventResponse * SOAP_FMAC4 soap_in_ns1__updateCustomEventResponse(struct soap *soap, const char *tag, ns1__updateCustomEventResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateCustomEventResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateCustomEventResponse, sizeof(ns1__updateCustomEventResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateCustomEventResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateCustomEventResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__updateCustomEventResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateCustomEventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateCustomEventResponse, 0, sizeof(ns1__updateCustomEventResponse), 0, soap_copy_ns1__updateCustomEventResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__updateCustomEventResponse * SOAP_FMAC6 soap_new_ns1__updateCustomEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__updateCustomEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__updateCustomEventResponse(struct soap *soap, ns1__updateCustomEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__updateCustomEventResponse * SOAP_FMAC4 soap_instantiate_ns1__updateCustomEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateCustomEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateCustomEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__updateCustomEventResponse;
		if (size)
			*size = sizeof(ns1__updateCustomEventResponse);
		((ns1__updateCustomEventResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__updateCustomEventResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateCustomEventResponse);
		for (int i = 0; i < n; i++)
			((ns1__updateCustomEventResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateCustomEventResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateCustomEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateCustomEventResponse %p -> %p\n", q, p));
	*(ns1__updateCustomEventResponse*)p = *(ns1__updateCustomEventResponse*)q;
}

void ns1__updateCustomEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__updateCustomEvent::eventId);
	soap_default_int(soap, &this->ns1__updateCustomEvent::threshold);
	soap_default_int(soap, &this->ns1__updateCustomEvent::evalPeriod);
	this->ns1__updateCustomEvent::eventDescription = NULL;
	/* transient soap skipped */
}

void ns1__updateCustomEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__updateCustomEvent::eventDescription);
	/* transient soap skipped */
}

int ns1__updateCustomEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateCustomEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__updateCustomEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateCustomEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateCustomEvent(struct soap *soap, const char *tag, int id, const ns1__updateCustomEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateCustomEvent), type))
		return soap->error;
	if (soap_out_int(soap, "eventId", -1, &(a->ns1__updateCustomEvent::eventId), ""))
		return soap->error;
	if (soap_out_int(soap, "threshold", -1, &(a->ns1__updateCustomEvent::threshold), ""))
		return soap->error;
	if (soap_out_int(soap, "evalPeriod", -1, &(a->ns1__updateCustomEvent::evalPeriod), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eventDescription", -1, &(a->ns1__updateCustomEvent::eventDescription), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateCustomEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateCustomEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateCustomEvent * SOAP_FMAC4 soap_get_ns1__updateCustomEvent(struct soap *soap, ns1__updateCustomEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__updateCustomEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateCustomEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateCustomEvent * SOAP_FMAC4 soap_in_ns1__updateCustomEvent(struct soap *soap, const char *tag, ns1__updateCustomEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateCustomEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateCustomEvent, sizeof(ns1__updateCustomEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateCustomEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateCustomEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_eventId1 = 1;
	size_t soap_flag_threshold1 = 1;
	size_t soap_flag_evalPeriod1 = 1;
	size_t soap_flag_eventDescription1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eventId", &(a->ns1__updateCustomEvent::eventId), "xsd:int"))
				{	soap_flag_eventId1--;
					continue;
				}
			if (soap_flag_threshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "threshold", &(a->ns1__updateCustomEvent::threshold), "xsd:int"))
				{	soap_flag_threshold1--;
					continue;
				}
			if (soap_flag_evalPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "evalPeriod", &(a->ns1__updateCustomEvent::evalPeriod), "xsd:int"))
				{	soap_flag_evalPeriod1--;
					continue;
				}
			if (soap_flag_eventDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eventDescription", &(a->ns1__updateCustomEvent::eventDescription), "xsd:string"))
				{	soap_flag_eventDescription1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateCustomEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateCustomEvent, 0, sizeof(ns1__updateCustomEvent), 0, soap_copy_ns1__updateCustomEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventId1 > 0 || soap_flag_threshold1 > 0 || soap_flag_evalPeriod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__updateCustomEvent * SOAP_FMAC6 soap_new_ns1__updateCustomEvent(struct soap *soap, int n)
{	return soap_instantiate_ns1__updateCustomEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__updateCustomEvent(struct soap *soap, ns1__updateCustomEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__updateCustomEvent * SOAP_FMAC4 soap_instantiate_ns1__updateCustomEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateCustomEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateCustomEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__updateCustomEvent;
		if (size)
			*size = sizeof(ns1__updateCustomEvent);
		((ns1__updateCustomEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__updateCustomEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateCustomEvent);
		for (int i = 0; i < n; i++)
			((ns1__updateCustomEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateCustomEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateCustomEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateCustomEvent %p -> %p\n", q, p));
	*(ns1__updateCustomEvent*)p = *(ns1__updateCustomEvent*)q;
}

void ns1__getPolicyStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__getPolicyStateResponse::return_);
	/* transient soap skipped */
}

void ns1__getPolicyStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getPolicyStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPolicyStateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPolicyStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPolicyStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPolicyStateResponse(struct soap *soap, const char *tag, int id, const ns1__getPolicyStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPolicyStateResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__getPolicyStateResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPolicyStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPolicyStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPolicyStateResponse * SOAP_FMAC4 soap_get_ns1__getPolicyStateResponse(struct soap *soap, ns1__getPolicyStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPolicyStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPolicyStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPolicyStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPolicyStateResponse * SOAP_FMAC4 soap_in_ns1__getPolicyStateResponse(struct soap *soap, const char *tag, ns1__getPolicyStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPolicyStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPolicyStateResponse, sizeof(ns1__getPolicyStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPolicyStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPolicyStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__getPolicyStateResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPolicyStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPolicyStateResponse, 0, sizeof(ns1__getPolicyStateResponse), 0, soap_copy_ns1__getPolicyStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPolicyStateResponse * SOAP_FMAC6 soap_new_ns1__getPolicyStateResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPolicyStateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPolicyStateResponse(struct soap *soap, ns1__getPolicyStateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPolicyStateResponse * SOAP_FMAC4 soap_instantiate_ns1__getPolicyStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPolicyStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPolicyStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPolicyStateResponse;
		if (size)
			*size = sizeof(ns1__getPolicyStateResponse);
		((ns1__getPolicyStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPolicyStateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPolicyStateResponse);
		for (int i = 0; i < n; i++)
			((ns1__getPolicyStateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPolicyStateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPolicyStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPolicyStateResponse %p -> %p\n", q, p));
	*(ns1__getPolicyStateResponse*)p = *(ns1__getPolicyStateResponse*)q;
}

void ns1__getPolicyState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getPolicyState::policyId);
	/* transient soap skipped */
}

void ns1__getPolicyState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getPolicyState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPolicyState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPolicyState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPolicyState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPolicyState(struct soap *soap, const char *tag, int id, const ns1__getPolicyState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPolicyState), type))
		return soap->error;
	if (soap_out_int(soap, "policyId", -1, &(a->ns1__getPolicyState::policyId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPolicyState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPolicyState(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPolicyState * SOAP_FMAC4 soap_get_ns1__getPolicyState(struct soap *soap, ns1__getPolicyState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPolicyState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPolicyState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPolicyState(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPolicyState * SOAP_FMAC4 soap_in_ns1__getPolicyState(struct soap *soap, const char *tag, ns1__getPolicyState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPolicyState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPolicyState, sizeof(ns1__getPolicyState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPolicyState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPolicyState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_policyId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_policyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "policyId", &(a->ns1__getPolicyState::policyId), "xsd:int"))
				{	soap_flag_policyId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPolicyState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPolicyState, 0, sizeof(ns1__getPolicyState), 0, soap_copy_ns1__getPolicyState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_policyId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPolicyState * SOAP_FMAC6 soap_new_ns1__getPolicyState(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPolicyState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPolicyState(struct soap *soap, ns1__getPolicyState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPolicyState * SOAP_FMAC4 soap_instantiate_ns1__getPolicyState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPolicyState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPolicyState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPolicyState;
		if (size)
			*size = sizeof(ns1__getPolicyState);
		((ns1__getPolicyState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPolicyState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPolicyState);
		for (int i = 0; i < n; i++)
			((ns1__getPolicyState*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPolicyState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPolicyState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPolicyState %p -> %p\n", q, p));
	*(ns1__getPolicyState*)p = *(ns1__getPolicyState*)q;
}

void ns1__enumeratePoliciesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__enumeratePoliciesResponse::return_);
	/* transient soap skipped */
}

void ns1__enumeratePoliciesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__enumeratePoliciesResponse::return_);
	/* transient soap skipped */
}

int ns1__enumeratePoliciesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumeratePoliciesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumeratePoliciesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumeratePoliciesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumeratePoliciesResponse(struct soap *soap, const char *tag, int id, const ns1__enumeratePoliciesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumeratePoliciesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "return", -1, &(a->ns1__enumeratePoliciesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumeratePoliciesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumeratePoliciesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumeratePoliciesResponse * SOAP_FMAC4 soap_get_ns1__enumeratePoliciesResponse(struct soap *soap, ns1__enumeratePoliciesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumeratePoliciesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumeratePoliciesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumeratePoliciesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumeratePoliciesResponse * SOAP_FMAC4 soap_in_ns1__enumeratePoliciesResponse(struct soap *soap, const char *tag, ns1__enumeratePoliciesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumeratePoliciesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumeratePoliciesResponse, sizeof(ns1__enumeratePoliciesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumeratePoliciesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumeratePoliciesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "return", &(a->ns1__enumeratePoliciesResponse::return_), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumeratePoliciesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumeratePoliciesResponse, 0, sizeof(ns1__enumeratePoliciesResponse), 0, soap_copy_ns1__enumeratePoliciesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumeratePoliciesResponse * SOAP_FMAC6 soap_new_ns1__enumeratePoliciesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumeratePoliciesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumeratePoliciesResponse(struct soap *soap, ns1__enumeratePoliciesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumeratePoliciesResponse * SOAP_FMAC4 soap_instantiate_ns1__enumeratePoliciesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumeratePoliciesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumeratePoliciesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumeratePoliciesResponse;
		if (size)
			*size = sizeof(ns1__enumeratePoliciesResponse);
		((ns1__enumeratePoliciesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumeratePoliciesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumeratePoliciesResponse);
		for (int i = 0; i < n; i++)
			((ns1__enumeratePoliciesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumeratePoliciesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumeratePoliciesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumeratePoliciesResponse %p -> %p\n", q, p));
	*(ns1__enumeratePoliciesResponse*)p = *(ns1__enumeratePoliciesResponse*)q;
}

void ns1__enumeratePolicies::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__enumeratePolicies::entityId);
	/* transient soap skipped */
}

void ns1__enumeratePolicies::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__enumeratePolicies::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumeratePolicies);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumeratePolicies::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumeratePolicies(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumeratePolicies(struct soap *soap, const char *tag, int id, const ns1__enumeratePolicies *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumeratePolicies), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__enumeratePolicies::entityId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumeratePolicies::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumeratePolicies(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumeratePolicies * SOAP_FMAC4 soap_get_ns1__enumeratePolicies(struct soap *soap, ns1__enumeratePolicies *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumeratePolicies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumeratePolicies::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumeratePolicies(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumeratePolicies * SOAP_FMAC4 soap_in_ns1__enumeratePolicies(struct soap *soap, const char *tag, ns1__enumeratePolicies *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumeratePolicies *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumeratePolicies, sizeof(ns1__enumeratePolicies), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumeratePolicies)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumeratePolicies *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__enumeratePolicies::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumeratePolicies *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumeratePolicies, 0, sizeof(ns1__enumeratePolicies), 0, soap_copy_ns1__enumeratePolicies);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumeratePolicies * SOAP_FMAC6 soap_new_ns1__enumeratePolicies(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumeratePolicies(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumeratePolicies(struct soap *soap, ns1__enumeratePolicies *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumeratePolicies * SOAP_FMAC4 soap_instantiate_ns1__enumeratePolicies(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumeratePolicies(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumeratePolicies, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumeratePolicies;
		if (size)
			*size = sizeof(ns1__enumeratePolicies);
		((ns1__enumeratePolicies*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumeratePolicies[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumeratePolicies);
		for (int i = 0; i < n; i++)
			((ns1__enumeratePolicies*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumeratePolicies*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumeratePolicies(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumeratePolicies %p -> %p\n", q, p));
	*(ns1__enumeratePolicies*)p = *(ns1__enumeratePolicies*)q;
}

void ns1__enumerateCustomEventsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__enumerateCustomEventsResponse::return_);
	/* transient soap skipped */
}

void ns1__enumerateCustomEventsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__enumerateCustomEventsResponse::return_);
	/* transient soap skipped */
}

int ns1__enumerateCustomEventsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumerateCustomEventsResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumerateCustomEventsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumerateCustomEventsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumerateCustomEventsResponse(struct soap *soap, const char *tag, int id, const ns1__enumerateCustomEventsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumerateCustomEventsResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "return", -1, &(a->ns1__enumerateCustomEventsResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumerateCustomEventsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumerateCustomEventsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumerateCustomEventsResponse * SOAP_FMAC4 soap_get_ns1__enumerateCustomEventsResponse(struct soap *soap, ns1__enumerateCustomEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumerateCustomEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumerateCustomEventsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumerateCustomEventsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumerateCustomEventsResponse * SOAP_FMAC4 soap_in_ns1__enumerateCustomEventsResponse(struct soap *soap, const char *tag, ns1__enumerateCustomEventsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumerateCustomEventsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumerateCustomEventsResponse, sizeof(ns1__enumerateCustomEventsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumerateCustomEventsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumerateCustomEventsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "return", &(a->ns1__enumerateCustomEventsResponse::return_), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumerateCustomEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumerateCustomEventsResponse, 0, sizeof(ns1__enumerateCustomEventsResponse), 0, soap_copy_ns1__enumerateCustomEventsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumerateCustomEventsResponse * SOAP_FMAC6 soap_new_ns1__enumerateCustomEventsResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumerateCustomEventsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumerateCustomEventsResponse(struct soap *soap, ns1__enumerateCustomEventsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumerateCustomEventsResponse * SOAP_FMAC4 soap_instantiate_ns1__enumerateCustomEventsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumerateCustomEventsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumerateCustomEventsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumerateCustomEventsResponse;
		if (size)
			*size = sizeof(ns1__enumerateCustomEventsResponse);
		((ns1__enumerateCustomEventsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumerateCustomEventsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumerateCustomEventsResponse);
		for (int i = 0; i < n; i++)
			((ns1__enumerateCustomEventsResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumerateCustomEventsResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumerateCustomEventsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumerateCustomEventsResponse %p -> %p\n", q, p));
	*(ns1__enumerateCustomEventsResponse*)p = *(ns1__enumerateCustomEventsResponse*)q;
}

void ns1__enumerateCustomEvents::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__enumerateCustomEvents::entityId);
	/* transient soap skipped */
}

void ns1__enumerateCustomEvents::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__enumerateCustomEvents::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumerateCustomEvents);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumerateCustomEvents::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumerateCustomEvents(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumerateCustomEvents(struct soap *soap, const char *tag, int id, const ns1__enumerateCustomEvents *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumerateCustomEvents), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__enumerateCustomEvents::entityId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumerateCustomEvents::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumerateCustomEvents(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumerateCustomEvents * SOAP_FMAC4 soap_get_ns1__enumerateCustomEvents(struct soap *soap, ns1__enumerateCustomEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumerateCustomEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumerateCustomEvents::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumerateCustomEvents(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumerateCustomEvents * SOAP_FMAC4 soap_in_ns1__enumerateCustomEvents(struct soap *soap, const char *tag, ns1__enumerateCustomEvents *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumerateCustomEvents *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumerateCustomEvents, sizeof(ns1__enumerateCustomEvents), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumerateCustomEvents)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumerateCustomEvents *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__enumerateCustomEvents::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumerateCustomEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumerateCustomEvents, 0, sizeof(ns1__enumerateCustomEvents), 0, soap_copy_ns1__enumerateCustomEvents);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumerateCustomEvents * SOAP_FMAC6 soap_new_ns1__enumerateCustomEvents(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumerateCustomEvents(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumerateCustomEvents(struct soap *soap, ns1__enumerateCustomEvents *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumerateCustomEvents * SOAP_FMAC4 soap_instantiate_ns1__enumerateCustomEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumerateCustomEvents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumerateCustomEvents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumerateCustomEvents;
		if (size)
			*size = sizeof(ns1__enumerateCustomEvents);
		((ns1__enumerateCustomEvents*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumerateCustomEvents[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumerateCustomEvents);
		for (int i = 0; i < n; i++)
			((ns1__enumerateCustomEvents*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumerateCustomEvents*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumerateCustomEvents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumerateCustomEvents %p -> %p\n", q, p));
	*(ns1__enumerateCustomEvents*)p = *(ns1__enumerateCustomEvents*)q;
}

void ns1__getPredefinedEventTypesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns1__predefinedEventType(soap, &this->ns1__getPredefinedEventTypesResponse::return_);
	/* transient soap skipped */
}

void ns1__getPredefinedEventTypesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns1__predefinedEventType(soap, &this->ns1__getPredefinedEventTypesResponse::return_);
	/* transient soap skipped */
}

int ns1__getPredefinedEventTypesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPredefinedEventTypesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPredefinedEventTypesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPredefinedEventTypesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPredefinedEventTypesResponse(struct soap *soap, const char *tag, int id, const ns1__getPredefinedEventTypesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPredefinedEventTypesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__predefinedEventType(soap, "return", -1, &(a->ns1__getPredefinedEventTypesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPredefinedEventTypesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPredefinedEventTypesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPredefinedEventTypesResponse * SOAP_FMAC4 soap_get_ns1__getPredefinedEventTypesResponse(struct soap *soap, ns1__getPredefinedEventTypesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPredefinedEventTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPredefinedEventTypesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPredefinedEventTypesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPredefinedEventTypesResponse * SOAP_FMAC4 soap_in_ns1__getPredefinedEventTypesResponse(struct soap *soap, const char *tag, ns1__getPredefinedEventTypesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPredefinedEventTypesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPredefinedEventTypesResponse, sizeof(ns1__getPredefinedEventTypesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPredefinedEventTypesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPredefinedEventTypesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__predefinedEventType(soap, "return", &(a->ns1__getPredefinedEventTypesResponse::return_), "ns1:predefinedEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPredefinedEventTypesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPredefinedEventTypesResponse, 0, sizeof(ns1__getPredefinedEventTypesResponse), 0, soap_copy_ns1__getPredefinedEventTypesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPredefinedEventTypesResponse * SOAP_FMAC6 soap_new_ns1__getPredefinedEventTypesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPredefinedEventTypesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPredefinedEventTypesResponse(struct soap *soap, ns1__getPredefinedEventTypesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPredefinedEventTypesResponse * SOAP_FMAC4 soap_instantiate_ns1__getPredefinedEventTypesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPredefinedEventTypesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPredefinedEventTypesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPredefinedEventTypesResponse;
		if (size)
			*size = sizeof(ns1__getPredefinedEventTypesResponse);
		((ns1__getPredefinedEventTypesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPredefinedEventTypesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPredefinedEventTypesResponse);
		for (int i = 0; i < n; i++)
			((ns1__getPredefinedEventTypesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPredefinedEventTypesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPredefinedEventTypesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPredefinedEventTypesResponse %p -> %p\n", q, p));
	*(ns1__getPredefinedEventTypesResponse*)p = *(ns1__getPredefinedEventTypesResponse*)q;
}

void ns1__getPredefinedEventTypes::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__getPredefinedEventTypes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getPredefinedEventTypes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getPredefinedEventTypes);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getPredefinedEventTypes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getPredefinedEventTypes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getPredefinedEventTypes(struct soap *soap, const char *tag, int id, const ns1__getPredefinedEventTypes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getPredefinedEventTypes), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getPredefinedEventTypes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getPredefinedEventTypes(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getPredefinedEventTypes * SOAP_FMAC4 soap_get_ns1__getPredefinedEventTypes(struct soap *soap, ns1__getPredefinedEventTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getPredefinedEventTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getPredefinedEventTypes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getPredefinedEventTypes(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getPredefinedEventTypes * SOAP_FMAC4 soap_in_ns1__getPredefinedEventTypes(struct soap *soap, const char *tag, ns1__getPredefinedEventTypes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getPredefinedEventTypes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getPredefinedEventTypes, sizeof(ns1__getPredefinedEventTypes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getPredefinedEventTypes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getPredefinedEventTypes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getPredefinedEventTypes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getPredefinedEventTypes, 0, sizeof(ns1__getPredefinedEventTypes), 0, soap_copy_ns1__getPredefinedEventTypes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getPredefinedEventTypes * SOAP_FMAC6 soap_new_ns1__getPredefinedEventTypes(struct soap *soap, int n)
{	return soap_instantiate_ns1__getPredefinedEventTypes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getPredefinedEventTypes(struct soap *soap, ns1__getPredefinedEventTypes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getPredefinedEventTypes * SOAP_FMAC4 soap_instantiate_ns1__getPredefinedEventTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getPredefinedEventTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getPredefinedEventTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getPredefinedEventTypes;
		if (size)
			*size = sizeof(ns1__getPredefinedEventTypes);
		((ns1__getPredefinedEventTypes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getPredefinedEventTypes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getPredefinedEventTypes);
		for (int i = 0; i < n; i++)
			((ns1__getPredefinedEventTypes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getPredefinedEventTypes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getPredefinedEventTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getPredefinedEventTypes %p -> %p\n", q, p));
	*(ns1__getPredefinedEventTypes*)p = *(ns1__getPredefinedEventTypes*)q;
}

void ns1__customEventData::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__customEventData::conditionOperator = NULL;
	soap_default_int(soap, &this->ns1__customEventData::entityId);
	soap_default_int(soap, &this->ns1__customEventData::evalPeriod);
	this->ns1__customEventData::eventDescription = NULL;
	this->ns1__customEventData::eventType = NULL;
	soap_default_int(soap, &this->ns1__customEventData::threshold);
	/* transient soap skipped */
}

void ns1__customEventData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__conditionOperator(soap, &this->ns1__customEventData::conditionOperator);
	soap_serialize_PointerTostd__string(soap, &this->ns1__customEventData::eventDescription);
	soap_serialize_PointerTons1__customEventType(soap, &this->ns1__customEventData::eventType);
	/* transient soap skipped */
}

int ns1__customEventData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__customEventData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__customEventData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__customEventData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__customEventData(struct soap *soap, const char *tag, int id, const ns1__customEventData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__customEventData), type))
		return soap->error;
	if (soap_out_PointerTons1__conditionOperator(soap, "conditionOperator", -1, &(a->ns1__customEventData::conditionOperator), ""))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__customEventData::entityId), ""))
		return soap->error;
	if (soap_out_int(soap, "evalPeriod", -1, &(a->ns1__customEventData::evalPeriod), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "eventDescription", -1, &(a->ns1__customEventData::eventDescription), ""))
		return soap->error;
	if (soap_out_PointerTons1__customEventType(soap, "eventType", -1, &(a->ns1__customEventData::eventType), ""))
		return soap->error;
	if (soap_out_int(soap, "threshold", -1, &(a->ns1__customEventData::threshold), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__customEventData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__customEventData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__customEventData * SOAP_FMAC4 soap_get_ns1__customEventData(struct soap *soap, ns1__customEventData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__customEventData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__customEventData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__customEventData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__customEventData * SOAP_FMAC4 soap_in_ns1__customEventData(struct soap *soap, const char *tag, ns1__customEventData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__customEventData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__customEventData, sizeof(ns1__customEventData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__customEventData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__customEventData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_conditionOperator1 = 1;
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_evalPeriod1 = 1;
	size_t soap_flag_eventDescription1 = 1;
	size_t soap_flag_eventType1 = 1;
	size_t soap_flag_threshold1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_conditionOperator1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__conditionOperator(soap, "conditionOperator", &(a->ns1__customEventData::conditionOperator), "ns1:conditionOperator"))
				{	soap_flag_conditionOperator1--;
					continue;
				}
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__customEventData::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_evalPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "evalPeriod", &(a->ns1__customEventData::evalPeriod), "xsd:int"))
				{	soap_flag_evalPeriod1--;
					continue;
				}
			if (soap_flag_eventDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "eventDescription", &(a->ns1__customEventData::eventDescription), "xsd:string"))
				{	soap_flag_eventDescription1--;
					continue;
				}
			if (soap_flag_eventType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__customEventType(soap, "eventType", &(a->ns1__customEventData::eventType), "ns1:customEventType"))
				{	soap_flag_eventType1--;
					continue;
				}
			if (soap_flag_threshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "threshold", &(a->ns1__customEventData::threshold), "xsd:int"))
				{	soap_flag_threshold1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__customEventData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__customEventData, 0, sizeof(ns1__customEventData), 0, soap_copy_ns1__customEventData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_evalPeriod1 > 0 || soap_flag_threshold1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__customEventData * SOAP_FMAC6 soap_new_ns1__customEventData(struct soap *soap, int n)
{	return soap_instantiate_ns1__customEventData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__customEventData(struct soap *soap, ns1__customEventData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__customEventData * SOAP_FMAC4 soap_instantiate_ns1__customEventData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__customEventData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__customEventData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__customEventData;
		if (size)
			*size = sizeof(ns1__customEventData);
		((ns1__customEventData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__customEventData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__customEventData);
		for (int i = 0; i < n; i++)
			((ns1__customEventData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__customEventData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__customEventData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__customEventData %p -> %p\n", q, p));
	*(ns1__customEventData*)p = *(ns1__customEventData*)q;
}

void ns1__getCustomEventDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getCustomEventDataResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getCustomEventDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__customEventData(soap, &this->ns1__getCustomEventDataResponse::return_);
	/* transient soap skipped */
}

int ns1__getCustomEventDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getCustomEventDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getCustomEventDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCustomEventDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomEventDataResponse(struct soap *soap, const char *tag, int id, const ns1__getCustomEventDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomEventDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__customEventData(soap, "return", -1, &(a->ns1__getCustomEventDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCustomEventDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCustomEventDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCustomEventDataResponse * SOAP_FMAC4 soap_get_ns1__getCustomEventDataResponse(struct soap *soap, ns1__getCustomEventDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomEventDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getCustomEventDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCustomEventDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCustomEventDataResponse * SOAP_FMAC4 soap_in_ns1__getCustomEventDataResponse(struct soap *soap, const char *tag, ns1__getCustomEventDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCustomEventDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomEventDataResponse, sizeof(ns1__getCustomEventDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCustomEventDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCustomEventDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__customEventData(soap, "return", &(a->ns1__getCustomEventDataResponse::return_), "ns1:customEventData"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCustomEventDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomEventDataResponse, 0, sizeof(ns1__getCustomEventDataResponse), 0, soap_copy_ns1__getCustomEventDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getCustomEventDataResponse * SOAP_FMAC6 soap_new_ns1__getCustomEventDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getCustomEventDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getCustomEventDataResponse(struct soap *soap, ns1__getCustomEventDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getCustomEventDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getCustomEventDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomEventDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomEventDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getCustomEventDataResponse;
		if (size)
			*size = sizeof(ns1__getCustomEventDataResponse);
		((ns1__getCustomEventDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getCustomEventDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getCustomEventDataResponse);
		for (int i = 0; i < n; i++)
			((ns1__getCustomEventDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getCustomEventDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomEventDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCustomEventDataResponse %p -> %p\n", q, p));
	*(ns1__getCustomEventDataResponse*)p = *(ns1__getCustomEventDataResponse*)q;
}

void ns1__getCustomEventData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getCustomEventData::eventId);
	/* transient soap skipped */
}

void ns1__getCustomEventData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getCustomEventData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getCustomEventData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getCustomEventData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getCustomEventData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getCustomEventData(struct soap *soap, const char *tag, int id, const ns1__getCustomEventData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getCustomEventData), type))
		return soap->error;
	if (soap_out_int(soap, "eventId", -1, &(a->ns1__getCustomEventData::eventId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getCustomEventData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getCustomEventData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getCustomEventData * SOAP_FMAC4 soap_get_ns1__getCustomEventData(struct soap *soap, ns1__getCustomEventData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getCustomEventData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getCustomEventData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getCustomEventData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getCustomEventData * SOAP_FMAC4 soap_in_ns1__getCustomEventData(struct soap *soap, const char *tag, ns1__getCustomEventData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getCustomEventData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getCustomEventData, sizeof(ns1__getCustomEventData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getCustomEventData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getCustomEventData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_eventId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eventId", &(a->ns1__getCustomEventData::eventId), "xsd:int"))
				{	soap_flag_eventId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getCustomEventData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getCustomEventData, 0, sizeof(ns1__getCustomEventData), 0, soap_copy_ns1__getCustomEventData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getCustomEventData * SOAP_FMAC6 soap_new_ns1__getCustomEventData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getCustomEventData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getCustomEventData(struct soap *soap, ns1__getCustomEventData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getCustomEventData * SOAP_FMAC4 soap_instantiate_ns1__getCustomEventData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getCustomEventData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getCustomEventData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getCustomEventData;
		if (size)
			*size = sizeof(ns1__getCustomEventData);
		((ns1__getCustomEventData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getCustomEventData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getCustomEventData);
		for (int i = 0; i < n; i++)
			((ns1__getCustomEventData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getCustomEventData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getCustomEventData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getCustomEventData %p -> %p\n", q, p));
	*(ns1__getCustomEventData*)p = *(ns1__getCustomEventData*)q;
}

void ns1__getEventHandlerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getEventHandlerResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getEventHandlerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getEventHandlerResponse::return_);
	/* transient soap skipped */
}

int ns1__getEventHandlerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getEventHandlerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getEventHandlerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getEventHandlerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEventHandlerResponse(struct soap *soap, const char *tag, int id, const ns1__getEventHandlerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEventHandlerResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getEventHandlerResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getEventHandlerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getEventHandlerResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEventHandlerResponse * SOAP_FMAC4 soap_get_ns1__getEventHandlerResponse(struct soap *soap, ns1__getEventHandlerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEventHandlerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getEventHandlerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getEventHandlerResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEventHandlerResponse * SOAP_FMAC4 soap_in_ns1__getEventHandlerResponse(struct soap *soap, const char *tag, ns1__getEventHandlerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getEventHandlerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEventHandlerResponse, sizeof(ns1__getEventHandlerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getEventHandlerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getEventHandlerResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getEventHandlerResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getEventHandlerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEventHandlerResponse, 0, sizeof(ns1__getEventHandlerResponse), 0, soap_copy_ns1__getEventHandlerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getEventHandlerResponse * SOAP_FMAC6 soap_new_ns1__getEventHandlerResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getEventHandlerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getEventHandlerResponse(struct soap *soap, ns1__getEventHandlerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getEventHandlerResponse * SOAP_FMAC4 soap_instantiate_ns1__getEventHandlerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEventHandlerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEventHandlerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getEventHandlerResponse;
		if (size)
			*size = sizeof(ns1__getEventHandlerResponse);
		((ns1__getEventHandlerResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getEventHandlerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getEventHandlerResponse);
		for (int i = 0; i < n; i++)
			((ns1__getEventHandlerResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getEventHandlerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEventHandlerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEventHandlerResponse %p -> %p\n", q, p));
	*(ns1__getEventHandlerResponse*)p = *(ns1__getEventHandlerResponse*)q;
}

void ns1__getEventHandler::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getEventHandler::handlerId);
	/* transient soap skipped */
}

void ns1__getEventHandler::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getEventHandler::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getEventHandler);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getEventHandler::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getEventHandler(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getEventHandler(struct soap *soap, const char *tag, int id, const ns1__getEventHandler *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getEventHandler), type))
		return soap->error;
	if (soap_out_int(soap, "handlerId", -1, &(a->ns1__getEventHandler::handlerId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getEventHandler::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getEventHandler(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getEventHandler * SOAP_FMAC4 soap_get_ns1__getEventHandler(struct soap *soap, ns1__getEventHandler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getEventHandler::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getEventHandler(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getEventHandler * SOAP_FMAC4 soap_in_ns1__getEventHandler(struct soap *soap, const char *tag, ns1__getEventHandler *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getEventHandler *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getEventHandler, sizeof(ns1__getEventHandler), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getEventHandler)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getEventHandler *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_handlerId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_handlerId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "handlerId", &(a->ns1__getEventHandler::handlerId), "xsd:int"))
				{	soap_flag_handlerId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getEventHandler *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getEventHandler, 0, sizeof(ns1__getEventHandler), 0, soap_copy_ns1__getEventHandler);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_handlerId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getEventHandler * SOAP_FMAC6 soap_new_ns1__getEventHandler(struct soap *soap, int n)
{	return soap_instantiate_ns1__getEventHandler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getEventHandler(struct soap *soap, ns1__getEventHandler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getEventHandler * SOAP_FMAC4 soap_instantiate_ns1__getEventHandler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getEventHandler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getEventHandler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getEventHandler;
		if (size)
			*size = sizeof(ns1__getEventHandler);
		((ns1__getEventHandler*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getEventHandler[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getEventHandler);
		for (int i = 0; i < n; i++)
			((ns1__getEventHandler*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getEventHandler*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getEventHandler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getEventHandler %p -> %p\n", q, p));
	*(ns1__getEventHandler*)p = *(ns1__getEventHandler*)q;
}

void ns1__addEntityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__addEntityResponse::return_);
	/* transient soap skipped */
}

void ns1__addEntityResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__addEntityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addEntityResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__addEntityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addEntityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addEntityResponse(struct soap *soap, const char *tag, int id, const ns1__addEntityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addEntityResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &(a->ns1__addEntityResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__addEntityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addEntityResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addEntityResponse * SOAP_FMAC4 soap_get_ns1__addEntityResponse(struct soap *soap, ns1__addEntityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__addEntityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addEntityResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addEntityResponse * SOAP_FMAC4 soap_in_ns1__addEntityResponse(struct soap *soap, const char *tag, ns1__addEntityResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addEntityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addEntityResponse, sizeof(ns1__addEntityResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addEntityResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addEntityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &(a->ns1__addEntityResponse::return_), "xsd:int"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addEntityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addEntityResponse, 0, sizeof(ns1__addEntityResponse), 0, soap_copy_ns1__addEntityResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__addEntityResponse * SOAP_FMAC6 soap_new_ns1__addEntityResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__addEntityResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__addEntityResponse(struct soap *soap, ns1__addEntityResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__addEntityResponse * SOAP_FMAC4 soap_instantiate_ns1__addEntityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addEntityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addEntityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__addEntityResponse;
		if (size)
			*size = sizeof(ns1__addEntityResponse);
		((ns1__addEntityResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__addEntityResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addEntityResponse);
		for (int i = 0; i < n; i++)
			((ns1__addEntityResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addEntityResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addEntityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addEntityResponse %p -> %p\n", q, p));
	*(ns1__addEntityResponse*)p = *(ns1__addEntityResponse*)q;
}

void ns1__addEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__addEntity::entityType = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__property(soap, &this->ns1__addEntity::properties);
	soap_default_bool(soap, &this->ns1__addEntity::forceAddition);
	/* transient soap skipped */
}

void ns1__addEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__entityType(soap, &this->ns1__addEntity::entityType);
	soap_serialize_std__vectorTemplateOfPointerTons1__property(soap, &this->ns1__addEntity::properties);
	/* transient soap skipped */
}

int ns1__addEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__addEntity);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__addEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__addEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addEntity(struct soap *soap, const char *tag, int id, const ns1__addEntity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addEntity), type))
		return soap->error;
	if (soap_out_PointerTons1__entityType(soap, "entityType", -1, &(a->ns1__addEntity::entityType), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__property(soap, "properties", -1, &(a->ns1__addEntity::properties), ""))
		return soap->error;
	if (soap_out_bool(soap, "forceAddition", -1, &(a->ns1__addEntity::forceAddition), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__addEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__addEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns1__addEntity * SOAP_FMAC4 soap_get_ns1__addEntity(struct soap *soap, ns1__addEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__addEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__addEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns1__addEntity * SOAP_FMAC4 soap_in_ns1__addEntity(struct soap *soap, const char *tag, ns1__addEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__addEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addEntity, sizeof(ns1__addEntity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__addEntity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__addEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityType1 = 1;
	size_t soap_flag_forceAddition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__entityType(soap, "entityType", &(a->ns1__addEntity::entityType), "ns1:entityType"))
				{	soap_flag_entityType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__property(soap, "properties", &(a->ns1__addEntity::properties), "ns1:property"))
					continue;
			if (soap_flag_forceAddition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "forceAddition", &(a->ns1__addEntity::forceAddition), "xsd:boolean"))
				{	soap_flag_forceAddition1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__addEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addEntity, 0, sizeof(ns1__addEntity), 0, soap_copy_ns1__addEntity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_forceAddition1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__addEntity * SOAP_FMAC6 soap_new_ns1__addEntity(struct soap *soap, int n)
{	return soap_instantiate_ns1__addEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__addEntity(struct soap *soap, ns1__addEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__addEntity * SOAP_FMAC4 soap_instantiate_ns1__addEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__addEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__addEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__addEntity;
		if (size)
			*size = sizeof(ns1__addEntity);
		((ns1__addEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__addEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__addEntity);
		for (int i = 0; i < n; i++)
			((ns1__addEntity*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__addEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__addEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__addEntity %p -> %p\n", q, p));
	*(ns1__addEntity*)p = *(ns1__addEntity*)q;
}

void ns1__getMetricDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getMetricDataResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getMetricDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumerationData(soap, &this->ns1__getMetricDataResponse::return_);
	/* transient soap skipped */
}

int ns1__getMetricDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMetricDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getMetricDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMetricDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetricDataResponse(struct soap *soap, const char *tag, int id, const ns1__getMetricDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetricDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__enumerationData(soap, "return", -1, &(a->ns1__getMetricDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getMetricDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMetricDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMetricDataResponse * SOAP_FMAC4 soap_get_ns1__getMetricDataResponse(struct soap *soap, ns1__getMetricDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetricDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getMetricDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMetricDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMetricDataResponse * SOAP_FMAC4 soap_in_ns1__getMetricDataResponse(struct soap *soap, const char *tag, ns1__getMetricDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMetricDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetricDataResponse, sizeof(ns1__getMetricDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMetricDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMetricDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumerationData(soap, "return", &(a->ns1__getMetricDataResponse::return_), "ns1:enumerationData"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMetricDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetricDataResponse, 0, sizeof(ns1__getMetricDataResponse), 0, soap_copy_ns1__getMetricDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getMetricDataResponse * SOAP_FMAC6 soap_new_ns1__getMetricDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getMetricDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getMetricDataResponse(struct soap *soap, ns1__getMetricDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getMetricDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getMetricDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMetricDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMetricDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getMetricDataResponse;
		if (size)
			*size = sizeof(ns1__getMetricDataResponse);
		((ns1__getMetricDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getMetricDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMetricDataResponse);
		for (int i = 0; i < n; i++)
			((ns1__getMetricDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMetricDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMetricDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMetricDataResponse %p -> %p\n", q, p));
	*(ns1__getMetricDataResponse*)p = *(ns1__getMetricDataResponse*)q;
}

void ns1__getMetricData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getMetricData::entityId);
	this->ns1__getMetricData::metricType = NULL;
	this->ns1__getMetricData::aggregationLevel = NULL;
	this->ns1__getMetricData::startTime = NULL;
	this->ns1__getMetricData::endTime = NULL;
	soap_default_int(soap, &this->ns1__getMetricData::aggPeriod);
	/* transient soap skipped */
}

void ns1__getMetricData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__metricType(soap, &this->ns1__getMetricData::metricType);
	soap_serialize_PointerTons1__aggregationLevel(soap, &this->ns1__getMetricData::aggregationLevel);
	soap_serialize_PointerTotime(soap, &this->ns1__getMetricData::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__getMetricData::endTime);
	/* transient soap skipped */
}

int ns1__getMetricData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getMetricData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getMetricData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getMetricData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getMetricData(struct soap *soap, const char *tag, int id, const ns1__getMetricData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getMetricData), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__getMetricData::entityId), ""))
		return soap->error;
	if (soap_out_PointerTons1__metricType(soap, "metricType", -1, &(a->ns1__getMetricData::metricType), ""))
		return soap->error;
	if (soap_out_PointerTons1__aggregationLevel(soap, "aggregationLevel", -1, &(a->ns1__getMetricData::aggregationLevel), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__getMetricData::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__getMetricData::endTime), ""))
		return soap->error;
	if (soap_out_int(soap, "aggPeriod", -1, &(a->ns1__getMetricData::aggPeriod), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getMetricData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getMetricData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getMetricData * SOAP_FMAC4 soap_get_ns1__getMetricData(struct soap *soap, ns1__getMetricData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getMetricData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getMetricData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getMetricData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getMetricData * SOAP_FMAC4 soap_in_ns1__getMetricData(struct soap *soap, const char *tag, ns1__getMetricData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getMetricData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getMetricData, sizeof(ns1__getMetricData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getMetricData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getMetricData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_metricType1 = 1;
	size_t soap_flag_aggregationLevel1 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_endTime1 = 1;
	size_t soap_flag_aggPeriod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__getMetricData::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_metricType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__metricType(soap, "metricType", &(a->ns1__getMetricData::metricType), "ns1:metricType"))
				{	soap_flag_metricType1--;
					continue;
				}
			if (soap_flag_aggregationLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__aggregationLevel(soap, "aggregationLevel", &(a->ns1__getMetricData::aggregationLevel), "ns1:aggregationLevel"))
				{	soap_flag_aggregationLevel1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__getMetricData::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__getMetricData::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_aggPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "aggPeriod", &(a->ns1__getMetricData::aggPeriod), "xsd:int"))
				{	soap_flag_aggPeriod1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getMetricData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getMetricData, 0, sizeof(ns1__getMetricData), 0, soap_copy_ns1__getMetricData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_aggPeriod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getMetricData * SOAP_FMAC6 soap_new_ns1__getMetricData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getMetricData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getMetricData(struct soap *soap, ns1__getMetricData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getMetricData * SOAP_FMAC4 soap_instantiate_ns1__getMetricData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getMetricData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getMetricData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getMetricData;
		if (size)
			*size = sizeof(ns1__getMetricData);
		((ns1__getMetricData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getMetricData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getMetricData);
		for (int i = 0; i < n; i++)
			((ns1__getMetricData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getMetricData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getMetricData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getMetricData %p -> %p\n", q, p));
	*(ns1__getMetricData*)p = *(ns1__getMetricData*)q;
}

void ns1__disassociateEntityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__disassociateEntityResponse::return_);
	/* transient soap skipped */
}

void ns1__disassociateEntityResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__disassociateEntityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__disassociateEntityResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__disassociateEntityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__disassociateEntityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__disassociateEntityResponse(struct soap *soap, const char *tag, int id, const ns1__disassociateEntityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__disassociateEntityResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__disassociateEntityResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__disassociateEntityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__disassociateEntityResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__disassociateEntityResponse * SOAP_FMAC4 soap_get_ns1__disassociateEntityResponse(struct soap *soap, ns1__disassociateEntityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__disassociateEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__disassociateEntityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__disassociateEntityResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__disassociateEntityResponse * SOAP_FMAC4 soap_in_ns1__disassociateEntityResponse(struct soap *soap, const char *tag, ns1__disassociateEntityResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__disassociateEntityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__disassociateEntityResponse, sizeof(ns1__disassociateEntityResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__disassociateEntityResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__disassociateEntityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__disassociateEntityResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__disassociateEntityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__disassociateEntityResponse, 0, sizeof(ns1__disassociateEntityResponse), 0, soap_copy_ns1__disassociateEntityResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__disassociateEntityResponse * SOAP_FMAC6 soap_new_ns1__disassociateEntityResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__disassociateEntityResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__disassociateEntityResponse(struct soap *soap, ns1__disassociateEntityResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__disassociateEntityResponse * SOAP_FMAC4 soap_instantiate_ns1__disassociateEntityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__disassociateEntityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__disassociateEntityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__disassociateEntityResponse;
		if (size)
			*size = sizeof(ns1__disassociateEntityResponse);
		((ns1__disassociateEntityResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__disassociateEntityResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__disassociateEntityResponse);
		for (int i = 0; i < n; i++)
			((ns1__disassociateEntityResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__disassociateEntityResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__disassociateEntityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__disassociateEntityResponse %p -> %p\n", q, p));
	*(ns1__disassociateEntityResponse*)p = *(ns1__disassociateEntityResponse*)q;
}

void ns1__disassociateEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__disassociateEntity::groupId);
	soap_default_int(soap, &this->ns1__disassociateEntity::entityId);
	/* transient soap skipped */
}

void ns1__disassociateEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__disassociateEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__disassociateEntity);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__disassociateEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__disassociateEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__disassociateEntity(struct soap *soap, const char *tag, int id, const ns1__disassociateEntity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__disassociateEntity), type))
		return soap->error;
	if (soap_out_int(soap, "groupId", -1, &(a->ns1__disassociateEntity::groupId), ""))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__disassociateEntity::entityId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__disassociateEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__disassociateEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns1__disassociateEntity * SOAP_FMAC4 soap_get_ns1__disassociateEntity(struct soap *soap, ns1__disassociateEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__disassociateEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__disassociateEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__disassociateEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns1__disassociateEntity * SOAP_FMAC4 soap_in_ns1__disassociateEntity(struct soap *soap, const char *tag, ns1__disassociateEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__disassociateEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__disassociateEntity, sizeof(ns1__disassociateEntity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__disassociateEntity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__disassociateEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_groupId1 = 1;
	size_t soap_flag_entityId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_groupId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "groupId", &(a->ns1__disassociateEntity::groupId), "xsd:int"))
				{	soap_flag_groupId1--;
					continue;
				}
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__disassociateEntity::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__disassociateEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__disassociateEntity, 0, sizeof(ns1__disassociateEntity), 0, soap_copy_ns1__disassociateEntity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_groupId1 > 0 || soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__disassociateEntity * SOAP_FMAC6 soap_new_ns1__disassociateEntity(struct soap *soap, int n)
{	return soap_instantiate_ns1__disassociateEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__disassociateEntity(struct soap *soap, ns1__disassociateEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__disassociateEntity * SOAP_FMAC4 soap_instantiate_ns1__disassociateEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__disassociateEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__disassociateEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__disassociateEntity;
		if (size)
			*size = sizeof(ns1__disassociateEntity);
		((ns1__disassociateEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__disassociateEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__disassociateEntity);
		for (int i = 0; i < n; i++)
			((ns1__disassociateEntity*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__disassociateEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__disassociateEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__disassociateEntity %p -> %p\n", q, p));
	*(ns1__disassociateEntity*)p = *(ns1__disassociateEntity*)q;
}

void ns1__removeCustomEventResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__removeCustomEventResponse::return_);
	/* transient soap skipped */
}

void ns1__removeCustomEventResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeCustomEventResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeCustomEventResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__removeCustomEventResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeCustomEventResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeCustomEventResponse(struct soap *soap, const char *tag, int id, const ns1__removeCustomEventResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeCustomEventResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__removeCustomEventResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__removeCustomEventResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeCustomEventResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeCustomEventResponse * SOAP_FMAC4 soap_get_ns1__removeCustomEventResponse(struct soap *soap, ns1__removeCustomEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeCustomEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__removeCustomEventResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeCustomEventResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeCustomEventResponse * SOAP_FMAC4 soap_in_ns1__removeCustomEventResponse(struct soap *soap, const char *tag, ns1__removeCustomEventResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeCustomEventResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeCustomEventResponse, sizeof(ns1__removeCustomEventResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeCustomEventResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeCustomEventResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__removeCustomEventResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeCustomEventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeCustomEventResponse, 0, sizeof(ns1__removeCustomEventResponse), 0, soap_copy_ns1__removeCustomEventResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__removeCustomEventResponse * SOAP_FMAC6 soap_new_ns1__removeCustomEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__removeCustomEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__removeCustomEventResponse(struct soap *soap, ns1__removeCustomEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__removeCustomEventResponse * SOAP_FMAC4 soap_instantiate_ns1__removeCustomEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeCustomEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeCustomEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__removeCustomEventResponse;
		if (size)
			*size = sizeof(ns1__removeCustomEventResponse);
		((ns1__removeCustomEventResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__removeCustomEventResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeCustomEventResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeCustomEventResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeCustomEventResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeCustomEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeCustomEventResponse %p -> %p\n", q, p));
	*(ns1__removeCustomEventResponse*)p = *(ns1__removeCustomEventResponse*)q;
}

void ns1__removeCustomEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__removeCustomEvent::eventId);
	/* transient soap skipped */
}

void ns1__removeCustomEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeCustomEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeCustomEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__removeCustomEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeCustomEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeCustomEvent(struct soap *soap, const char *tag, int id, const ns1__removeCustomEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeCustomEvent), type))
		return soap->error;
	if (soap_out_int(soap, "eventId", -1, &(a->ns1__removeCustomEvent::eventId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__removeCustomEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeCustomEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeCustomEvent * SOAP_FMAC4 soap_get_ns1__removeCustomEvent(struct soap *soap, ns1__removeCustomEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__removeCustomEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeCustomEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeCustomEvent * SOAP_FMAC4 soap_in_ns1__removeCustomEvent(struct soap *soap, const char *tag, ns1__removeCustomEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeCustomEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeCustomEvent, sizeof(ns1__removeCustomEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeCustomEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeCustomEvent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_eventId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eventId", &(a->ns1__removeCustomEvent::eventId), "xsd:int"))
				{	soap_flag_eventId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeCustomEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeCustomEvent, 0, sizeof(ns1__removeCustomEvent), 0, soap_copy_ns1__removeCustomEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__removeCustomEvent * SOAP_FMAC6 soap_new_ns1__removeCustomEvent(struct soap *soap, int n)
{	return soap_instantiate_ns1__removeCustomEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__removeCustomEvent(struct soap *soap, ns1__removeCustomEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__removeCustomEvent * SOAP_FMAC4 soap_instantiate_ns1__removeCustomEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeCustomEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeCustomEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__removeCustomEvent;
		if (size)
			*size = sizeof(ns1__removeCustomEvent);
		((ns1__removeCustomEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__removeCustomEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeCustomEvent);
		for (int i = 0; i < n; i++)
			((ns1__removeCustomEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeCustomEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeCustomEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeCustomEvent %p -> %p\n", q, p));
	*(ns1__removeCustomEvent*)p = *(ns1__removeCustomEvent*)q;
}

void ns1__submitSecretKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__submitSecretKeyResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__submitSecretKeyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__submitSecretKeyResponse::return_);
	/* transient soap skipped */
}

int ns1__submitSecretKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__submitSecretKeyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__submitSecretKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__submitSecretKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__submitSecretKeyResponse(struct soap *soap, const char *tag, int id, const ns1__submitSecretKeyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__submitSecretKeyResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__submitSecretKeyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__submitSecretKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__submitSecretKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__submitSecretKeyResponse * SOAP_FMAC4 soap_get_ns1__submitSecretKeyResponse(struct soap *soap, ns1__submitSecretKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__submitSecretKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__submitSecretKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__submitSecretKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__submitSecretKeyResponse * SOAP_FMAC4 soap_in_ns1__submitSecretKeyResponse(struct soap *soap, const char *tag, ns1__submitSecretKeyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__submitSecretKeyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__submitSecretKeyResponse, sizeof(ns1__submitSecretKeyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__submitSecretKeyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__submitSecretKeyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__submitSecretKeyResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__submitSecretKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__submitSecretKeyResponse, 0, sizeof(ns1__submitSecretKeyResponse), 0, soap_copy_ns1__submitSecretKeyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__submitSecretKeyResponse * SOAP_FMAC6 soap_new_ns1__submitSecretKeyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__submitSecretKeyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__submitSecretKeyResponse(struct soap *soap, ns1__submitSecretKeyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__submitSecretKeyResponse * SOAP_FMAC4 soap_instantiate_ns1__submitSecretKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__submitSecretKeyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__submitSecretKeyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__submitSecretKeyResponse;
		if (size)
			*size = sizeof(ns1__submitSecretKeyResponse);
		((ns1__submitSecretKeyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__submitSecretKeyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__submitSecretKeyResponse);
		for (int i = 0; i < n; i++)
			((ns1__submitSecretKeyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__submitSecretKeyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__submitSecretKeyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__submitSecretKeyResponse %p -> %p\n", q, p));
	*(ns1__submitSecretKeyResponse*)p = *(ns1__submitSecretKeyResponse*)q;
}

void ns1__submitSecretKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__submitSecretKey::base64key = NULL;
	this->ns1__submitSecretKey::algorithm = NULL;
	/* transient soap skipped */
}

void ns1__submitSecretKey::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__submitSecretKey::base64key);
	soap_serialize_PointerTostd__string(soap, &this->ns1__submitSecretKey::algorithm);
	/* transient soap skipped */
}

int ns1__submitSecretKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__submitSecretKey);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__submitSecretKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__submitSecretKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__submitSecretKey(struct soap *soap, const char *tag, int id, const ns1__submitSecretKey *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__submitSecretKey), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "base64key", -1, &(a->ns1__submitSecretKey::base64key), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "algorithm", -1, &(a->ns1__submitSecretKey::algorithm), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__submitSecretKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__submitSecretKey(soap, this, tag, type);
}

SOAP_FMAC3 ns1__submitSecretKey * SOAP_FMAC4 soap_get_ns1__submitSecretKey(struct soap *soap, ns1__submitSecretKey *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__submitSecretKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__submitSecretKey::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__submitSecretKey(soap, tag, this, type);
}

SOAP_FMAC3 ns1__submitSecretKey * SOAP_FMAC4 soap_in_ns1__submitSecretKey(struct soap *soap, const char *tag, ns1__submitSecretKey *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__submitSecretKey *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__submitSecretKey, sizeof(ns1__submitSecretKey), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__submitSecretKey)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__submitSecretKey *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_base64key1 = 1;
	size_t soap_flag_algorithm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_base64key1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "base64key", &(a->ns1__submitSecretKey::base64key), "xsd:string"))
				{	soap_flag_base64key1--;
					continue;
				}
			if (soap_flag_algorithm1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "algorithm", &(a->ns1__submitSecretKey::algorithm), "xsd:string"))
				{	soap_flag_algorithm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__submitSecretKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__submitSecretKey, 0, sizeof(ns1__submitSecretKey), 0, soap_copy_ns1__submitSecretKey);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__submitSecretKey * SOAP_FMAC6 soap_new_ns1__submitSecretKey(struct soap *soap, int n)
{	return soap_instantiate_ns1__submitSecretKey(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__submitSecretKey(struct soap *soap, ns1__submitSecretKey *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__submitSecretKey * SOAP_FMAC4 soap_instantiate_ns1__submitSecretKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__submitSecretKey(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__submitSecretKey, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__submitSecretKey;
		if (size)
			*size = sizeof(ns1__submitSecretKey);
		((ns1__submitSecretKey*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__submitSecretKey[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__submitSecretKey);
		for (int i = 0; i < n; i++)
			((ns1__submitSecretKey*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__submitSecretKey*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__submitSecretKey(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__submitSecretKey %p -> %p\n", q, p));
	*(ns1__submitSecretKey*)p = *(ns1__submitSecretKey*)q;
}

void ns1__setEntityPropertiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__setEntityPropertiesResponse::return_);
	/* transient soap skipped */
}

void ns1__setEntityPropertiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setEntityPropertiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setEntityPropertiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setEntityPropertiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setEntityPropertiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setEntityPropertiesResponse(struct soap *soap, const char *tag, int id, const ns1__setEntityPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setEntityPropertiesResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__setEntityPropertiesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setEntityPropertiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setEntityPropertiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setEntityPropertiesResponse * SOAP_FMAC4 soap_get_ns1__setEntityPropertiesResponse(struct soap *soap, ns1__setEntityPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setEntityPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setEntityPropertiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setEntityPropertiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setEntityPropertiesResponse * SOAP_FMAC4 soap_in_ns1__setEntityPropertiesResponse(struct soap *soap, const char *tag, ns1__setEntityPropertiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setEntityPropertiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setEntityPropertiesResponse, sizeof(ns1__setEntityPropertiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setEntityPropertiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setEntityPropertiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__setEntityPropertiesResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setEntityPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setEntityPropertiesResponse, 0, sizeof(ns1__setEntityPropertiesResponse), 0, soap_copy_ns1__setEntityPropertiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setEntityPropertiesResponse * SOAP_FMAC6 soap_new_ns1__setEntityPropertiesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__setEntityPropertiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setEntityPropertiesResponse(struct soap *soap, ns1__setEntityPropertiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setEntityPropertiesResponse * SOAP_FMAC4 soap_instantiate_ns1__setEntityPropertiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setEntityPropertiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setEntityPropertiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setEntityPropertiesResponse;
		if (size)
			*size = sizeof(ns1__setEntityPropertiesResponse);
		((ns1__setEntityPropertiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setEntityPropertiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setEntityPropertiesResponse);
		for (int i = 0; i < n; i++)
			((ns1__setEntityPropertiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setEntityPropertiesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setEntityPropertiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setEntityPropertiesResponse %p -> %p\n", q, p));
	*(ns1__setEntityPropertiesResponse*)p = *(ns1__setEntityPropertiesResponse*)q;
}

void ns1__property::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__property::name = NULL;
	this->ns1__property::value = NULL;
	/* transient soap skipped */
}

void ns1__property::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__entityProperty(soap, &this->ns1__property::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__property::value);
	/* transient soap skipped */
}

int ns1__property::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__property);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__property::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__property(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__property(struct soap *soap, const char *tag, int id, const ns1__property *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__property), type))
		return soap->error;
	if (soap_out_PointerTons1__entityProperty(soap, "name", -1, &(a->ns1__property::name), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "value", -1, &(a->ns1__property::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__property::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__property(soap, this, tag, type);
}

SOAP_FMAC3 ns1__property * SOAP_FMAC4 soap_get_ns1__property(struct soap *soap, ns1__property *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__property::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__property(soap, tag, this, type);
}

SOAP_FMAC3 ns1__property * SOAP_FMAC4 soap_in_ns1__property(struct soap *soap, const char *tag, ns1__property *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__property *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__property, sizeof(ns1__property), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__property)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__property *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__entityProperty(soap, "name", &(a->ns1__property::name), "ns1:entityProperty"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "value", &(a->ns1__property::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__property *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__property, 0, sizeof(ns1__property), 0, soap_copy_ns1__property);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__property * SOAP_FMAC6 soap_new_ns1__property(struct soap *soap, int n)
{	return soap_instantiate_ns1__property(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__property(struct soap *soap, ns1__property *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__property * SOAP_FMAC4 soap_instantiate_ns1__property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__property;
		if (size)
			*size = sizeof(ns1__property);
		((ns1__property*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__property[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__property);
		for (int i = 0; i < n; i++)
			((ns1__property*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__property*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__property %p -> %p\n", q, p));
	*(ns1__property*)p = *(ns1__property*)q;
}

void ns1__setEntityProperties::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__setEntityProperties::entityId);
	soap_default_std__vectorTemplateOfPointerTons1__property(soap, &this->ns1__setEntityProperties::properties);
	soap_default_bool(soap, &this->ns1__setEntityProperties::forceSetting);
	/* transient soap skipped */
}

void ns1__setEntityProperties::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__property(soap, &this->ns1__setEntityProperties::properties);
	/* transient soap skipped */
}

int ns1__setEntityProperties::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setEntityProperties);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setEntityProperties::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setEntityProperties(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setEntityProperties(struct soap *soap, const char *tag, int id, const ns1__setEntityProperties *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setEntityProperties), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__setEntityProperties::entityId), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__property(soap, "properties", -1, &(a->ns1__setEntityProperties::properties), ""))
		return soap->error;
	if (soap_out_bool(soap, "forceSetting", -1, &(a->ns1__setEntityProperties::forceSetting), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setEntityProperties::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setEntityProperties(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setEntityProperties * SOAP_FMAC4 soap_get_ns1__setEntityProperties(struct soap *soap, ns1__setEntityProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setEntityProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setEntityProperties::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setEntityProperties(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setEntityProperties * SOAP_FMAC4 soap_in_ns1__setEntityProperties(struct soap *soap, const char *tag, ns1__setEntityProperties *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setEntityProperties *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setEntityProperties, sizeof(ns1__setEntityProperties), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setEntityProperties)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setEntityProperties *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_forceSetting1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__setEntityProperties::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__property(soap, "properties", &(a->ns1__setEntityProperties::properties), "ns1:property"))
					continue;
			if (soap_flag_forceSetting1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "forceSetting", &(a->ns1__setEntityProperties::forceSetting), "xsd:boolean"))
				{	soap_flag_forceSetting1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setEntityProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setEntityProperties, 0, sizeof(ns1__setEntityProperties), 0, soap_copy_ns1__setEntityProperties);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_forceSetting1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setEntityProperties * SOAP_FMAC6 soap_new_ns1__setEntityProperties(struct soap *soap, int n)
{	return soap_instantiate_ns1__setEntityProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setEntityProperties(struct soap *soap, ns1__setEntityProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setEntityProperties * SOAP_FMAC4 soap_instantiate_ns1__setEntityProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setEntityProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setEntityProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setEntityProperties;
		if (size)
			*size = sizeof(ns1__setEntityProperties);
		((ns1__setEntityProperties*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setEntityProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setEntityProperties);
		for (int i = 0; i < n; i++)
			((ns1__setEntityProperties*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setEntityProperties*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setEntityProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setEntityProperties %p -> %p\n", q, p));
	*(ns1__setEntityProperties*)p = *(ns1__setEntityProperties*)q;
}

void ns1__setEventStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__setEventStateResponse::return_);
	/* transient soap skipped */
}

void ns1__setEventStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setEventStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setEventStateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setEventStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setEventStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setEventStateResponse(struct soap *soap, const char *tag, int id, const ns1__setEventStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setEventStateResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__setEventStateResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setEventStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setEventStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setEventStateResponse * SOAP_FMAC4 soap_get_ns1__setEventStateResponse(struct soap *soap, ns1__setEventStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setEventStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setEventStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setEventStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setEventStateResponse * SOAP_FMAC4 soap_in_ns1__setEventStateResponse(struct soap *soap, const char *tag, ns1__setEventStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setEventStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setEventStateResponse, sizeof(ns1__setEventStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setEventStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setEventStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__setEventStateResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setEventStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setEventStateResponse, 0, sizeof(ns1__setEventStateResponse), 0, soap_copy_ns1__setEventStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setEventStateResponse * SOAP_FMAC6 soap_new_ns1__setEventStateResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__setEventStateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setEventStateResponse(struct soap *soap, ns1__setEventStateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setEventStateResponse * SOAP_FMAC4 soap_instantiate_ns1__setEventStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setEventStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setEventStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setEventStateResponse;
		if (size)
			*size = sizeof(ns1__setEventStateResponse);
		((ns1__setEventStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setEventStateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setEventStateResponse);
		for (int i = 0; i < n; i++)
			((ns1__setEventStateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setEventStateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setEventStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setEventStateResponse %p -> %p\n", q, p));
	*(ns1__setEventStateResponse*)p = *(ns1__setEventStateResponse*)q;
}

void ns1__setEventState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__setEventState::eventId);
	soap_default_bool(soap, &this->ns1__setEventState::enable);
	/* transient soap skipped */
}

void ns1__setEventState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setEventState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setEventState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setEventState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setEventState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setEventState(struct soap *soap, const char *tag, int id, const ns1__setEventState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setEventState), type))
		return soap->error;
	if (soap_out_int(soap, "eventId", -1, &(a->ns1__setEventState::eventId), ""))
		return soap->error;
	if (soap_out_bool(soap, "enable", -1, &(a->ns1__setEventState::enable), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setEventState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setEventState(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setEventState * SOAP_FMAC4 soap_get_ns1__setEventState(struct soap *soap, ns1__setEventState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setEventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setEventState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setEventState(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setEventState * SOAP_FMAC4 soap_in_ns1__setEventState(struct soap *soap, const char *tag, ns1__setEventState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setEventState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setEventState, sizeof(ns1__setEventState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setEventState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setEventState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_eventId1 = 1;
	size_t soap_flag_enable1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "eventId", &(a->ns1__setEventState::eventId), "xsd:int"))
				{	soap_flag_eventId1--;
					continue;
				}
			if (soap_flag_enable1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enable", &(a->ns1__setEventState::enable), "xsd:boolean"))
				{	soap_flag_enable1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setEventState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setEventState, 0, sizeof(ns1__setEventState), 0, soap_copy_ns1__setEventState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventId1 > 0 || soap_flag_enable1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setEventState * SOAP_FMAC6 soap_new_ns1__setEventState(struct soap *soap, int n)
{	return soap_instantiate_ns1__setEventState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setEventState(struct soap *soap, ns1__setEventState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setEventState * SOAP_FMAC4 soap_instantiate_ns1__setEventState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setEventState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setEventState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setEventState;
		if (size)
			*size = sizeof(ns1__setEventState);
		((ns1__setEventState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setEventState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setEventState);
		for (int i = 0; i < n; i++)
			((ns1__setEventState*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setEventState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setEventState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setEventState %p -> %p\n", q, p));
	*(ns1__setEventState*)p = *(ns1__setEventState*)q;
}

void ns1__subscribeEventHandlerResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__subscribeEventHandlerResponse::return_);
	/* transient soap skipped */
}

void ns1__subscribeEventHandlerResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__subscribeEventHandlerResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__subscribeEventHandlerResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__subscribeEventHandlerResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__subscribeEventHandlerResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__subscribeEventHandlerResponse(struct soap *soap, const char *tag, int id, const ns1__subscribeEventHandlerResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__subscribeEventHandlerResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &(a->ns1__subscribeEventHandlerResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__subscribeEventHandlerResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__subscribeEventHandlerResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__subscribeEventHandlerResponse * SOAP_FMAC4 soap_get_ns1__subscribeEventHandlerResponse(struct soap *soap, ns1__subscribeEventHandlerResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__subscribeEventHandlerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__subscribeEventHandlerResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__subscribeEventHandlerResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__subscribeEventHandlerResponse * SOAP_FMAC4 soap_in_ns1__subscribeEventHandlerResponse(struct soap *soap, const char *tag, ns1__subscribeEventHandlerResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__subscribeEventHandlerResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__subscribeEventHandlerResponse, sizeof(ns1__subscribeEventHandlerResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__subscribeEventHandlerResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__subscribeEventHandlerResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &(a->ns1__subscribeEventHandlerResponse::return_), "xsd:int"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__subscribeEventHandlerResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__subscribeEventHandlerResponse, 0, sizeof(ns1__subscribeEventHandlerResponse), 0, soap_copy_ns1__subscribeEventHandlerResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__subscribeEventHandlerResponse * SOAP_FMAC6 soap_new_ns1__subscribeEventHandlerResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__subscribeEventHandlerResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__subscribeEventHandlerResponse(struct soap *soap, ns1__subscribeEventHandlerResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__subscribeEventHandlerResponse * SOAP_FMAC4 soap_instantiate_ns1__subscribeEventHandlerResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__subscribeEventHandlerResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__subscribeEventHandlerResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__subscribeEventHandlerResponse;
		if (size)
			*size = sizeof(ns1__subscribeEventHandlerResponse);
		((ns1__subscribeEventHandlerResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__subscribeEventHandlerResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__subscribeEventHandlerResponse);
		for (int i = 0; i < n; i++)
			((ns1__subscribeEventHandlerResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__subscribeEventHandlerResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__subscribeEventHandlerResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__subscribeEventHandlerResponse %p -> %p\n", q, p));
	*(ns1__subscribeEventHandlerResponse*)p = *(ns1__subscribeEventHandlerResponse*)q;
}

void ns1__subscribeEventHandler::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__subscribeEventHandler::url = NULL;
	/* transient soap skipped */
}

void ns1__subscribeEventHandler::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__subscribeEventHandler::url);
	/* transient soap skipped */
}

int ns1__subscribeEventHandler::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__subscribeEventHandler);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__subscribeEventHandler::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__subscribeEventHandler(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__subscribeEventHandler(struct soap *soap, const char *tag, int id, const ns1__subscribeEventHandler *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__subscribeEventHandler), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "url", -1, &(a->ns1__subscribeEventHandler::url), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__subscribeEventHandler::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__subscribeEventHandler(soap, this, tag, type);
}

SOAP_FMAC3 ns1__subscribeEventHandler * SOAP_FMAC4 soap_get_ns1__subscribeEventHandler(struct soap *soap, ns1__subscribeEventHandler *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__subscribeEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__subscribeEventHandler::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__subscribeEventHandler(soap, tag, this, type);
}

SOAP_FMAC3 ns1__subscribeEventHandler * SOAP_FMAC4 soap_in_ns1__subscribeEventHandler(struct soap *soap, const char *tag, ns1__subscribeEventHandler *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__subscribeEventHandler *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__subscribeEventHandler, sizeof(ns1__subscribeEventHandler), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__subscribeEventHandler)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__subscribeEventHandler *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_url1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_url1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "url", &(a->ns1__subscribeEventHandler::url), "xsd:string"))
				{	soap_flag_url1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__subscribeEventHandler *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__subscribeEventHandler, 0, sizeof(ns1__subscribeEventHandler), 0, soap_copy_ns1__subscribeEventHandler);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__subscribeEventHandler * SOAP_FMAC6 soap_new_ns1__subscribeEventHandler(struct soap *soap, int n)
{	return soap_instantiate_ns1__subscribeEventHandler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__subscribeEventHandler(struct soap *soap, ns1__subscribeEventHandler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__subscribeEventHandler * SOAP_FMAC4 soap_instantiate_ns1__subscribeEventHandler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__subscribeEventHandler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__subscribeEventHandler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__subscribeEventHandler;
		if (size)
			*size = sizeof(ns1__subscribeEventHandler);
		((ns1__subscribeEventHandler*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__subscribeEventHandler[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__subscribeEventHandler);
		for (int i = 0; i < n; i++)
			((ns1__subscribeEventHandler*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__subscribeEventHandler*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__subscribeEventHandler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__subscribeEventHandler %p -> %p\n", q, p));
	*(ns1__subscribeEventHandler*)p = *(ns1__subscribeEventHandler*)q;
}

void ns1__getGlobalPropertyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getGlobalPropertyResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getGlobalPropertyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getGlobalPropertyResponse::return_);
	/* transient soap skipped */
}

int ns1__getGlobalPropertyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalPropertyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getGlobalPropertyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getGlobalPropertyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalPropertyResponse(struct soap *soap, const char *tag, int id, const ns1__getGlobalPropertyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalPropertyResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getGlobalPropertyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getGlobalPropertyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getGlobalPropertyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getGlobalPropertyResponse * SOAP_FMAC4 soap_get_ns1__getGlobalPropertyResponse(struct soap *soap, ns1__getGlobalPropertyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalPropertyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getGlobalPropertyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getGlobalPropertyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getGlobalPropertyResponse * SOAP_FMAC4 soap_in_ns1__getGlobalPropertyResponse(struct soap *soap, const char *tag, ns1__getGlobalPropertyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getGlobalPropertyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalPropertyResponse, sizeof(ns1__getGlobalPropertyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getGlobalPropertyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getGlobalPropertyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getGlobalPropertyResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getGlobalPropertyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalPropertyResponse, 0, sizeof(ns1__getGlobalPropertyResponse), 0, soap_copy_ns1__getGlobalPropertyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getGlobalPropertyResponse * SOAP_FMAC6 soap_new_ns1__getGlobalPropertyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getGlobalPropertyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getGlobalPropertyResponse(struct soap *soap, ns1__getGlobalPropertyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getGlobalPropertyResponse * SOAP_FMAC4 soap_instantiate_ns1__getGlobalPropertyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalPropertyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalPropertyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getGlobalPropertyResponse;
		if (size)
			*size = sizeof(ns1__getGlobalPropertyResponse);
		((ns1__getGlobalPropertyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getGlobalPropertyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getGlobalPropertyResponse);
		for (int i = 0; i < n; i++)
			((ns1__getGlobalPropertyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getGlobalPropertyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalPropertyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getGlobalPropertyResponse %p -> %p\n", q, p));
	*(ns1__getGlobalPropertyResponse*)p = *(ns1__getGlobalPropertyResponse*)q;
}

void ns1__getGlobalProperty::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getGlobalProperty::property = NULL;
	/* transient soap skipped */
}

void ns1__getGlobalProperty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__globalProperty(soap, &this->ns1__getGlobalProperty::property);
	/* transient soap skipped */
}

int ns1__getGlobalProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getGlobalProperty);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getGlobalProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getGlobalProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getGlobalProperty(struct soap *soap, const char *tag, int id, const ns1__getGlobalProperty *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getGlobalProperty), type))
		return soap->error;
	if (soap_out_PointerTons1__globalProperty(soap, "property", -1, &(a->ns1__getGlobalProperty::property), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getGlobalProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getGlobalProperty(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getGlobalProperty * SOAP_FMAC4 soap_get_ns1__getGlobalProperty(struct soap *soap, ns1__getGlobalProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getGlobalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getGlobalProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getGlobalProperty(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getGlobalProperty * SOAP_FMAC4 soap_in_ns1__getGlobalProperty(struct soap *soap, const char *tag, ns1__getGlobalProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getGlobalProperty *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getGlobalProperty, sizeof(ns1__getGlobalProperty), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getGlobalProperty)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getGlobalProperty *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_property1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_property1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalProperty(soap, "property", &(a->ns1__getGlobalProperty::property), "ns1:globalProperty"))
				{	soap_flag_property1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getGlobalProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getGlobalProperty, 0, sizeof(ns1__getGlobalProperty), 0, soap_copy_ns1__getGlobalProperty);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getGlobalProperty * SOAP_FMAC6 soap_new_ns1__getGlobalProperty(struct soap *soap, int n)
{	return soap_instantiate_ns1__getGlobalProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getGlobalProperty(struct soap *soap, ns1__getGlobalProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getGlobalProperty * SOAP_FMAC4 soap_instantiate_ns1__getGlobalProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getGlobalProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getGlobalProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getGlobalProperty;
		if (size)
			*size = sizeof(ns1__getGlobalProperty);
		((ns1__getGlobalProperty*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getGlobalProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getGlobalProperty);
		for (int i = 0; i < n; i++)
			((ns1__getGlobalProperty*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getGlobalProperty*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getGlobalProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getGlobalProperty %p -> %p\n", q, p));
	*(ns1__getGlobalProperty*)p = *(ns1__getGlobalProperty*)q;
}

void ns1__updatePolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__updatePolicyResponse::return_);
	/* transient soap skipped */
}

void ns1__updatePolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__updatePolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updatePolicyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__updatePolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updatePolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updatePolicyResponse(struct soap *soap, const char *tag, int id, const ns1__updatePolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updatePolicyResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__updatePolicyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updatePolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updatePolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updatePolicyResponse * SOAP_FMAC4 soap_get_ns1__updatePolicyResponse(struct soap *soap, ns1__updatePolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updatePolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__updatePolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updatePolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updatePolicyResponse * SOAP_FMAC4 soap_in_ns1__updatePolicyResponse(struct soap *soap, const char *tag, ns1__updatePolicyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updatePolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updatePolicyResponse, sizeof(ns1__updatePolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updatePolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updatePolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__updatePolicyResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updatePolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updatePolicyResponse, 0, sizeof(ns1__updatePolicyResponse), 0, soap_copy_ns1__updatePolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__updatePolicyResponse * SOAP_FMAC6 soap_new_ns1__updatePolicyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__updatePolicyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__updatePolicyResponse(struct soap *soap, ns1__updatePolicyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__updatePolicyResponse * SOAP_FMAC4 soap_instantiate_ns1__updatePolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updatePolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updatePolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__updatePolicyResponse;
		if (size)
			*size = sizeof(ns1__updatePolicyResponse);
		((ns1__updatePolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__updatePolicyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updatePolicyResponse);
		for (int i = 0; i < n; i++)
			((ns1__updatePolicyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updatePolicyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updatePolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updatePolicyResponse %p -> %p\n", q, p));
	*(ns1__updatePolicyResponse*)p = *(ns1__updatePolicyResponse*)q;
}

void ns1__updatePolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__updatePolicy::policyId);
	soap_default_int(soap, &this->ns1__updatePolicy::threshold);
	this->ns1__updatePolicy::policyDescription = NULL;
	soap_default_bool(soap, &this->ns1__updatePolicy::updatePriorityLists);
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__updatePolicy::lowPriorityList);
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__updatePolicy::highPriorityList);
	/* transient soap skipped */
}

void ns1__updatePolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__updatePolicy::policyDescription);
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__updatePolicy::lowPriorityList);
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__updatePolicy::highPriorityList);
	/* transient soap skipped */
}

int ns1__updatePolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updatePolicy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__updatePolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updatePolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updatePolicy(struct soap *soap, const char *tag, int id, const ns1__updatePolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updatePolicy), type))
		return soap->error;
	if (soap_out_int(soap, "policyId", -1, &(a->ns1__updatePolicy::policyId), ""))
		return soap->error;
	if (soap_out_int(soap, "threshold", -1, &(a->ns1__updatePolicy::threshold), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "policyDescription", -1, &(a->ns1__updatePolicy::policyDescription), ""))
		return soap->error;
	if (soap_out_bool(soap, "updatePriorityLists", -1, &(a->ns1__updatePolicy::updatePriorityLists), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "lowPriorityList", -1, &(a->ns1__updatePolicy::lowPriorityList), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "highPriorityList", -1, &(a->ns1__updatePolicy::highPriorityList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updatePolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updatePolicy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updatePolicy * SOAP_FMAC4 soap_get_ns1__updatePolicy(struct soap *soap, ns1__updatePolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updatePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__updatePolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updatePolicy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updatePolicy * SOAP_FMAC4 soap_in_ns1__updatePolicy(struct soap *soap, const char *tag, ns1__updatePolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updatePolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updatePolicy, sizeof(ns1__updatePolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updatePolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updatePolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_policyId1 = 1;
	size_t soap_flag_threshold1 = 1;
	size_t soap_flag_policyDescription1 = 1;
	size_t soap_flag_updatePriorityLists1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_policyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "policyId", &(a->ns1__updatePolicy::policyId), "xsd:int"))
				{	soap_flag_policyId1--;
					continue;
				}
			if (soap_flag_threshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "threshold", &(a->ns1__updatePolicy::threshold), "xsd:int"))
				{	soap_flag_threshold1--;
					continue;
				}
			if (soap_flag_policyDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "policyDescription", &(a->ns1__updatePolicy::policyDescription), "xsd:string"))
				{	soap_flag_policyDescription1--;
					continue;
				}
			if (soap_flag_updatePriorityLists1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "updatePriorityLists", &(a->ns1__updatePolicy::updatePriorityLists), "xsd:boolean"))
				{	soap_flag_updatePriorityLists1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "lowPriorityList", &(a->ns1__updatePolicy::lowPriorityList), "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "highPriorityList", &(a->ns1__updatePolicy::highPriorityList), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updatePolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updatePolicy, 0, sizeof(ns1__updatePolicy), 0, soap_copy_ns1__updatePolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_policyId1 > 0 || soap_flag_threshold1 > 0 || soap_flag_updatePriorityLists1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__updatePolicy * SOAP_FMAC6 soap_new_ns1__updatePolicy(struct soap *soap, int n)
{	return soap_instantiate_ns1__updatePolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__updatePolicy(struct soap *soap, ns1__updatePolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__updatePolicy * SOAP_FMAC4 soap_instantiate_ns1__updatePolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updatePolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updatePolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__updatePolicy;
		if (size)
			*size = sizeof(ns1__updatePolicy);
		((ns1__updatePolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__updatePolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updatePolicy);
		for (int i = 0; i < n; i++)
			((ns1__updatePolicy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updatePolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updatePolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updatePolicy %p -> %p\n", q, p));
	*(ns1__updatePolicy*)p = *(ns1__updatePolicy*)q;
}

void ns1__rediscoverNodeCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__rediscoverNodeCapabilitiesResponse::return_);
	/* transient soap skipped */
}

void ns1__rediscoverNodeCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__rediscoverNodeCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__rediscoverNodeCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__rediscoverNodeCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__rediscoverNodeCapabilitiesResponse(struct soap *soap, const char *tag, int id, const ns1__rediscoverNodeCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__rediscoverNodeCapabilitiesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__rediscoverNodeCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__rediscoverNodeCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilitiesResponse * SOAP_FMAC4 soap_get_ns1__rediscoverNodeCapabilitiesResponse(struct soap *soap, ns1__rediscoverNodeCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__rediscoverNodeCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__rediscoverNodeCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__rediscoverNodeCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilitiesResponse * SOAP_FMAC4 soap_in_ns1__rediscoverNodeCapabilitiesResponse(struct soap *soap, const char *tag, ns1__rediscoverNodeCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__rediscoverNodeCapabilitiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse, sizeof(ns1__rediscoverNodeCapabilitiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__rediscoverNodeCapabilitiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__rediscoverNodeCapabilitiesResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__rediscoverNodeCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse, 0, sizeof(ns1__rediscoverNodeCapabilitiesResponse), 0, soap_copy_ns1__rediscoverNodeCapabilitiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__rediscoverNodeCapabilitiesResponse * SOAP_FMAC6 soap_new_ns1__rediscoverNodeCapabilitiesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__rediscoverNodeCapabilitiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__rediscoverNodeCapabilitiesResponse(struct soap *soap, ns1__rediscoverNodeCapabilitiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilitiesResponse * SOAP_FMAC4 soap_instantiate_ns1__rediscoverNodeCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__rediscoverNodeCapabilitiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__rediscoverNodeCapabilitiesResponse;
		if (size)
			*size = sizeof(ns1__rediscoverNodeCapabilitiesResponse);
		((ns1__rediscoverNodeCapabilitiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__rediscoverNodeCapabilitiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__rediscoverNodeCapabilitiesResponse);
		for (int i = 0; i < n; i++)
			((ns1__rediscoverNodeCapabilitiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__rediscoverNodeCapabilitiesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__rediscoverNodeCapabilitiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__rediscoverNodeCapabilitiesResponse %p -> %p\n", q, p));
	*(ns1__rediscoverNodeCapabilitiesResponse*)p = *(ns1__rediscoverNodeCapabilitiesResponse*)q;
}

void ns1__rediscoverNodeCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__rediscoverNodeCapabilities::entityId);
	/* transient soap skipped */
}

void ns1__rediscoverNodeCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__rediscoverNodeCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__rediscoverNodeCapabilities);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__rediscoverNodeCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__rediscoverNodeCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__rediscoverNodeCapabilities(struct soap *soap, const char *tag, int id, const ns1__rediscoverNodeCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__rediscoverNodeCapabilities), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__rediscoverNodeCapabilities::entityId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__rediscoverNodeCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__rediscoverNodeCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilities * SOAP_FMAC4 soap_get_ns1__rediscoverNodeCapabilities(struct soap *soap, ns1__rediscoverNodeCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__rediscoverNodeCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__rediscoverNodeCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__rediscoverNodeCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilities * SOAP_FMAC4 soap_in_ns1__rediscoverNodeCapabilities(struct soap *soap, const char *tag, ns1__rediscoverNodeCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__rediscoverNodeCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__rediscoverNodeCapabilities, sizeof(ns1__rediscoverNodeCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__rediscoverNodeCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__rediscoverNodeCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__rediscoverNodeCapabilities::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__rediscoverNodeCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__rediscoverNodeCapabilities, 0, sizeof(ns1__rediscoverNodeCapabilities), 0, soap_copy_ns1__rediscoverNodeCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__rediscoverNodeCapabilities * SOAP_FMAC6 soap_new_ns1__rediscoverNodeCapabilities(struct soap *soap, int n)
{	return soap_instantiate_ns1__rediscoverNodeCapabilities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__rediscoverNodeCapabilities(struct soap *soap, ns1__rediscoverNodeCapabilities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilities * SOAP_FMAC4 soap_instantiate_ns1__rediscoverNodeCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__rediscoverNodeCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__rediscoverNodeCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__rediscoverNodeCapabilities;
		if (size)
			*size = sizeof(ns1__rediscoverNodeCapabilities);
		((ns1__rediscoverNodeCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__rediscoverNodeCapabilities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__rediscoverNodeCapabilities);
		for (int i = 0; i < n; i++)
			((ns1__rediscoverNodeCapabilities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__rediscoverNodeCapabilities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__rediscoverNodeCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__rediscoverNodeCapabilities %p -> %p\n", q, p));
	*(ns1__rediscoverNodeCapabilities*)p = *(ns1__rediscoverNodeCapabilities*)q;
}

void ns1__removeEntityResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__removeEntityResponse::return_);
	/* transient soap skipped */
}

void ns1__removeEntityResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeEntityResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeEntityResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__removeEntityResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeEntityResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeEntityResponse(struct soap *soap, const char *tag, int id, const ns1__removeEntityResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeEntityResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__removeEntityResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__removeEntityResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeEntityResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeEntityResponse * SOAP_FMAC4 soap_get_ns1__removeEntityResponse(struct soap *soap, ns1__removeEntityResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__removeEntityResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeEntityResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeEntityResponse * SOAP_FMAC4 soap_in_ns1__removeEntityResponse(struct soap *soap, const char *tag, ns1__removeEntityResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeEntityResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeEntityResponse, sizeof(ns1__removeEntityResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeEntityResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeEntityResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__removeEntityResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeEntityResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeEntityResponse, 0, sizeof(ns1__removeEntityResponse), 0, soap_copy_ns1__removeEntityResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__removeEntityResponse * SOAP_FMAC6 soap_new_ns1__removeEntityResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__removeEntityResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__removeEntityResponse(struct soap *soap, ns1__removeEntityResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__removeEntityResponse * SOAP_FMAC4 soap_instantiate_ns1__removeEntityResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeEntityResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeEntityResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__removeEntityResponse;
		if (size)
			*size = sizeof(ns1__removeEntityResponse);
		((ns1__removeEntityResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__removeEntityResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeEntityResponse);
		for (int i = 0; i < n; i++)
			((ns1__removeEntityResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeEntityResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeEntityResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeEntityResponse %p -> %p\n", q, p));
	*(ns1__removeEntityResponse*)p = *(ns1__removeEntityResponse*)q;
}

void ns1__removeEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__removeEntity::entityId);
	soap_default_bool(soap, &this->ns1__removeEntity::delCollectedData);
	/* transient soap skipped */
}

void ns1__removeEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removeEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removeEntity);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__removeEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removeEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removeEntity(struct soap *soap, const char *tag, int id, const ns1__removeEntity *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removeEntity), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__removeEntity::entityId), ""))
		return soap->error;
	if (soap_out_bool(soap, "delCollectedData", -1, &(a->ns1__removeEntity::delCollectedData), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__removeEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removeEntity(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removeEntity * SOAP_FMAC4 soap_get_ns1__removeEntity(struct soap *soap, ns1__removeEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removeEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__removeEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removeEntity(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removeEntity * SOAP_FMAC4 soap_in_ns1__removeEntity(struct soap *soap, const char *tag, ns1__removeEntity *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removeEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removeEntity, sizeof(ns1__removeEntity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removeEntity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removeEntity *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_delCollectedData1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__removeEntity::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_delCollectedData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "delCollectedData", &(a->ns1__removeEntity::delCollectedData), "xsd:boolean"))
				{	soap_flag_delCollectedData1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removeEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removeEntity, 0, sizeof(ns1__removeEntity), 0, soap_copy_ns1__removeEntity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_delCollectedData1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__removeEntity * SOAP_FMAC6 soap_new_ns1__removeEntity(struct soap *soap, int n)
{	return soap_instantiate_ns1__removeEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__removeEntity(struct soap *soap, ns1__removeEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__removeEntity * SOAP_FMAC4 soap_instantiate_ns1__removeEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removeEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removeEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__removeEntity;
		if (size)
			*size = sizeof(ns1__removeEntity);
		((ns1__removeEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__removeEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removeEntity);
		for (int i = 0; i < n; i++)
			((ns1__removeEntity*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removeEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removeEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removeEntity %p -> %p\n", q, p));
	*(ns1__removeEntity*)p = *(ns1__removeEntity*)q;
}

void ns1__setCollectionStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__setCollectionStateResponse::return_);
	/* transient soap skipped */
}

void ns1__setCollectionStateResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setCollectionStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setCollectionStateResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setCollectionStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setCollectionStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setCollectionStateResponse(struct soap *soap, const char *tag, int id, const ns1__setCollectionStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setCollectionStateResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__setCollectionStateResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setCollectionStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setCollectionStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setCollectionStateResponse * SOAP_FMAC4 soap_get_ns1__setCollectionStateResponse(struct soap *soap, ns1__setCollectionStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setCollectionStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setCollectionStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setCollectionStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setCollectionStateResponse * SOAP_FMAC4 soap_in_ns1__setCollectionStateResponse(struct soap *soap, const char *tag, ns1__setCollectionStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setCollectionStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setCollectionStateResponse, sizeof(ns1__setCollectionStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setCollectionStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setCollectionStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__setCollectionStateResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setCollectionStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setCollectionStateResponse, 0, sizeof(ns1__setCollectionStateResponse), 0, soap_copy_ns1__setCollectionStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setCollectionStateResponse * SOAP_FMAC6 soap_new_ns1__setCollectionStateResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__setCollectionStateResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setCollectionStateResponse(struct soap *soap, ns1__setCollectionStateResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setCollectionStateResponse * SOAP_FMAC4 soap_instantiate_ns1__setCollectionStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setCollectionStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setCollectionStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setCollectionStateResponse;
		if (size)
			*size = sizeof(ns1__setCollectionStateResponse);
		((ns1__setCollectionStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setCollectionStateResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setCollectionStateResponse);
		for (int i = 0; i < n; i++)
			((ns1__setCollectionStateResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setCollectionStateResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setCollectionStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setCollectionStateResponse %p -> %p\n", q, p));
	*(ns1__setCollectionStateResponse*)p = *(ns1__setCollectionStateResponse*)q;
}

void ns1__setCollectionState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__setCollectionState::suspend);
	/* transient soap skipped */
}

void ns1__setCollectionState::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setCollectionState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setCollectionState);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setCollectionState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setCollectionState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setCollectionState(struct soap *soap, const char *tag, int id, const ns1__setCollectionState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setCollectionState), type))
		return soap->error;
	if (soap_out_bool(soap, "suspend", -1, &(a->ns1__setCollectionState::suspend), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setCollectionState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setCollectionState(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setCollectionState * SOAP_FMAC4 soap_get_ns1__setCollectionState(struct soap *soap, ns1__setCollectionState *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setCollectionState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setCollectionState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setCollectionState(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setCollectionState * SOAP_FMAC4 soap_in_ns1__setCollectionState(struct soap *soap, const char *tag, ns1__setCollectionState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setCollectionState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setCollectionState, sizeof(ns1__setCollectionState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setCollectionState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setCollectionState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_suspend1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_suspend1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "suspend", &(a->ns1__setCollectionState::suspend), "xsd:boolean"))
				{	soap_flag_suspend1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setCollectionState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setCollectionState, 0, sizeof(ns1__setCollectionState), 0, soap_copy_ns1__setCollectionState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_suspend1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setCollectionState * SOAP_FMAC6 soap_new_ns1__setCollectionState(struct soap *soap, int n)
{	return soap_instantiate_ns1__setCollectionState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setCollectionState(struct soap *soap, ns1__setCollectionState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setCollectionState * SOAP_FMAC4 soap_instantiate_ns1__setCollectionState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setCollectionState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setCollectionState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setCollectionState;
		if (size)
			*size = sizeof(ns1__setCollectionState);
		((ns1__setCollectionState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setCollectionState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setCollectionState);
		for (int i = 0; i < n; i++)
			((ns1__setCollectionState*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setCollectionState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setCollectionState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setCollectionState %p -> %p\n", q, p));
	*(ns1__setCollectionState*)p = *(ns1__setCollectionState*)q;
}

void ns1__setGlobalPropertyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__setGlobalPropertyResponse::return_);
	/* transient soap skipped */
}

void ns1__setGlobalPropertyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setGlobalPropertyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setGlobalPropertyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setGlobalPropertyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setGlobalPropertyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setGlobalPropertyResponse(struct soap *soap, const char *tag, int id, const ns1__setGlobalPropertyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setGlobalPropertyResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__setGlobalPropertyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setGlobalPropertyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setGlobalPropertyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setGlobalPropertyResponse * SOAP_FMAC4 soap_get_ns1__setGlobalPropertyResponse(struct soap *soap, ns1__setGlobalPropertyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setGlobalPropertyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setGlobalPropertyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setGlobalPropertyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setGlobalPropertyResponse * SOAP_FMAC4 soap_in_ns1__setGlobalPropertyResponse(struct soap *soap, const char *tag, ns1__setGlobalPropertyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setGlobalPropertyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setGlobalPropertyResponse, sizeof(ns1__setGlobalPropertyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setGlobalPropertyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setGlobalPropertyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__setGlobalPropertyResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setGlobalPropertyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setGlobalPropertyResponse, 0, sizeof(ns1__setGlobalPropertyResponse), 0, soap_copy_ns1__setGlobalPropertyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setGlobalPropertyResponse * SOAP_FMAC6 soap_new_ns1__setGlobalPropertyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__setGlobalPropertyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setGlobalPropertyResponse(struct soap *soap, ns1__setGlobalPropertyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setGlobalPropertyResponse * SOAP_FMAC4 soap_instantiate_ns1__setGlobalPropertyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setGlobalPropertyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setGlobalPropertyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setGlobalPropertyResponse;
		if (size)
			*size = sizeof(ns1__setGlobalPropertyResponse);
		((ns1__setGlobalPropertyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setGlobalPropertyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setGlobalPropertyResponse);
		for (int i = 0; i < n; i++)
			((ns1__setGlobalPropertyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setGlobalPropertyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setGlobalPropertyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setGlobalPropertyResponse %p -> %p\n", q, p));
	*(ns1__setGlobalPropertyResponse*)p = *(ns1__setGlobalPropertyResponse*)q;
}

void ns1__setGlobalProperty::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__setGlobalProperty::property = NULL;
	this->ns1__setGlobalProperty::value = NULL;
	/* transient soap skipped */
}

void ns1__setGlobalProperty::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__globalProperty(soap, &this->ns1__setGlobalProperty::property);
	soap_serialize_PointerTostd__string(soap, &this->ns1__setGlobalProperty::value);
	/* transient soap skipped */
}

int ns1__setGlobalProperty::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setGlobalProperty);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setGlobalProperty::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setGlobalProperty(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setGlobalProperty(struct soap *soap, const char *tag, int id, const ns1__setGlobalProperty *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setGlobalProperty), type))
		return soap->error;
	if (soap_out_PointerTons1__globalProperty(soap, "property", -1, &(a->ns1__setGlobalProperty::property), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "value", -1, &(a->ns1__setGlobalProperty::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setGlobalProperty::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setGlobalProperty(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setGlobalProperty * SOAP_FMAC4 soap_get_ns1__setGlobalProperty(struct soap *soap, ns1__setGlobalProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setGlobalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setGlobalProperty::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setGlobalProperty(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setGlobalProperty * SOAP_FMAC4 soap_in_ns1__setGlobalProperty(struct soap *soap, const char *tag, ns1__setGlobalProperty *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setGlobalProperty *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setGlobalProperty, sizeof(ns1__setGlobalProperty), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setGlobalProperty)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setGlobalProperty *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_property1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_property1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__globalProperty(soap, "property", &(a->ns1__setGlobalProperty::property), "ns1:globalProperty"))
				{	soap_flag_property1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "value", &(a->ns1__setGlobalProperty::value), "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setGlobalProperty *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setGlobalProperty, 0, sizeof(ns1__setGlobalProperty), 0, soap_copy_ns1__setGlobalProperty);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setGlobalProperty * SOAP_FMAC6 soap_new_ns1__setGlobalProperty(struct soap *soap, int n)
{	return soap_instantiate_ns1__setGlobalProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setGlobalProperty(struct soap *soap, ns1__setGlobalProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setGlobalProperty * SOAP_FMAC4 soap_instantiate_ns1__setGlobalProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setGlobalProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setGlobalProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setGlobalProperty;
		if (size)
			*size = sizeof(ns1__setGlobalProperty);
		((ns1__setGlobalProperty*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setGlobalProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setGlobalProperty);
		for (int i = 0; i < n; i++)
			((ns1__setGlobalProperty*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setGlobalProperty*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setGlobalProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setGlobalProperty %p -> %p\n", q, p));
	*(ns1__setGlobalProperty*)p = *(ns1__setGlobalProperty*)q;
}

void ns1__subscribePredefinedEventResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__subscribePredefinedEventResponse::return_);
	/* transient soap skipped */
}

void ns1__subscribePredefinedEventResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__subscribePredefinedEventResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__subscribePredefinedEventResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__subscribePredefinedEventResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__subscribePredefinedEventResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__subscribePredefinedEventResponse(struct soap *soap, const char *tag, int id, const ns1__subscribePredefinedEventResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__subscribePredefinedEventResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__subscribePredefinedEventResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__subscribePredefinedEventResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__subscribePredefinedEventResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__subscribePredefinedEventResponse * SOAP_FMAC4 soap_get_ns1__subscribePredefinedEventResponse(struct soap *soap, ns1__subscribePredefinedEventResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__subscribePredefinedEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__subscribePredefinedEventResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__subscribePredefinedEventResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__subscribePredefinedEventResponse * SOAP_FMAC4 soap_in_ns1__subscribePredefinedEventResponse(struct soap *soap, const char *tag, ns1__subscribePredefinedEventResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__subscribePredefinedEventResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__subscribePredefinedEventResponse, sizeof(ns1__subscribePredefinedEventResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__subscribePredefinedEventResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__subscribePredefinedEventResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__subscribePredefinedEventResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__subscribePredefinedEventResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__subscribePredefinedEventResponse, 0, sizeof(ns1__subscribePredefinedEventResponse), 0, soap_copy_ns1__subscribePredefinedEventResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__subscribePredefinedEventResponse * SOAP_FMAC6 soap_new_ns1__subscribePredefinedEventResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__subscribePredefinedEventResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__subscribePredefinedEventResponse(struct soap *soap, ns1__subscribePredefinedEventResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__subscribePredefinedEventResponse * SOAP_FMAC4 soap_instantiate_ns1__subscribePredefinedEventResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__subscribePredefinedEventResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__subscribePredefinedEventResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__subscribePredefinedEventResponse;
		if (size)
			*size = sizeof(ns1__subscribePredefinedEventResponse);
		((ns1__subscribePredefinedEventResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__subscribePredefinedEventResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__subscribePredefinedEventResponse);
		for (int i = 0; i < n; i++)
			((ns1__subscribePredefinedEventResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__subscribePredefinedEventResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__subscribePredefinedEventResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__subscribePredefinedEventResponse %p -> %p\n", q, p));
	*(ns1__subscribePredefinedEventResponse*)p = *(ns1__subscribePredefinedEventResponse*)q;
}

void ns1__subscribePredefinedEvent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfns1__predefinedEventType(soap, &this->ns1__subscribePredefinedEvent::eventTypes);
	/* transient soap skipped */
}

void ns1__subscribePredefinedEvent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfns1__predefinedEventType(soap, &this->ns1__subscribePredefinedEvent::eventTypes);
	/* transient soap skipped */
}

int ns1__subscribePredefinedEvent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__subscribePredefinedEvent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__subscribePredefinedEvent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__subscribePredefinedEvent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__subscribePredefinedEvent(struct soap *soap, const char *tag, int id, const ns1__subscribePredefinedEvent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__subscribePredefinedEvent), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__predefinedEventType(soap, "eventTypes", -1, &(a->ns1__subscribePredefinedEvent::eventTypes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__subscribePredefinedEvent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__subscribePredefinedEvent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__subscribePredefinedEvent * SOAP_FMAC4 soap_get_ns1__subscribePredefinedEvent(struct soap *soap, ns1__subscribePredefinedEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__subscribePredefinedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__subscribePredefinedEvent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__subscribePredefinedEvent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__subscribePredefinedEvent * SOAP_FMAC4 soap_in_ns1__subscribePredefinedEvent(struct soap *soap, const char *tag, ns1__subscribePredefinedEvent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__subscribePredefinedEvent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__subscribePredefinedEvent, sizeof(ns1__subscribePredefinedEvent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__subscribePredefinedEvent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__subscribePredefinedEvent *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__predefinedEventType(soap, "eventTypes", &(a->ns1__subscribePredefinedEvent::eventTypes), "ns1:predefinedEventType"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__subscribePredefinedEvent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__subscribePredefinedEvent, 0, sizeof(ns1__subscribePredefinedEvent), 0, soap_copy_ns1__subscribePredefinedEvent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__subscribePredefinedEvent * SOAP_FMAC6 soap_new_ns1__subscribePredefinedEvent(struct soap *soap, int n)
{	return soap_instantiate_ns1__subscribePredefinedEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__subscribePredefinedEvent(struct soap *soap, ns1__subscribePredefinedEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__subscribePredefinedEvent * SOAP_FMAC4 soap_instantiate_ns1__subscribePredefinedEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__subscribePredefinedEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__subscribePredefinedEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__subscribePredefinedEvent;
		if (size)
			*size = sizeof(ns1__subscribePredefinedEvent);
		((ns1__subscribePredefinedEvent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__subscribePredefinedEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__subscribePredefinedEvent);
		for (int i = 0; i < n; i++)
			((ns1__subscribePredefinedEvent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__subscribePredefinedEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__subscribePredefinedEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__subscribePredefinedEvent %p -> %p\n", q, p));
	*(ns1__subscribePredefinedEvent*)p = *(ns1__subscribePredefinedEvent*)q;
}

void ns1__getVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getVersionResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__getVersionResponse::return_);
	/* transient soap skipped */
}

int ns1__getVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getVersionResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVersionResponse(struct soap *soap, const char *tag, int id, const ns1__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVersionResponse), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "return", -1, &(a->ns1__getVersionResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getVersionResponse * SOAP_FMAC4 soap_get_ns1__getVersionResponse(struct soap *soap, ns1__getVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getVersionResponse * SOAP_FMAC4 soap_in_ns1__getVersionResponse(struct soap *soap, const char *tag, ns1__getVersionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getVersionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVersionResponse, sizeof(ns1__getVersionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getVersionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getVersionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "return", &(a->ns1__getVersionResponse::return_), "xsd:string"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVersionResponse, 0, sizeof(ns1__getVersionResponse), 0, soap_copy_ns1__getVersionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getVersionResponse * SOAP_FMAC6 soap_new_ns1__getVersionResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getVersionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getVersionResponse(struct soap *soap, ns1__getVersionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getVersionResponse * SOAP_FMAC4 soap_instantiate_ns1__getVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVersionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVersionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getVersionResponse;
		if (size)
			*size = sizeof(ns1__getVersionResponse);
		((ns1__getVersionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getVersionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getVersionResponse);
		for (int i = 0; i < n; i++)
			((ns1__getVersionResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getVersionResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVersionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getVersionResponse %p -> %p\n", q, p));
	*(ns1__getVersionResponse*)p = *(ns1__getVersionResponse*)q;
}

void ns1__getVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__getVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getVersion);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getVersion(struct soap *soap, const char *tag, int id, const ns1__getVersion *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getVersion), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getVersion(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getVersion * SOAP_FMAC4 soap_get_ns1__getVersion(struct soap *soap, ns1__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getVersion(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getVersion * SOAP_FMAC4 soap_in_ns1__getVersion(struct soap *soap, const char *tag, ns1__getVersion *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getVersion *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getVersion, sizeof(ns1__getVersion), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getVersion)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getVersion *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getVersion, 0, sizeof(ns1__getVersion), 0, soap_copy_ns1__getVersion);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getVersion * SOAP_FMAC6 soap_new_ns1__getVersion(struct soap *soap, int n)
{	return soap_instantiate_ns1__getVersion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getVersion(struct soap *soap, ns1__getVersion *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getVersion * SOAP_FMAC4 soap_instantiate_ns1__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getVersion;
		if (size)
			*size = sizeof(ns1__getVersion);
		((ns1__getVersion*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getVersion);
		for (int i = 0; i < n; i++)
			((ns1__getVersion*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getVersion %p -> %p\n", q, p));
	*(ns1__getVersion*)p = *(ns1__getVersion*)q;
}

void ns1__findEntitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__findEntitiesResponse::return_);
	/* transient soap skipped */
}

void ns1__findEntitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__findEntitiesResponse::return_);
	/* transient soap skipped */
}

int ns1__findEntitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findEntitiesResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findEntitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findEntitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findEntitiesResponse(struct soap *soap, const char *tag, int id, const ns1__findEntitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findEntitiesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "return", -1, &(a->ns1__findEntitiesResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findEntitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findEntitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findEntitiesResponse * SOAP_FMAC4 soap_get_ns1__findEntitiesResponse(struct soap *soap, ns1__findEntitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findEntitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findEntitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findEntitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findEntitiesResponse * SOAP_FMAC4 soap_in_ns1__findEntitiesResponse(struct soap *soap, const char *tag, ns1__findEntitiesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findEntitiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findEntitiesResponse, sizeof(ns1__findEntitiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findEntitiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findEntitiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "return", &(a->ns1__findEntitiesResponse::return_), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findEntitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findEntitiesResponse, 0, sizeof(ns1__findEntitiesResponse), 0, soap_copy_ns1__findEntitiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__findEntitiesResponse * SOAP_FMAC6 soap_new_ns1__findEntitiesResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__findEntitiesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__findEntitiesResponse(struct soap *soap, ns1__findEntitiesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__findEntitiesResponse * SOAP_FMAC4 soap_instantiate_ns1__findEntitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findEntitiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findEntitiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findEntitiesResponse;
		if (size)
			*size = sizeof(ns1__findEntitiesResponse);
		((ns1__findEntitiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findEntitiesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findEntitiesResponse);
		for (int i = 0; i < n; i++)
			((ns1__findEntitiesResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findEntitiesResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findEntitiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findEntitiesResponse %p -> %p\n", q, p));
	*(ns1__findEntitiesResponse*)p = *(ns1__findEntitiesResponse*)q;
}

void ns1__findEntities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__findEntities::property = NULL;
	this->ns1__findEntities::searchString = NULL;
	soap_default_bool(soap, &this->ns1__findEntities::fullMatch);
	/* transient soap skipped */
}

void ns1__findEntities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__entityProperty(soap, &this->ns1__findEntities::property);
	soap_serialize_PointerTostd__string(soap, &this->ns1__findEntities::searchString);
	/* transient soap skipped */
}

int ns1__findEntities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__findEntities);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__findEntities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__findEntities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__findEntities(struct soap *soap, const char *tag, int id, const ns1__findEntities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__findEntities), type))
		return soap->error;
	if (soap_out_PointerTons1__entityProperty(soap, "property", -1, &(a->ns1__findEntities::property), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "searchString", -1, &(a->ns1__findEntities::searchString), ""))
		return soap->error;
	if (soap_out_bool(soap, "fullMatch", -1, &(a->ns1__findEntities::fullMatch), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__findEntities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__findEntities(soap, this, tag, type);
}

SOAP_FMAC3 ns1__findEntities * SOAP_FMAC4 soap_get_ns1__findEntities(struct soap *soap, ns1__findEntities *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__findEntities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__findEntities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__findEntities(soap, tag, this, type);
}

SOAP_FMAC3 ns1__findEntities * SOAP_FMAC4 soap_in_ns1__findEntities(struct soap *soap, const char *tag, ns1__findEntities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__findEntities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__findEntities, sizeof(ns1__findEntities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__findEntities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__findEntities *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_property1 = 1;
	size_t soap_flag_searchString1 = 1;
	size_t soap_flag_fullMatch1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_property1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__entityProperty(soap, "property", &(a->ns1__findEntities::property), "ns1:entityProperty"))
				{	soap_flag_property1--;
					continue;
				}
			if (soap_flag_searchString1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "searchString", &(a->ns1__findEntities::searchString), "xsd:string"))
				{	soap_flag_searchString1--;
					continue;
				}
			if (soap_flag_fullMatch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "fullMatch", &(a->ns1__findEntities::fullMatch), "xsd:boolean"))
				{	soap_flag_fullMatch1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__findEntities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__findEntities, 0, sizeof(ns1__findEntities), 0, soap_copy_ns1__findEntities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fullMatch1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__findEntities * SOAP_FMAC6 soap_new_ns1__findEntities(struct soap *soap, int n)
{	return soap_instantiate_ns1__findEntities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__findEntities(struct soap *soap, ns1__findEntities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__findEntities * SOAP_FMAC4 soap_instantiate_ns1__findEntities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__findEntities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__findEntities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__findEntities;
		if (size)
			*size = sizeof(ns1__findEntities);
		((ns1__findEntities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__findEntities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__findEntities);
		for (int i = 0; i < n; i++)
			((ns1__findEntities*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__findEntities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__findEntities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__findEntities %p -> %p\n", q, p));
	*(ns1__findEntities*)p = *(ns1__findEntities*)q;
}

void ns1__exportHierarchyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__exportHierarchyResponse::return_);
	/* transient soap skipped */
}

void ns1__exportHierarchyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__exportHierarchyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__exportHierarchyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__exportHierarchyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__exportHierarchyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__exportHierarchyResponse(struct soap *soap, const char *tag, int id, const ns1__exportHierarchyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__exportHierarchyResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__exportHierarchyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__exportHierarchyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__exportHierarchyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__exportHierarchyResponse * SOAP_FMAC4 soap_get_ns1__exportHierarchyResponse(struct soap *soap, ns1__exportHierarchyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__exportHierarchyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__exportHierarchyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__exportHierarchyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__exportHierarchyResponse * SOAP_FMAC4 soap_in_ns1__exportHierarchyResponse(struct soap *soap, const char *tag, ns1__exportHierarchyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__exportHierarchyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__exportHierarchyResponse, sizeof(ns1__exportHierarchyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__exportHierarchyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__exportHierarchyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__exportHierarchyResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__exportHierarchyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__exportHierarchyResponse, 0, sizeof(ns1__exportHierarchyResponse), 0, soap_copy_ns1__exportHierarchyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__exportHierarchyResponse * SOAP_FMAC6 soap_new_ns1__exportHierarchyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__exportHierarchyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__exportHierarchyResponse(struct soap *soap, ns1__exportHierarchyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__exportHierarchyResponse * SOAP_FMAC4 soap_instantiate_ns1__exportHierarchyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__exportHierarchyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__exportHierarchyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__exportHierarchyResponse;
		if (size)
			*size = sizeof(ns1__exportHierarchyResponse);
		((ns1__exportHierarchyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__exportHierarchyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__exportHierarchyResponse);
		for (int i = 0; i < n; i++)
			((ns1__exportHierarchyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__exportHierarchyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__exportHierarchyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__exportHierarchyResponse %p -> %p\n", q, p));
	*(ns1__exportHierarchyResponse*)p = *(ns1__exportHierarchyResponse*)q;
}

void ns1__exportHierarchy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__exportHierarchy::filePath = NULL;
	/* transient soap skipped */
}

void ns1__exportHierarchy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__exportHierarchy::filePath);
	/* transient soap skipped */
}

int ns1__exportHierarchy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__exportHierarchy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__exportHierarchy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__exportHierarchy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__exportHierarchy(struct soap *soap, const char *tag, int id, const ns1__exportHierarchy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__exportHierarchy), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "filePath", -1, &(a->ns1__exportHierarchy::filePath), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__exportHierarchy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__exportHierarchy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__exportHierarchy * SOAP_FMAC4 soap_get_ns1__exportHierarchy(struct soap *soap, ns1__exportHierarchy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__exportHierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__exportHierarchy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__exportHierarchy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__exportHierarchy * SOAP_FMAC4 soap_in_ns1__exportHierarchy(struct soap *soap, const char *tag, ns1__exportHierarchy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__exportHierarchy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__exportHierarchy, sizeof(ns1__exportHierarchy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__exportHierarchy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__exportHierarchy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_filePath1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "filePath", &(a->ns1__exportHierarchy::filePath), "xsd:string"))
				{	soap_flag_filePath1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__exportHierarchy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__exportHierarchy, 0, sizeof(ns1__exportHierarchy), 0, soap_copy_ns1__exportHierarchy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__exportHierarchy * SOAP_FMAC6 soap_new_ns1__exportHierarchy(struct soap *soap, int n)
{	return soap_instantiate_ns1__exportHierarchy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__exportHierarchy(struct soap *soap, ns1__exportHierarchy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__exportHierarchy * SOAP_FMAC4 soap_instantiate_ns1__exportHierarchy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__exportHierarchy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__exportHierarchy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__exportHierarchy;
		if (size)
			*size = sizeof(ns1__exportHierarchy);
		((ns1__exportHierarchy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__exportHierarchy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__exportHierarchy);
		for (int i = 0; i < n; i++)
			((ns1__exportHierarchy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__exportHierarchy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__exportHierarchy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__exportHierarchy %p -> %p\n", q, p));
	*(ns1__exportHierarchy*)p = *(ns1__exportHierarchy*)q;
}

void ns1__enumerateEventHandlersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__enumerateEventHandlersResponse::return_);
	/* transient soap skipped */
}

void ns1__enumerateEventHandlersResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__enumerateEventHandlersResponse::return_);
	/* transient soap skipped */
}

int ns1__enumerateEventHandlersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumerateEventHandlersResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumerateEventHandlersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumerateEventHandlersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumerateEventHandlersResponse(struct soap *soap, const char *tag, int id, const ns1__enumerateEventHandlersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumerateEventHandlersResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "return", -1, &(a->ns1__enumerateEventHandlersResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumerateEventHandlersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumerateEventHandlersResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumerateEventHandlersResponse * SOAP_FMAC4 soap_get_ns1__enumerateEventHandlersResponse(struct soap *soap, ns1__enumerateEventHandlersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumerateEventHandlersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumerateEventHandlersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumerateEventHandlersResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumerateEventHandlersResponse * SOAP_FMAC4 soap_in_ns1__enumerateEventHandlersResponse(struct soap *soap, const char *tag, ns1__enumerateEventHandlersResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumerateEventHandlersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumerateEventHandlersResponse, sizeof(ns1__enumerateEventHandlersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumerateEventHandlersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumerateEventHandlersResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "return", &(a->ns1__enumerateEventHandlersResponse::return_), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumerateEventHandlersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumerateEventHandlersResponse, 0, sizeof(ns1__enumerateEventHandlersResponse), 0, soap_copy_ns1__enumerateEventHandlersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumerateEventHandlersResponse * SOAP_FMAC6 soap_new_ns1__enumerateEventHandlersResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumerateEventHandlersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumerateEventHandlersResponse(struct soap *soap, ns1__enumerateEventHandlersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumerateEventHandlersResponse * SOAP_FMAC4 soap_instantiate_ns1__enumerateEventHandlersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumerateEventHandlersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumerateEventHandlersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumerateEventHandlersResponse;
		if (size)
			*size = sizeof(ns1__enumerateEventHandlersResponse);
		((ns1__enumerateEventHandlersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumerateEventHandlersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumerateEventHandlersResponse);
		for (int i = 0; i < n; i++)
			((ns1__enumerateEventHandlersResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumerateEventHandlersResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumerateEventHandlersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumerateEventHandlersResponse %p -> %p\n", q, p));
	*(ns1__enumerateEventHandlersResponse*)p = *(ns1__enumerateEventHandlersResponse*)q;
}

void ns1__enumerateEventHandlers::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void ns1__enumerateEventHandlers::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__enumerateEventHandlers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumerateEventHandlers);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumerateEventHandlers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumerateEventHandlers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumerateEventHandlers(struct soap *soap, const char *tag, int id, const ns1__enumerateEventHandlers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumerateEventHandlers), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumerateEventHandlers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumerateEventHandlers(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumerateEventHandlers * SOAP_FMAC4 soap_get_ns1__enumerateEventHandlers(struct soap *soap, ns1__enumerateEventHandlers *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumerateEventHandlers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumerateEventHandlers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumerateEventHandlers(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumerateEventHandlers * SOAP_FMAC4 soap_in_ns1__enumerateEventHandlers(struct soap *soap, const char *tag, ns1__enumerateEventHandlers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumerateEventHandlers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumerateEventHandlers, sizeof(ns1__enumerateEventHandlers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumerateEventHandlers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumerateEventHandlers *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumerateEventHandlers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumerateEventHandlers, 0, sizeof(ns1__enumerateEventHandlers), 0, soap_copy_ns1__enumerateEventHandlers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumerateEventHandlers * SOAP_FMAC6 soap_new_ns1__enumerateEventHandlers(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumerateEventHandlers(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumerateEventHandlers(struct soap *soap, ns1__enumerateEventHandlers *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumerateEventHandlers * SOAP_FMAC4 soap_instantiate_ns1__enumerateEventHandlers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumerateEventHandlers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumerateEventHandlers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumerateEventHandlers;
		if (size)
			*size = sizeof(ns1__enumerateEventHandlers);
		((ns1__enumerateEventHandlers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumerateEventHandlers[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumerateEventHandlers);
		for (int i = 0; i < n; i++)
			((ns1__enumerateEventHandlers*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumerateEventHandlers*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumerateEventHandlers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumerateEventHandlers %p -> %p\n", q, p));
	*(ns1__enumerateEventHandlers*)p = *(ns1__enumerateEventHandlers*)q;
}

void ns1__aggregationPeriod::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__aggregationPeriod::end = NULL;
	this->ns1__aggregationPeriod::start = NULL;
	soap_default_int(soap, &this->ns1__aggregationPeriod::value);
	/* transient soap skipped */
}

void ns1__aggregationPeriod::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__aggregationPeriod::end);
	soap_serialize_PointerTotime(soap, &this->ns1__aggregationPeriod::start);
	/* transient soap skipped */
}

int ns1__aggregationPeriod::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__aggregationPeriod);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__aggregationPeriod::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__aggregationPeriod(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__aggregationPeriod(struct soap *soap, const char *tag, int id, const ns1__aggregationPeriod *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__aggregationPeriod), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "end", -1, &(a->ns1__aggregationPeriod::end), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "start", -1, &(a->ns1__aggregationPeriod::start), ""))
		return soap->error;
	if (soap_out_int(soap, "value", -1, &(a->ns1__aggregationPeriod::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__aggregationPeriod::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__aggregationPeriod(soap, this, tag, type);
}

SOAP_FMAC3 ns1__aggregationPeriod * SOAP_FMAC4 soap_get_ns1__aggregationPeriod(struct soap *soap, ns1__aggregationPeriod *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__aggregationPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__aggregationPeriod::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__aggregationPeriod(soap, tag, this, type);
}

SOAP_FMAC3 ns1__aggregationPeriod * SOAP_FMAC4 soap_in_ns1__aggregationPeriod(struct soap *soap, const char *tag, ns1__aggregationPeriod *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__aggregationPeriod *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__aggregationPeriod, sizeof(ns1__aggregationPeriod), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__aggregationPeriod)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__aggregationPeriod *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_end1 = 1;
	size_t soap_flag_start1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_end1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "end", &(a->ns1__aggregationPeriod::end), "xsd:dateTime"))
				{	soap_flag_end1--;
					continue;
				}
			if (soap_flag_start1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "start", &(a->ns1__aggregationPeriod::start), "xsd:dateTime"))
				{	soap_flag_start1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "value", &(a->ns1__aggregationPeriod::value), "xsd:int"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__aggregationPeriod *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__aggregationPeriod, 0, sizeof(ns1__aggregationPeriod), 0, soap_copy_ns1__aggregationPeriod);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__aggregationPeriod * SOAP_FMAC6 soap_new_ns1__aggregationPeriod(struct soap *soap, int n)
{	return soap_instantiate_ns1__aggregationPeriod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__aggregationPeriod(struct soap *soap, ns1__aggregationPeriod *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__aggregationPeriod * SOAP_FMAC4 soap_instantiate_ns1__aggregationPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__aggregationPeriod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__aggregationPeriod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__aggregationPeriod;
		if (size)
			*size = sizeof(ns1__aggregationPeriod);
		((ns1__aggregationPeriod*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__aggregationPeriod[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__aggregationPeriod);
		for (int i = 0; i < n; i++)
			((ns1__aggregationPeriod*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__aggregationPeriod*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__aggregationPeriod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__aggregationPeriod %p -> %p\n", q, p));
	*(ns1__aggregationPeriod*)p = *(ns1__aggregationPeriod*)q;
}

void ns1__getQueryAggregationPeriodListResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, &this->ns1__getQueryAggregationPeriodListResponse::return_);
	/* transient soap skipped */
}

void ns1__getQueryAggregationPeriodListResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, &this->ns1__getQueryAggregationPeriodListResponse::return_);
	/* transient soap skipped */
}

int ns1__getQueryAggregationPeriodListResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getQueryAggregationPeriodListResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getQueryAggregationPeriodListResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getQueryAggregationPeriodListResponse(struct soap *soap, const char *tag, int id, const ns1__getQueryAggregationPeriodListResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, "return", -1, &(a->ns1__getQueryAggregationPeriodListResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getQueryAggregationPeriodListResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getQueryAggregationPeriodListResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodListResponse * SOAP_FMAC4 soap_get_ns1__getQueryAggregationPeriodListResponse(struct soap *soap, ns1__getQueryAggregationPeriodListResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getQueryAggregationPeriodListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getQueryAggregationPeriodListResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getQueryAggregationPeriodListResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodListResponse * SOAP_FMAC4 soap_in_ns1__getQueryAggregationPeriodListResponse(struct soap *soap, const char *tag, ns1__getQueryAggregationPeriodListResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getQueryAggregationPeriodListResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse, sizeof(ns1__getQueryAggregationPeriodListResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getQueryAggregationPeriodListResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, "return", &(a->ns1__getQueryAggregationPeriodListResponse::return_), "ns1:aggregationPeriod"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getQueryAggregationPeriodListResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse, 0, sizeof(ns1__getQueryAggregationPeriodListResponse), 0, soap_copy_ns1__getQueryAggregationPeriodListResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getQueryAggregationPeriodListResponse * SOAP_FMAC6 soap_new_ns1__getQueryAggregationPeriodListResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getQueryAggregationPeriodListResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getQueryAggregationPeriodListResponse(struct soap *soap, ns1__getQueryAggregationPeriodListResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodListResponse * SOAP_FMAC4 soap_instantiate_ns1__getQueryAggregationPeriodListResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getQueryAggregationPeriodListResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getQueryAggregationPeriodListResponse;
		if (size)
			*size = sizeof(ns1__getQueryAggregationPeriodListResponse);
		((ns1__getQueryAggregationPeriodListResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getQueryAggregationPeriodListResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getQueryAggregationPeriodListResponse);
		for (int i = 0; i < n; i++)
			((ns1__getQueryAggregationPeriodListResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getQueryAggregationPeriodListResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getQueryAggregationPeriodListResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getQueryAggregationPeriodListResponse %p -> %p\n", q, p));
	*(ns1__getQueryAggregationPeriodListResponse*)p = *(ns1__getQueryAggregationPeriodListResponse*)q;
}

void ns1__getQueryAggregationPeriodList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getQueryAggregationPeriodList::startTime = NULL;
	this->ns1__getQueryAggregationPeriodList::endTime = NULL;
	this->ns1__getQueryAggregationPeriodList::queryType = NULL;
	/* transient soap skipped */
}

void ns1__getQueryAggregationPeriodList::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__getQueryAggregationPeriodList::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__getQueryAggregationPeriodList::endTime);
	soap_serialize_PointerTons1__queryType(soap, &this->ns1__getQueryAggregationPeriodList::queryType);
	/* transient soap skipped */
}

int ns1__getQueryAggregationPeriodList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getQueryAggregationPeriodList);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getQueryAggregationPeriodList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getQueryAggregationPeriodList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getQueryAggregationPeriodList(struct soap *soap, const char *tag, int id, const ns1__getQueryAggregationPeriodList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getQueryAggregationPeriodList), type))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__getQueryAggregationPeriodList::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__getQueryAggregationPeriodList::endTime), ""))
		return soap->error;
	if (soap_out_PointerTons1__queryType(soap, "queryType", -1, &(a->ns1__getQueryAggregationPeriodList::queryType), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getQueryAggregationPeriodList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getQueryAggregationPeriodList(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodList * SOAP_FMAC4 soap_get_ns1__getQueryAggregationPeriodList(struct soap *soap, ns1__getQueryAggregationPeriodList *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getQueryAggregationPeriodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getQueryAggregationPeriodList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getQueryAggregationPeriodList(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodList * SOAP_FMAC4 soap_in_ns1__getQueryAggregationPeriodList(struct soap *soap, const char *tag, ns1__getQueryAggregationPeriodList *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getQueryAggregationPeriodList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getQueryAggregationPeriodList, sizeof(ns1__getQueryAggregationPeriodList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getQueryAggregationPeriodList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getQueryAggregationPeriodList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_endTime1 = 1;
	size_t soap_flag_queryType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__getQueryAggregationPeriodList::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__getQueryAggregationPeriodList::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_queryType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__queryType(soap, "queryType", &(a->ns1__getQueryAggregationPeriodList::queryType), "ns1:queryType"))
				{	soap_flag_queryType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getQueryAggregationPeriodList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getQueryAggregationPeriodList, 0, sizeof(ns1__getQueryAggregationPeriodList), 0, soap_copy_ns1__getQueryAggregationPeriodList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getQueryAggregationPeriodList * SOAP_FMAC6 soap_new_ns1__getQueryAggregationPeriodList(struct soap *soap, int n)
{	return soap_instantiate_ns1__getQueryAggregationPeriodList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getQueryAggregationPeriodList(struct soap *soap, ns1__getQueryAggregationPeriodList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodList * SOAP_FMAC4 soap_instantiate_ns1__getQueryAggregationPeriodList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getQueryAggregationPeriodList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getQueryAggregationPeriodList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getQueryAggregationPeriodList;
		if (size)
			*size = sizeof(ns1__getQueryAggregationPeriodList);
		((ns1__getQueryAggregationPeriodList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getQueryAggregationPeriodList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getQueryAggregationPeriodList);
		for (int i = 0; i < n; i++)
			((ns1__getQueryAggregationPeriodList*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getQueryAggregationPeriodList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getQueryAggregationPeriodList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getQueryAggregationPeriodList %p -> %p\n", q, p));
	*(ns1__getQueryAggregationPeriodList*)p = *(ns1__getQueryAggregationPeriodList*)q;
}

void ns1__isPolicyActiveResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->ns1__isPolicyActiveResponse::return_);
	/* transient soap skipped */
}

void ns1__isPolicyActiveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__isPolicyActiveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__isPolicyActiveResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__isPolicyActiveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__isPolicyActiveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__isPolicyActiveResponse(struct soap *soap, const char *tag, int id, const ns1__isPolicyActiveResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__isPolicyActiveResponse), type))
		return soap->error;
	if (soap_out_bool(soap, "return", -1, &(a->ns1__isPolicyActiveResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__isPolicyActiveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__isPolicyActiveResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__isPolicyActiveResponse * SOAP_FMAC4 soap_get_ns1__isPolicyActiveResponse(struct soap *soap, ns1__isPolicyActiveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__isPolicyActiveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__isPolicyActiveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__isPolicyActiveResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__isPolicyActiveResponse * SOAP_FMAC4 soap_in_ns1__isPolicyActiveResponse(struct soap *soap, const char *tag, ns1__isPolicyActiveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__isPolicyActiveResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__isPolicyActiveResponse, sizeof(ns1__isPolicyActiveResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__isPolicyActiveResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__isPolicyActiveResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "return", &(a->ns1__isPolicyActiveResponse::return_), "xsd:boolean"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__isPolicyActiveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__isPolicyActiveResponse, 0, sizeof(ns1__isPolicyActiveResponse), 0, soap_copy_ns1__isPolicyActiveResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__isPolicyActiveResponse * SOAP_FMAC6 soap_new_ns1__isPolicyActiveResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__isPolicyActiveResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__isPolicyActiveResponse(struct soap *soap, ns1__isPolicyActiveResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__isPolicyActiveResponse * SOAP_FMAC4 soap_instantiate_ns1__isPolicyActiveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__isPolicyActiveResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__isPolicyActiveResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__isPolicyActiveResponse;
		if (size)
			*size = sizeof(ns1__isPolicyActiveResponse);
		((ns1__isPolicyActiveResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__isPolicyActiveResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__isPolicyActiveResponse);
		for (int i = 0; i < n; i++)
			((ns1__isPolicyActiveResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__isPolicyActiveResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__isPolicyActiveResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__isPolicyActiveResponse %p -> %p\n", q, p));
	*(ns1__isPolicyActiveResponse*)p = *(ns1__isPolicyActiveResponse*)q;
}

void ns1__isPolicyActive::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__isPolicyActive::policyId);
	/* transient soap skipped */
}

void ns1__isPolicyActive::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__isPolicyActive::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__isPolicyActive);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__isPolicyActive::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__isPolicyActive(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__isPolicyActive(struct soap *soap, const char *tag, int id, const ns1__isPolicyActive *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__isPolicyActive), type))
		return soap->error;
	if (soap_out_int(soap, "policyId", -1, &(a->ns1__isPolicyActive::policyId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__isPolicyActive::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__isPolicyActive(soap, this, tag, type);
}

SOAP_FMAC3 ns1__isPolicyActive * SOAP_FMAC4 soap_get_ns1__isPolicyActive(struct soap *soap, ns1__isPolicyActive *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__isPolicyActive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__isPolicyActive::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__isPolicyActive(soap, tag, this, type);
}

SOAP_FMAC3 ns1__isPolicyActive * SOAP_FMAC4 soap_in_ns1__isPolicyActive(struct soap *soap, const char *tag, ns1__isPolicyActive *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__isPolicyActive *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__isPolicyActive, sizeof(ns1__isPolicyActive), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__isPolicyActive)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__isPolicyActive *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_policyId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_policyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "policyId", &(a->ns1__isPolicyActive::policyId), "xsd:int"))
				{	soap_flag_policyId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__isPolicyActive *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__isPolicyActive, 0, sizeof(ns1__isPolicyActive), 0, soap_copy_ns1__isPolicyActive);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_policyId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__isPolicyActive * SOAP_FMAC6 soap_new_ns1__isPolicyActive(struct soap *soap, int n)
{	return soap_instantiate_ns1__isPolicyActive(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__isPolicyActive(struct soap *soap, ns1__isPolicyActive *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__isPolicyActive * SOAP_FMAC4 soap_instantiate_ns1__isPolicyActive(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__isPolicyActive(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__isPolicyActive, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__isPolicyActive;
		if (size)
			*size = sizeof(ns1__isPolicyActive);
		((ns1__isPolicyActive*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__isPolicyActive[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__isPolicyActive);
		for (int i = 0; i < n; i++)
			((ns1__isPolicyActive*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__isPolicyActive*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__isPolicyActive(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__isPolicyActive %p -> %p\n", q, p));
	*(ns1__isPolicyActive*)p = *(ns1__isPolicyActive*)q;
}

void ns1__importHierarchyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__importHierarchyResponse::return_);
	/* transient soap skipped */
}

void ns1__importHierarchyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__importHierarchyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__importHierarchyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__importHierarchyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__importHierarchyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__importHierarchyResponse(struct soap *soap, const char *tag, int id, const ns1__importHierarchyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__importHierarchyResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__importHierarchyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__importHierarchyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__importHierarchyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__importHierarchyResponse * SOAP_FMAC4 soap_get_ns1__importHierarchyResponse(struct soap *soap, ns1__importHierarchyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__importHierarchyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__importHierarchyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__importHierarchyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__importHierarchyResponse * SOAP_FMAC4 soap_in_ns1__importHierarchyResponse(struct soap *soap, const char *tag, ns1__importHierarchyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__importHierarchyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__importHierarchyResponse, sizeof(ns1__importHierarchyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__importHierarchyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__importHierarchyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__importHierarchyResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__importHierarchyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__importHierarchyResponse, 0, sizeof(ns1__importHierarchyResponse), 0, soap_copy_ns1__importHierarchyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__importHierarchyResponse * SOAP_FMAC6 soap_new_ns1__importHierarchyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__importHierarchyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__importHierarchyResponse(struct soap *soap, ns1__importHierarchyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__importHierarchyResponse * SOAP_FMAC4 soap_instantiate_ns1__importHierarchyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__importHierarchyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__importHierarchyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__importHierarchyResponse;
		if (size)
			*size = sizeof(ns1__importHierarchyResponse);
		((ns1__importHierarchyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__importHierarchyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__importHierarchyResponse);
		for (int i = 0; i < n; i++)
			((ns1__importHierarchyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__importHierarchyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__importHierarchyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__importHierarchyResponse %p -> %p\n", q, p));
	*(ns1__importHierarchyResponse*)p = *(ns1__importHierarchyResponse*)q;
}

void ns1__importHierarchy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__importHierarchy::filePath = NULL;
	soap_default_bool(soap, &this->ns1__importHierarchy::forceAddition);
	/* transient soap skipped */
}

void ns1__importHierarchy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__importHierarchy::filePath);
	/* transient soap skipped */
}

int ns1__importHierarchy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__importHierarchy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__importHierarchy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__importHierarchy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__importHierarchy(struct soap *soap, const char *tag, int id, const ns1__importHierarchy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__importHierarchy), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "filePath", -1, &(a->ns1__importHierarchy::filePath), ""))
		return soap->error;
	if (soap_out_bool(soap, "forceAddition", -1, &(a->ns1__importHierarchy::forceAddition), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__importHierarchy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__importHierarchy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__importHierarchy * SOAP_FMAC4 soap_get_ns1__importHierarchy(struct soap *soap, ns1__importHierarchy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__importHierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__importHierarchy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__importHierarchy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__importHierarchy * SOAP_FMAC4 soap_in_ns1__importHierarchy(struct soap *soap, const char *tag, ns1__importHierarchy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__importHierarchy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__importHierarchy, sizeof(ns1__importHierarchy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__importHierarchy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__importHierarchy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_filePath1 = 1;
	size_t soap_flag_forceAddition1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_filePath1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "filePath", &(a->ns1__importHierarchy::filePath), "xsd:string"))
				{	soap_flag_filePath1--;
					continue;
				}
			if (soap_flag_forceAddition1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "forceAddition", &(a->ns1__importHierarchy::forceAddition), "xsd:boolean"))
				{	soap_flag_forceAddition1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__importHierarchy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__importHierarchy, 0, sizeof(ns1__importHierarchy), 0, soap_copy_ns1__importHierarchy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_forceAddition1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__importHierarchy * SOAP_FMAC6 soap_new_ns1__importHierarchy(struct soap *soap, int n)
{	return soap_instantiate_ns1__importHierarchy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__importHierarchy(struct soap *soap, ns1__importHierarchy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__importHierarchy * SOAP_FMAC4 soap_instantiate_ns1__importHierarchy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__importHierarchy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__importHierarchy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__importHierarchy;
		if (size)
			*size = sizeof(ns1__importHierarchy);
		((ns1__importHierarchy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__importHierarchy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__importHierarchy);
		for (int i = 0; i < n; i++)
			((ns1__importHierarchy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__importHierarchy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__importHierarchy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__importHierarchy %p -> %p\n", q, p));
	*(ns1__importHierarchy*)p = *(ns1__importHierarchy*)q;
}

void ns1__getNextDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getNextDataResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getNextDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumerationData(soap, &this->ns1__getNextDataResponse::return_);
	/* transient soap skipped */
}

int ns1__getNextDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getNextDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getNextDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getNextDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getNextDataResponse(struct soap *soap, const char *tag, int id, const ns1__getNextDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getNextDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__enumerationData(soap, "return", -1, &(a->ns1__getNextDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getNextDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getNextDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getNextDataResponse * SOAP_FMAC4 soap_get_ns1__getNextDataResponse(struct soap *soap, ns1__getNextDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getNextDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getNextDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getNextDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getNextDataResponse * SOAP_FMAC4 soap_in_ns1__getNextDataResponse(struct soap *soap, const char *tag, ns1__getNextDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getNextDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getNextDataResponse, sizeof(ns1__getNextDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getNextDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getNextDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumerationData(soap, "return", &(a->ns1__getNextDataResponse::return_), "ns1:enumerationData"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getNextDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getNextDataResponse, 0, sizeof(ns1__getNextDataResponse), 0, soap_copy_ns1__getNextDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getNextDataResponse * SOAP_FMAC6 soap_new_ns1__getNextDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getNextDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getNextDataResponse(struct soap *soap, ns1__getNextDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getNextDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getNextDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getNextDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getNextDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getNextDataResponse;
		if (size)
			*size = sizeof(ns1__getNextDataResponse);
		((ns1__getNextDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getNextDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getNextDataResponse);
		for (int i = 0; i < n; i++)
			((ns1__getNextDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getNextDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getNextDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getNextDataResponse %p -> %p\n", q, p));
	*(ns1__getNextDataResponse*)p = *(ns1__getNextDataResponse*)q;
}

void ns1__getNextData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getNextData::enumerationHandle);
	/* transient soap skipped */
}

void ns1__getNextData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__getNextData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getNextData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getNextData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getNextData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getNextData(struct soap *soap, const char *tag, int id, const ns1__getNextData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getNextData), type))
		return soap->error;
	if (soap_out_int(soap, "enumerationHandle", -1, &(a->ns1__getNextData::enumerationHandle), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getNextData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getNextData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getNextData * SOAP_FMAC4 soap_get_ns1__getNextData(struct soap *soap, ns1__getNextData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getNextData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getNextData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getNextData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getNextData * SOAP_FMAC4 soap_in_ns1__getNextData(struct soap *soap, const char *tag, ns1__getNextData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getNextData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getNextData, sizeof(ns1__getNextData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getNextData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getNextData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enumerationHandle1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enumerationHandle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "enumerationHandle", &(a->ns1__getNextData::enumerationHandle), "xsd:int"))
				{	soap_flag_enumerationHandle1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getNextData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getNextData, 0, sizeof(ns1__getNextData), 0, soap_copy_ns1__getNextData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enumerationHandle1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getNextData * SOAP_FMAC6 soap_new_ns1__getNextData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getNextData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getNextData(struct soap *soap, ns1__getNextData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getNextData * SOAP_FMAC4 soap_instantiate_ns1__getNextData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getNextData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getNextData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getNextData;
		if (size)
			*size = sizeof(ns1__getNextData);
		((ns1__getNextData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getNextData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getNextData);
		for (int i = 0; i < n; i++)
			((ns1__getNextData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getNextData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getNextData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getNextData %p -> %p\n", q, p));
	*(ns1__getNextData*)p = *(ns1__getNextData*)q;
}

void ns1__schedulePolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__schedulePolicyResponse::return_);
	/* transient soap skipped */
}

void ns1__schedulePolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__schedulePolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__schedulePolicyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__schedulePolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__schedulePolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__schedulePolicyResponse(struct soap *soap, const char *tag, int id, const ns1__schedulePolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__schedulePolicyResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__schedulePolicyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__schedulePolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__schedulePolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__schedulePolicyResponse * SOAP_FMAC4 soap_get_ns1__schedulePolicyResponse(struct soap *soap, ns1__schedulePolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__schedulePolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__schedulePolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__schedulePolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__schedulePolicyResponse * SOAP_FMAC4 soap_in_ns1__schedulePolicyResponse(struct soap *soap, const char *tag, ns1__schedulePolicyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__schedulePolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__schedulePolicyResponse, sizeof(ns1__schedulePolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__schedulePolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__schedulePolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__schedulePolicyResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__schedulePolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__schedulePolicyResponse, 0, sizeof(ns1__schedulePolicyResponse), 0, soap_copy_ns1__schedulePolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__schedulePolicyResponse * SOAP_FMAC6 soap_new_ns1__schedulePolicyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__schedulePolicyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__schedulePolicyResponse(struct soap *soap, ns1__schedulePolicyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__schedulePolicyResponse * SOAP_FMAC4 soap_instantiate_ns1__schedulePolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__schedulePolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__schedulePolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__schedulePolicyResponse;
		if (size)
			*size = sizeof(ns1__schedulePolicyResponse);
		((ns1__schedulePolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__schedulePolicyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__schedulePolicyResponse);
		for (int i = 0; i < n; i++)
			((ns1__schedulePolicyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__schedulePolicyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__schedulePolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__schedulePolicyResponse %p -> %p\n", q, p));
	*(ns1__schedulePolicyResponse*)p = *(ns1__schedulePolicyResponse*)q;
}

void ns1__schedulePolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__schedulePolicy::policyId);
	this->ns1__schedulePolicy::startTime = NULL;
	this->ns1__schedulePolicy::endTime = NULL;
	soap_default_int(soap, &this->ns1__schedulePolicy::startHour);
	soap_default_int(soap, &this->ns1__schedulePolicy::endHour);
	soap_default_std__vectorTemplateOfns1__day(soap, &this->ns1__schedulePolicy::days);
	/* transient soap skipped */
}

void ns1__schedulePolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__schedulePolicy::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__schedulePolicy::endTime);
	soap_serialize_std__vectorTemplateOfns1__day(soap, &this->ns1__schedulePolicy::days);
	/* transient soap skipped */
}

int ns1__schedulePolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__schedulePolicy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__schedulePolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__schedulePolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__schedulePolicy(struct soap *soap, const char *tag, int id, const ns1__schedulePolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__schedulePolicy), type))
		return soap->error;
	if (soap_out_int(soap, "policyId", -1, &(a->ns1__schedulePolicy::policyId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__schedulePolicy::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__schedulePolicy::endTime), ""))
		return soap->error;
	if (soap_out_int(soap, "startHour", -1, &(a->ns1__schedulePolicy::startHour), ""))
		return soap->error;
	if (soap_out_int(soap, "endHour", -1, &(a->ns1__schedulePolicy::endHour), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfns1__day(soap, "days", -1, &(a->ns1__schedulePolicy::days), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__schedulePolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__schedulePolicy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__schedulePolicy * SOAP_FMAC4 soap_get_ns1__schedulePolicy(struct soap *soap, ns1__schedulePolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__schedulePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__schedulePolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__schedulePolicy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__schedulePolicy * SOAP_FMAC4 soap_in_ns1__schedulePolicy(struct soap *soap, const char *tag, ns1__schedulePolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__schedulePolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__schedulePolicy, sizeof(ns1__schedulePolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__schedulePolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__schedulePolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_policyId1 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_endTime1 = 1;
	size_t soap_flag_startHour1 = 1;
	size_t soap_flag_endHour1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_policyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "policyId", &(a->ns1__schedulePolicy::policyId), "xsd:int"))
				{	soap_flag_policyId1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__schedulePolicy::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__schedulePolicy::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_startHour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "startHour", &(a->ns1__schedulePolicy::startHour), "xsd:int"))
				{	soap_flag_startHour1--;
					continue;
				}
			if (soap_flag_endHour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "endHour", &(a->ns1__schedulePolicy::endHour), "xsd:int"))
				{	soap_flag_endHour1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfns1__day(soap, "days", &(a->ns1__schedulePolicy::days), "ns1:day"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__schedulePolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__schedulePolicy, 0, sizeof(ns1__schedulePolicy), 0, soap_copy_ns1__schedulePolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_policyId1 > 0 || soap_flag_startHour1 > 0 || soap_flag_endHour1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__schedulePolicy * SOAP_FMAC6 soap_new_ns1__schedulePolicy(struct soap *soap, int n)
{	return soap_instantiate_ns1__schedulePolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__schedulePolicy(struct soap *soap, ns1__schedulePolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__schedulePolicy * SOAP_FMAC4 soap_instantiate_ns1__schedulePolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__schedulePolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__schedulePolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__schedulePolicy;
		if (size)
			*size = sizeof(ns1__schedulePolicy);
		((ns1__schedulePolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__schedulePolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__schedulePolicy);
		for (int i = 0; i < n; i++)
			((ns1__schedulePolicy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__schedulePolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__schedulePolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__schedulePolicy %p -> %p\n", q, p));
	*(ns1__schedulePolicy*)p = *(ns1__schedulePolicy*)q;
}

void ns1__setPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__setPolicyResponse::return_);
	/* transient soap skipped */
}

void ns1__setPolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__setPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setPolicyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setPolicyResponse(struct soap *soap, const char *tag, int id, const ns1__setPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setPolicyResponse), type))
		return soap->error;
	if (soap_out_int(soap, "return", -1, &(a->ns1__setPolicyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setPolicyResponse * SOAP_FMAC4 soap_get_ns1__setPolicyResponse(struct soap *soap, ns1__setPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setPolicyResponse * SOAP_FMAC4 soap_in_ns1__setPolicyResponse(struct soap *soap, const char *tag, ns1__setPolicyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setPolicyResponse, sizeof(ns1__setPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "return", &(a->ns1__setPolicyResponse::return_), "xsd:int"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setPolicyResponse, 0, sizeof(ns1__setPolicyResponse), 0, soap_copy_ns1__setPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setPolicyResponse * SOAP_FMAC6 soap_new_ns1__setPolicyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__setPolicyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setPolicyResponse(struct soap *soap, ns1__setPolicyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setPolicyResponse * SOAP_FMAC4 soap_instantiate_ns1__setPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setPolicyResponse;
		if (size)
			*size = sizeof(ns1__setPolicyResponse);
		((ns1__setPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setPolicyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setPolicyResponse);
		for (int i = 0; i < n; i++)
			((ns1__setPolicyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setPolicyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setPolicyResponse %p -> %p\n", q, p));
	*(ns1__setPolicyResponse*)p = *(ns1__setPolicyResponse*)q;
}

void ns1__setPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__setPolicy::entityId);
	this->ns1__setPolicy::policyType = NULL;
	soap_default_int(soap, &this->ns1__setPolicy::threshold);
	this->ns1__setPolicy::policyDescription = NULL;
	soap_default_bool(soap, &this->ns1__setPolicy::enabled);
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__setPolicy::lowPriorityList);
	soap_default_std__vectorTemplateOfint(soap, &this->ns1__setPolicy::highPriorityList);
	/* transient soap skipped */
}

void ns1__setPolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__policyType(soap, &this->ns1__setPolicy::policyType);
	soap_serialize_PointerTostd__string(soap, &this->ns1__setPolicy::policyDescription);
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__setPolicy::lowPriorityList);
	soap_serialize_std__vectorTemplateOfint(soap, &this->ns1__setPolicy::highPriorityList);
	/* transient soap skipped */
}

int ns1__setPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__setPolicy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__setPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__setPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__setPolicy(struct soap *soap, const char *tag, int id, const ns1__setPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__setPolicy), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__setPolicy::entityId), ""))
		return soap->error;
	if (soap_out_PointerTons1__policyType(soap, "policyType", -1, &(a->ns1__setPolicy::policyType), ""))
		return soap->error;
	if (soap_out_int(soap, "threshold", -1, &(a->ns1__setPolicy::threshold), ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "policyDescription", -1, &(a->ns1__setPolicy::policyDescription), ""))
		return soap->error;
	if (soap_out_bool(soap, "enabled", -1, &(a->ns1__setPolicy::enabled), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "lowPriorityList", -1, &(a->ns1__setPolicy::lowPriorityList), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfint(soap, "highPriorityList", -1, &(a->ns1__setPolicy::highPriorityList), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__setPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__setPolicy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__setPolicy * SOAP_FMAC4 soap_get_ns1__setPolicy(struct soap *soap, ns1__setPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__setPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__setPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__setPolicy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__setPolicy * SOAP_FMAC4 soap_in_ns1__setPolicy(struct soap *soap, const char *tag, ns1__setPolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__setPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__setPolicy, sizeof(ns1__setPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__setPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__setPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_policyType1 = 1;
	size_t soap_flag_threshold1 = 1;
	size_t soap_flag_policyDescription1 = 1;
	size_t soap_flag_enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__setPolicy::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_policyType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__policyType(soap, "policyType", &(a->ns1__setPolicy::policyType), "ns1:policyType"))
				{	soap_flag_policyType1--;
					continue;
				}
			if (soap_flag_threshold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "threshold", &(a->ns1__setPolicy::threshold), "xsd:int"))
				{	soap_flag_threshold1--;
					continue;
				}
			if (soap_flag_policyDescription1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "policyDescription", &(a->ns1__setPolicy::policyDescription), "xsd:string"))
				{	soap_flag_policyDescription1--;
					continue;
				}
			if (soap_flag_enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "enabled", &(a->ns1__setPolicy::enabled), "xsd:boolean"))
				{	soap_flag_enabled1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "lowPriorityList", &(a->ns1__setPolicy::lowPriorityList), "xsd:int"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfint(soap, "highPriorityList", &(a->ns1__setPolicy::highPriorityList), "xsd:int"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__setPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__setPolicy, 0, sizeof(ns1__setPolicy), 0, soap_copy_ns1__setPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_threshold1 > 0 || soap_flag_enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__setPolicy * SOAP_FMAC6 soap_new_ns1__setPolicy(struct soap *soap, int n)
{	return soap_instantiate_ns1__setPolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__setPolicy(struct soap *soap, ns1__setPolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__setPolicy * SOAP_FMAC4 soap_instantiate_ns1__setPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__setPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__setPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__setPolicy;
		if (size)
			*size = sizeof(ns1__setPolicy);
		((ns1__setPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__setPolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__setPolicy);
		for (int i = 0; i < n; i++)
			((ns1__setPolicy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__setPolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__setPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__setPolicy %p -> %p\n", q, p));
	*(ns1__setPolicy*)p = *(ns1__setPolicy*)q;
}

void ns1__ptData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__ptData::entityId);
	this->ns1__ptData::time = NULL;
	soap_default_int(soap, &this->ns1__ptData::value);
	/* transient soap skipped */
}

void ns1__ptData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__ptData::time);
	/* transient soap skipped */
}

int ns1__ptData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ptData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ptData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ptData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ptData(struct soap *soap, const char *tag, int id, const ns1__ptData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ptData), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__ptData::entityId), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "time", -1, &(a->ns1__ptData::time), ""))
		return soap->error;
	if (soap_out_int(soap, "value", -1, &(a->ns1__ptData::value), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__ptData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ptData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ptData * SOAP_FMAC4 soap_get_ns1__ptData(struct soap *soap, ns1__ptData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__ptData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ptData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ptData * SOAP_FMAC4 soap_in_ns1__ptData(struct soap *soap, const char *tag, ns1__ptData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ptData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ptData, sizeof(ns1__ptData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ptData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ptData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_time1 = 1;
	size_t soap_flag_value1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__ptData::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_time1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "time", &(a->ns1__ptData::time), "xsd:dateTime"))
				{	soap_flag_time1--;
					continue;
				}
			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "value", &(a->ns1__ptData::value), "xsd:int"))
				{	soap_flag_value1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ptData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ptData, 0, sizeof(ns1__ptData), 0, soap_copy_ns1__ptData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_value1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ptData * SOAP_FMAC6 soap_new_ns1__ptData(struct soap *soap, int n)
{	return soap_instantiate_ns1__ptData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ptData(struct soap *soap, ns1__ptData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ptData * SOAP_FMAC4 soap_instantiate_ns1__ptData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ptData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ptData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ptData;
		if (size)
			*size = sizeof(ns1__ptData);
		((ns1__ptData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ptData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ptData);
		for (int i = 0; i < n; i++)
			((ns1__ptData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ptData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ptData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ptData %p -> %p\n", q, p));
	*(ns1__ptData*)p = *(ns1__ptData*)q;
}

void ns1__enumerationData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__enumerationData::enumerationHandle);
	this->ns1__enumerationData::expirationDate = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__ptData(soap, &this->ns1__enumerationData::queryData);
	/* transient soap skipped */
}

void ns1__enumerationData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTotime(soap, &this->ns1__enumerationData::expirationDate);
	soap_serialize_std__vectorTemplateOfPointerTons1__ptData(soap, &this->ns1__enumerationData::queryData);
	/* transient soap skipped */
}

int ns1__enumerationData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__enumerationData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__enumerationData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__enumerationData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__enumerationData(struct soap *soap, const char *tag, int id, const ns1__enumerationData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__enumerationData), type))
		return soap->error;
	if (soap_out_int(soap, "enumerationHandle", -1, &(a->ns1__enumerationData::enumerationHandle), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "expirationDate", -1, &(a->ns1__enumerationData::expirationDate), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__ptData(soap, "queryData", -1, &(a->ns1__enumerationData::queryData), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__enumerationData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__enumerationData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__enumerationData * SOAP_FMAC4 soap_get_ns1__enumerationData(struct soap *soap, ns1__enumerationData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__enumerationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__enumerationData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__enumerationData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__enumerationData * SOAP_FMAC4 soap_in_ns1__enumerationData(struct soap *soap, const char *tag, ns1__enumerationData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__enumerationData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__enumerationData, sizeof(ns1__enumerationData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__enumerationData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__enumerationData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_enumerationHandle1 = 1;
	size_t soap_flag_expirationDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_enumerationHandle1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "enumerationHandle", &(a->ns1__enumerationData::enumerationHandle), "xsd:int"))
				{	soap_flag_enumerationHandle1--;
					continue;
				}
			if (soap_flag_expirationDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "expirationDate", &(a->ns1__enumerationData::expirationDate), "xsd:dateTime"))
				{	soap_flag_expirationDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__ptData(soap, "queryData", &(a->ns1__enumerationData::queryData), "ns1:ptData"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__enumerationData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__enumerationData, 0, sizeof(ns1__enumerationData), 0, soap_copy_ns1__enumerationData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_enumerationHandle1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__enumerationData * SOAP_FMAC6 soap_new_ns1__enumerationData(struct soap *soap, int n)
{	return soap_instantiate_ns1__enumerationData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__enumerationData(struct soap *soap, ns1__enumerationData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__enumerationData * SOAP_FMAC4 soap_instantiate_ns1__enumerationData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__enumerationData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__enumerationData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__enumerationData;
		if (size)
			*size = sizeof(ns1__enumerationData);
		((ns1__enumerationData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__enumerationData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__enumerationData);
		for (int i = 0; i < n; i++)
			((ns1__enumerationData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__enumerationData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__enumerationData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__enumerationData %p -> %p\n", q, p));
	*(ns1__enumerationData*)p = *(ns1__enumerationData*)q;
}

void ns1__getQueryDataResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__getQueryDataResponse::return_ = NULL;
	/* transient soap skipped */
}

void ns1__getQueryDataResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumerationData(soap, &this->ns1__getQueryDataResponse::return_);
	/* transient soap skipped */
}

int ns1__getQueryDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getQueryDataResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getQueryDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getQueryDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getQueryDataResponse(struct soap *soap, const char *tag, int id, const ns1__getQueryDataResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getQueryDataResponse), type))
		return soap->error;
	if (soap_out_PointerTons1__enumerationData(soap, "return", -1, &(a->ns1__getQueryDataResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getQueryDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getQueryDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getQueryDataResponse * SOAP_FMAC4 soap_get_ns1__getQueryDataResponse(struct soap *soap, ns1__getQueryDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getQueryDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getQueryDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getQueryDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getQueryDataResponse * SOAP_FMAC4 soap_in_ns1__getQueryDataResponse(struct soap *soap, const char *tag, ns1__getQueryDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getQueryDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getQueryDataResponse, sizeof(ns1__getQueryDataResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getQueryDataResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getQueryDataResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumerationData(soap, "return", &(a->ns1__getQueryDataResponse::return_), "ns1:enumerationData"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getQueryDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getQueryDataResponse, 0, sizeof(ns1__getQueryDataResponse), 0, soap_copy_ns1__getQueryDataResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getQueryDataResponse * SOAP_FMAC6 soap_new_ns1__getQueryDataResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__getQueryDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getQueryDataResponse(struct soap *soap, ns1__getQueryDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getQueryDataResponse * SOAP_FMAC4 soap_instantiate_ns1__getQueryDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getQueryDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getQueryDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getQueryDataResponse;
		if (size)
			*size = sizeof(ns1__getQueryDataResponse);
		((ns1__getQueryDataResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getQueryDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getQueryDataResponse);
		for (int i = 0; i < n; i++)
			((ns1__getQueryDataResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getQueryDataResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getQueryDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getQueryDataResponse %p -> %p\n", q, p));
	*(ns1__getQueryDataResponse*)p = *(ns1__getQueryDataResponse*)q;
}

void ns1__getQueryData::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__getQueryData::entityId);
	this->ns1__getQueryData::queryType = NULL;
	this->ns1__getQueryData::aggregationLevel = NULL;
	this->ns1__getQueryData::startTime = NULL;
	this->ns1__getQueryData::endTime = NULL;
	soap_default_int(soap, &this->ns1__getQueryData::aggPeriod);
	/* transient soap skipped */
}

void ns1__getQueryData::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__queryType(soap, &this->ns1__getQueryData::queryType);
	soap_serialize_PointerTons1__aggregationLevel(soap, &this->ns1__getQueryData::aggregationLevel);
	soap_serialize_PointerTotime(soap, &this->ns1__getQueryData::startTime);
	soap_serialize_PointerTotime(soap, &this->ns1__getQueryData::endTime);
	/* transient soap skipped */
}

int ns1__getQueryData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__getQueryData);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__getQueryData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__getQueryData(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__getQueryData(struct soap *soap, const char *tag, int id, const ns1__getQueryData *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__getQueryData), type))
		return soap->error;
	if (soap_out_int(soap, "entityId", -1, &(a->ns1__getQueryData::entityId), ""))
		return soap->error;
	if (soap_out_PointerTons1__queryType(soap, "queryType", -1, &(a->ns1__getQueryData::queryType), ""))
		return soap->error;
	if (soap_out_PointerTons1__aggregationLevel(soap, "aggregationLevel", -1, &(a->ns1__getQueryData::aggregationLevel), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "startTime", -1, &(a->ns1__getQueryData::startTime), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "endTime", -1, &(a->ns1__getQueryData::endTime), ""))
		return soap->error;
	if (soap_out_int(soap, "aggPeriod", -1, &(a->ns1__getQueryData::aggPeriod), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__getQueryData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__getQueryData(soap, this, tag, type);
}

SOAP_FMAC3 ns1__getQueryData * SOAP_FMAC4 soap_get_ns1__getQueryData(struct soap *soap, ns1__getQueryData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__getQueryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__getQueryData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__getQueryData(soap, tag, this, type);
}

SOAP_FMAC3 ns1__getQueryData * SOAP_FMAC4 soap_in_ns1__getQueryData(struct soap *soap, const char *tag, ns1__getQueryData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__getQueryData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__getQueryData, sizeof(ns1__getQueryData), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__getQueryData)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__getQueryData *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_entityId1 = 1;
	size_t soap_flag_queryType1 = 1;
	size_t soap_flag_aggregationLevel1 = 1;
	size_t soap_flag_startTime1 = 1;
	size_t soap_flag_endTime1 = 1;
	size_t soap_flag_aggPeriod1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_entityId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "entityId", &(a->ns1__getQueryData::entityId), "xsd:int"))
				{	soap_flag_entityId1--;
					continue;
				}
			if (soap_flag_queryType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__queryType(soap, "queryType", &(a->ns1__getQueryData::queryType), "ns1:queryType"))
				{	soap_flag_queryType1--;
					continue;
				}
			if (soap_flag_aggregationLevel1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__aggregationLevel(soap, "aggregationLevel", &(a->ns1__getQueryData::aggregationLevel), "ns1:aggregationLevel"))
				{	soap_flag_aggregationLevel1--;
					continue;
				}
			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "startTime", &(a->ns1__getQueryData::startTime), "xsd:dateTime"))
				{	soap_flag_startTime1--;
					continue;
				}
			if (soap_flag_endTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "endTime", &(a->ns1__getQueryData::endTime), "xsd:dateTime"))
				{	soap_flag_endTime1--;
					continue;
				}
			if (soap_flag_aggPeriod1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "aggPeriod", &(a->ns1__getQueryData::aggPeriod), "xsd:int"))
				{	soap_flag_aggPeriod1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__getQueryData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__getQueryData, 0, sizeof(ns1__getQueryData), 0, soap_copy_ns1__getQueryData);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_entityId1 > 0 || soap_flag_aggPeriod1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__getQueryData * SOAP_FMAC6 soap_new_ns1__getQueryData(struct soap *soap, int n)
{	return soap_instantiate_ns1__getQueryData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__getQueryData(struct soap *soap, ns1__getQueryData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__getQueryData * SOAP_FMAC4 soap_instantiate_ns1__getQueryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__getQueryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__getQueryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__getQueryData;
		if (size)
			*size = sizeof(ns1__getQueryData);
		((ns1__getQueryData*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__getQueryData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__getQueryData);
		for (int i = 0; i < n; i++)
			((ns1__getQueryData*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__getQueryData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__getQueryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__getQueryData %p -> %p\n", q, p));
	*(ns1__getQueryData*)p = *(ns1__getQueryData*)q;
}

void ns1__Exception::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Exception::message = NULL;
	/* transient soap skipped */
}

void ns1__Exception::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__Exception::message);
	/* transient soap skipped */
}

int ns1__Exception::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__Exception);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__Exception::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Exception(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Exception(struct soap *soap, const char *tag, int id, const ns1__Exception *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Exception), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "message", -1, &(a->ns1__Exception::message), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__Exception::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Exception(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Exception * SOAP_FMAC4 soap_get_ns1__Exception(struct soap *soap, ns1__Exception *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Exception(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__Exception::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Exception(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Exception * SOAP_FMAC4 soap_in_ns1__Exception(struct soap *soap, const char *tag, ns1__Exception *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Exception *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Exception, sizeof(ns1__Exception), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__Exception)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__Exception *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_message1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_message1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "message", &(a->ns1__Exception::message), "xsd:string"))
				{	soap_flag_message1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__Exception *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Exception, 0, sizeof(ns1__Exception), 0, soap_copy_ns1__Exception);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__Exception * SOAP_FMAC6 soap_new_ns1__Exception(struct soap *soap, int n)
{	return soap_instantiate_ns1__Exception(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__Exception(struct soap *soap, ns1__Exception *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__Exception * SOAP_FMAC4 soap_instantiate_ns1__Exception(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Exception(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__Exception, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__Exception;
		if (size)
			*size = sizeof(ns1__Exception);
		((ns1__Exception*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__Exception[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__Exception);
		for (int i = 0; i < n; i++)
			((ns1__Exception*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__Exception*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__Exception(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__Exception %p -> %p\n", q, p));
	*(ns1__Exception*)p = *(ns1__Exception*)q;
}

void ns1__removePolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__byte(soap, &this->ns1__removePolicyResponse::return_);
	/* transient soap skipped */
}

void ns1__removePolicyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removePolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removePolicyResponse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__removePolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removePolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removePolicyResponse(struct soap *soap, const char *tag, int id, const ns1__removePolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removePolicyResponse), type))
		return soap->error;
	if (soap_out_xsd__byte(soap, "return", -1, &(a->ns1__removePolicyResponse::return_), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__removePolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removePolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removePolicyResponse * SOAP_FMAC4 soap_get_ns1__removePolicyResponse(struct soap *soap, ns1__removePolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removePolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__removePolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removePolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removePolicyResponse * SOAP_FMAC4 soap_in_ns1__removePolicyResponse(struct soap *soap, const char *tag, ns1__removePolicyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removePolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removePolicyResponse, sizeof(ns1__removePolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removePolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removePolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_return_1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__byte(soap, "return", &(a->ns1__removePolicyResponse::return_), "xsd:byte"))
				{	soap_flag_return_1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removePolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removePolicyResponse, 0, sizeof(ns1__removePolicyResponse), 0, soap_copy_ns1__removePolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_return_1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__removePolicyResponse * SOAP_FMAC6 soap_new_ns1__removePolicyResponse(struct soap *soap, int n)
{	return soap_instantiate_ns1__removePolicyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__removePolicyResponse(struct soap *soap, ns1__removePolicyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__removePolicyResponse * SOAP_FMAC4 soap_instantiate_ns1__removePolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removePolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removePolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__removePolicyResponse;
		if (size)
			*size = sizeof(ns1__removePolicyResponse);
		((ns1__removePolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__removePolicyResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removePolicyResponse);
		for (int i = 0; i < n; i++)
			((ns1__removePolicyResponse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removePolicyResponse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removePolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removePolicyResponse %p -> %p\n", q, p));
	*(ns1__removePolicyResponse*)p = *(ns1__removePolicyResponse*)q;
}

void ns1__removePolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__removePolicy::policyId);
	/* transient soap skipped */
}

void ns1__removePolicy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__removePolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__removePolicy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__removePolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__removePolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__removePolicy(struct soap *soap, const char *tag, int id, const ns1__removePolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__removePolicy), type))
		return soap->error;
	if (soap_out_int(soap, "policyId", -1, &(a->ns1__removePolicy::policyId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__removePolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__removePolicy(soap, this, tag, type);
}

SOAP_FMAC3 ns1__removePolicy * SOAP_FMAC4 soap_get_ns1__removePolicy(struct soap *soap, ns1__removePolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__removePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *ns1__removePolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__removePolicy(soap, tag, this, type);
}

SOAP_FMAC3 ns1__removePolicy * SOAP_FMAC4 soap_in_ns1__removePolicy(struct soap *soap, const char *tag, ns1__removePolicy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__removePolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__removePolicy, sizeof(ns1__removePolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__removePolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__removePolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_policyId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_policyId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "policyId", &(a->ns1__removePolicy::policyId), "xsd:int"))
				{	soap_flag_policyId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__removePolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__removePolicy, 0, sizeof(ns1__removePolicy), 0, soap_copy_ns1__removePolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_policyId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__removePolicy * SOAP_FMAC6 soap_new_ns1__removePolicy(struct soap *soap, int n)
{	return soap_instantiate_ns1__removePolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__removePolicy(struct soap *soap, ns1__removePolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__removePolicy * SOAP_FMAC4 soap_instantiate_ns1__removePolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__removePolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__removePolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__removePolicy;
		if (size)
			*size = sizeof(ns1__removePolicy);
		((ns1__removePolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__removePolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__removePolicy);
		for (int i = 0; i < n; i++)
			((ns1__removePolicy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__removePolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__removePolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__removePolicy %p -> %p\n", q, p));
	*(ns1__removePolicy*)p = *(ns1__removePolicy*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateCustomEvent(struct soap *soap, struct __ns1__updateCustomEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateCustomEvent_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateCustomEvent(struct soap *soap, const struct __ns1__updateCustomEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateCustomEvent(soap, &a->ns1__updateCustomEvent_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateCustomEvent(struct soap *soap, const struct __ns1__updateCustomEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateCustomEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateCustomEvent(struct soap *soap, const char *tag, int id, const struct __ns1__updateCustomEvent *a, const char *type)
{
	if (soap_out_PointerTons1__updateCustomEvent(soap, "ns1:updateCustomEvent", -1, &a->ns1__updateCustomEvent_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateCustomEvent * SOAP_FMAC4 soap_get___ns1__updateCustomEvent(struct soap *soap, struct __ns1__updateCustomEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__updateCustomEvent * SOAP_FMAC4 soap_in___ns1__updateCustomEvent(struct soap *soap, const char *tag, struct __ns1__updateCustomEvent *a, const char *type)
{
	size_t soap_flag_ns1__updateCustomEvent_ = 1;
	short soap_flag;
	a = (struct __ns1__updateCustomEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateCustomEvent, sizeof(struct __ns1__updateCustomEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateCustomEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateCustomEvent_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateCustomEvent(soap, "ns1:updateCustomEvent", &a->ns1__updateCustomEvent_, "ns1:updateCustomEvent"))
				{	soap_flag_ns1__updateCustomEvent_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__updateCustomEvent * SOAP_FMAC6 soap_new___ns1__updateCustomEvent(struct soap *soap, int n)
{	return soap_instantiate___ns1__updateCustomEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__updateCustomEvent(struct soap *soap, struct __ns1__updateCustomEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__updateCustomEvent * SOAP_FMAC4 soap_instantiate___ns1__updateCustomEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateCustomEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateCustomEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__updateCustomEvent;
		if (size)
			*size = sizeof(struct __ns1__updateCustomEvent);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__updateCustomEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateCustomEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateCustomEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateCustomEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateCustomEvent %p -> %p\n", q, p));
	*(struct __ns1__updateCustomEvent*)p = *(struct __ns1__updateCustomEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__unsubscribePredefinedEvent(struct soap *soap, struct __ns1__unsubscribePredefinedEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__unsubscribePredefinedEvent_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__unsubscribePredefinedEvent(struct soap *soap, const struct __ns1__unsubscribePredefinedEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__unsubscribePredefinedEvent(soap, &a->ns1__unsubscribePredefinedEvent_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__unsubscribePredefinedEvent(struct soap *soap, const struct __ns1__unsubscribePredefinedEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__unsubscribePredefinedEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__unsubscribePredefinedEvent(struct soap *soap, const char *tag, int id, const struct __ns1__unsubscribePredefinedEvent *a, const char *type)
{
	if (soap_out_PointerTons1__unsubscribePredefinedEvent(soap, "ns1:unsubscribePredefinedEvent", -1, &a->ns1__unsubscribePredefinedEvent_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unsubscribePredefinedEvent * SOAP_FMAC4 soap_get___ns1__unsubscribePredefinedEvent(struct soap *soap, struct __ns1__unsubscribePredefinedEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__unsubscribePredefinedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__unsubscribePredefinedEvent * SOAP_FMAC4 soap_in___ns1__unsubscribePredefinedEvent(struct soap *soap, const char *tag, struct __ns1__unsubscribePredefinedEvent *a, const char *type)
{
	size_t soap_flag_ns1__unsubscribePredefinedEvent_ = 1;
	short soap_flag;
	a = (struct __ns1__unsubscribePredefinedEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__unsubscribePredefinedEvent, sizeof(struct __ns1__unsubscribePredefinedEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__unsubscribePredefinedEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__unsubscribePredefinedEvent_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__unsubscribePredefinedEvent(soap, "ns1:unsubscribePredefinedEvent", &a->ns1__unsubscribePredefinedEvent_, "ns1:unsubscribePredefinedEvent"))
				{	soap_flag_ns1__unsubscribePredefinedEvent_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__unsubscribePredefinedEvent * SOAP_FMAC6 soap_new___ns1__unsubscribePredefinedEvent(struct soap *soap, int n)
{	return soap_instantiate___ns1__unsubscribePredefinedEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__unsubscribePredefinedEvent(struct soap *soap, struct __ns1__unsubscribePredefinedEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__unsubscribePredefinedEvent * SOAP_FMAC4 soap_instantiate___ns1__unsubscribePredefinedEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__unsubscribePredefinedEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__unsubscribePredefinedEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__unsubscribePredefinedEvent;
		if (size)
			*size = sizeof(struct __ns1__unsubscribePredefinedEvent);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__unsubscribePredefinedEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__unsubscribePredefinedEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__unsubscribePredefinedEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__unsubscribePredefinedEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__unsubscribePredefinedEvent %p -> %p\n", q, p));
	*(struct __ns1__unsubscribePredefinedEvent*)p = *(struct __ns1__unsubscribePredefinedEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__unsubscribeEventHandler(struct soap *soap, struct __ns1__unsubscribeEventHandler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__unsubscribeEventHandler_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__unsubscribeEventHandler(struct soap *soap, const struct __ns1__unsubscribeEventHandler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__unsubscribeEventHandler(soap, &a->ns1__unsubscribeEventHandler_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__unsubscribeEventHandler(struct soap *soap, const struct __ns1__unsubscribeEventHandler *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__unsubscribeEventHandler(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__unsubscribeEventHandler(struct soap *soap, const char *tag, int id, const struct __ns1__unsubscribeEventHandler *a, const char *type)
{
	if (soap_out_PointerTons1__unsubscribeEventHandler(soap, "ns1:unsubscribeEventHandler", -1, &a->ns1__unsubscribeEventHandler_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__unsubscribeEventHandler * SOAP_FMAC4 soap_get___ns1__unsubscribeEventHandler(struct soap *soap, struct __ns1__unsubscribeEventHandler *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__unsubscribeEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__unsubscribeEventHandler * SOAP_FMAC4 soap_in___ns1__unsubscribeEventHandler(struct soap *soap, const char *tag, struct __ns1__unsubscribeEventHandler *a, const char *type)
{
	size_t soap_flag_ns1__unsubscribeEventHandler_ = 1;
	short soap_flag;
	a = (struct __ns1__unsubscribeEventHandler *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__unsubscribeEventHandler, sizeof(struct __ns1__unsubscribeEventHandler), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__unsubscribeEventHandler(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__unsubscribeEventHandler_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__unsubscribeEventHandler(soap, "ns1:unsubscribeEventHandler", &a->ns1__unsubscribeEventHandler_, "ns1:unsubscribeEventHandler"))
				{	soap_flag_ns1__unsubscribeEventHandler_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__unsubscribeEventHandler * SOAP_FMAC6 soap_new___ns1__unsubscribeEventHandler(struct soap *soap, int n)
{	return soap_instantiate___ns1__unsubscribeEventHandler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__unsubscribeEventHandler(struct soap *soap, struct __ns1__unsubscribeEventHandler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__unsubscribeEventHandler * SOAP_FMAC4 soap_instantiate___ns1__unsubscribeEventHandler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__unsubscribeEventHandler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__unsubscribeEventHandler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__unsubscribeEventHandler;
		if (size)
			*size = sizeof(struct __ns1__unsubscribeEventHandler);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__unsubscribeEventHandler[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__unsubscribeEventHandler);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__unsubscribeEventHandler*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__unsubscribeEventHandler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__unsubscribeEventHandler %p -> %p\n", q, p));
	*(struct __ns1__unsubscribeEventHandler*)p = *(struct __ns1__unsubscribeEventHandler*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__subscribePredefinedEvent(struct soap *soap, struct __ns1__subscribePredefinedEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__subscribePredefinedEvent_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__subscribePredefinedEvent(struct soap *soap, const struct __ns1__subscribePredefinedEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__subscribePredefinedEvent(soap, &a->ns1__subscribePredefinedEvent_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__subscribePredefinedEvent(struct soap *soap, const struct __ns1__subscribePredefinedEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__subscribePredefinedEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__subscribePredefinedEvent(struct soap *soap, const char *tag, int id, const struct __ns1__subscribePredefinedEvent *a, const char *type)
{
	if (soap_out_PointerTons1__subscribePredefinedEvent(soap, "ns1:subscribePredefinedEvent", -1, &a->ns1__subscribePredefinedEvent_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribePredefinedEvent * SOAP_FMAC4 soap_get___ns1__subscribePredefinedEvent(struct soap *soap, struct __ns1__subscribePredefinedEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__subscribePredefinedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__subscribePredefinedEvent * SOAP_FMAC4 soap_in___ns1__subscribePredefinedEvent(struct soap *soap, const char *tag, struct __ns1__subscribePredefinedEvent *a, const char *type)
{
	size_t soap_flag_ns1__subscribePredefinedEvent_ = 1;
	short soap_flag;
	a = (struct __ns1__subscribePredefinedEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__subscribePredefinedEvent, sizeof(struct __ns1__subscribePredefinedEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__subscribePredefinedEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__subscribePredefinedEvent_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__subscribePredefinedEvent(soap, "ns1:subscribePredefinedEvent", &a->ns1__subscribePredefinedEvent_, "ns1:subscribePredefinedEvent"))
				{	soap_flag_ns1__subscribePredefinedEvent_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__subscribePredefinedEvent * SOAP_FMAC6 soap_new___ns1__subscribePredefinedEvent(struct soap *soap, int n)
{	return soap_instantiate___ns1__subscribePredefinedEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__subscribePredefinedEvent(struct soap *soap, struct __ns1__subscribePredefinedEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__subscribePredefinedEvent * SOAP_FMAC4 soap_instantiate___ns1__subscribePredefinedEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__subscribePredefinedEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__subscribePredefinedEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__subscribePredefinedEvent;
		if (size)
			*size = sizeof(struct __ns1__subscribePredefinedEvent);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__subscribePredefinedEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__subscribePredefinedEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__subscribePredefinedEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__subscribePredefinedEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__subscribePredefinedEvent %p -> %p\n", q, p));
	*(struct __ns1__subscribePredefinedEvent*)p = *(struct __ns1__subscribePredefinedEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__subscribeEventHandler(struct soap *soap, struct __ns1__subscribeEventHandler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__subscribeEventHandler_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__subscribeEventHandler(struct soap *soap, const struct __ns1__subscribeEventHandler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__subscribeEventHandler(soap, &a->ns1__subscribeEventHandler_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__subscribeEventHandler(struct soap *soap, const struct __ns1__subscribeEventHandler *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__subscribeEventHandler(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__subscribeEventHandler(struct soap *soap, const char *tag, int id, const struct __ns1__subscribeEventHandler *a, const char *type)
{
	if (soap_out_PointerTons1__subscribeEventHandler(soap, "ns1:subscribeEventHandler", -1, &a->ns1__subscribeEventHandler_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__subscribeEventHandler * SOAP_FMAC4 soap_get___ns1__subscribeEventHandler(struct soap *soap, struct __ns1__subscribeEventHandler *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__subscribeEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__subscribeEventHandler * SOAP_FMAC4 soap_in___ns1__subscribeEventHandler(struct soap *soap, const char *tag, struct __ns1__subscribeEventHandler *a, const char *type)
{
	size_t soap_flag_ns1__subscribeEventHandler_ = 1;
	short soap_flag;
	a = (struct __ns1__subscribeEventHandler *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__subscribeEventHandler, sizeof(struct __ns1__subscribeEventHandler), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__subscribeEventHandler(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__subscribeEventHandler_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__subscribeEventHandler(soap, "ns1:subscribeEventHandler", &a->ns1__subscribeEventHandler_, "ns1:subscribeEventHandler"))
				{	soap_flag_ns1__subscribeEventHandler_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__subscribeEventHandler * SOAP_FMAC6 soap_new___ns1__subscribeEventHandler(struct soap *soap, int n)
{	return soap_instantiate___ns1__subscribeEventHandler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__subscribeEventHandler(struct soap *soap, struct __ns1__subscribeEventHandler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__subscribeEventHandler * SOAP_FMAC4 soap_instantiate___ns1__subscribeEventHandler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__subscribeEventHandler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__subscribeEventHandler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__subscribeEventHandler;
		if (size)
			*size = sizeof(struct __ns1__subscribeEventHandler);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__subscribeEventHandler[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__subscribeEventHandler);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__subscribeEventHandler*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__subscribeEventHandler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__subscribeEventHandler %p -> %p\n", q, p));
	*(struct __ns1__subscribeEventHandler*)p = *(struct __ns1__subscribeEventHandler*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__submitSecretKey(struct soap *soap, struct __ns1__submitSecretKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__submitSecretKey_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__submitSecretKey(struct soap *soap, const struct __ns1__submitSecretKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__submitSecretKey(soap, &a->ns1__submitSecretKey_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__submitSecretKey(struct soap *soap, const struct __ns1__submitSecretKey *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__submitSecretKey(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__submitSecretKey(struct soap *soap, const char *tag, int id, const struct __ns1__submitSecretKey *a, const char *type)
{
	if (soap_out_PointerTons1__submitSecretKey(soap, "ns1:submitSecretKey", -1, &a->ns1__submitSecretKey_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__submitSecretKey * SOAP_FMAC4 soap_get___ns1__submitSecretKey(struct soap *soap, struct __ns1__submitSecretKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__submitSecretKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__submitSecretKey * SOAP_FMAC4 soap_in___ns1__submitSecretKey(struct soap *soap, const char *tag, struct __ns1__submitSecretKey *a, const char *type)
{
	size_t soap_flag_ns1__submitSecretKey_ = 1;
	short soap_flag;
	a = (struct __ns1__submitSecretKey *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__submitSecretKey, sizeof(struct __ns1__submitSecretKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__submitSecretKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__submitSecretKey_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__submitSecretKey(soap, "ns1:submitSecretKey", &a->ns1__submitSecretKey_, "ns1:submitSecretKey"))
				{	soap_flag_ns1__submitSecretKey_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__submitSecretKey * SOAP_FMAC6 soap_new___ns1__submitSecretKey(struct soap *soap, int n)
{	return soap_instantiate___ns1__submitSecretKey(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__submitSecretKey(struct soap *soap, struct __ns1__submitSecretKey *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__submitSecretKey * SOAP_FMAC4 soap_instantiate___ns1__submitSecretKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__submitSecretKey(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__submitSecretKey, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__submitSecretKey;
		if (size)
			*size = sizeof(struct __ns1__submitSecretKey);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__submitSecretKey[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__submitSecretKey);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__submitSecretKey*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__submitSecretKey(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__submitSecretKey %p -> %p\n", q, p));
	*(struct __ns1__submitSecretKey*)p = *(struct __ns1__submitSecretKey*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPolicyState(struct soap *soap, struct __ns1__setPolicyState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setPolicyState_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPolicyState(struct soap *soap, const struct __ns1__setPolicyState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setPolicyState(soap, &a->ns1__setPolicyState_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPolicyState(struct soap *soap, const struct __ns1__setPolicyState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPolicyState(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPolicyState(struct soap *soap, const char *tag, int id, const struct __ns1__setPolicyState *a, const char *type)
{
	if (soap_out_PointerTons1__setPolicyState(soap, "ns1:setPolicyState", -1, &a->ns1__setPolicyState_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPolicyState * SOAP_FMAC4 soap_get___ns1__setPolicyState(struct soap *soap, struct __ns1__setPolicyState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPolicyState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__setPolicyState * SOAP_FMAC4 soap_in___ns1__setPolicyState(struct soap *soap, const char *tag, struct __ns1__setPolicyState *a, const char *type)
{
	size_t soap_flag_ns1__setPolicyState_ = 1;
	short soap_flag;
	a = (struct __ns1__setPolicyState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPolicyState, sizeof(struct __ns1__setPolicyState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPolicyState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setPolicyState_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setPolicyState(soap, "ns1:setPolicyState", &a->ns1__setPolicyState_, "ns1:setPolicyState"))
				{	soap_flag_ns1__setPolicyState_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__setPolicyState * SOAP_FMAC6 soap_new___ns1__setPolicyState(struct soap *soap, int n)
{	return soap_instantiate___ns1__setPolicyState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__setPolicyState(struct soap *soap, struct __ns1__setPolicyState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__setPolicyState * SOAP_FMAC4 soap_instantiate___ns1__setPolicyState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setPolicyState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setPolicyState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__setPolicyState;
		if (size)
			*size = sizeof(struct __ns1__setPolicyState);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__setPolicyState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setPolicyState);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setPolicyState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setPolicyState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setPolicyState %p -> %p\n", q, p));
	*(struct __ns1__setPolicyState*)p = *(struct __ns1__setPolicyState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setGlobalProperty(struct soap *soap, struct __ns1__setGlobalProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setGlobalProperty_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setGlobalProperty(struct soap *soap, const struct __ns1__setGlobalProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setGlobalProperty(soap, &a->ns1__setGlobalProperty_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setGlobalProperty(struct soap *soap, const struct __ns1__setGlobalProperty *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setGlobalProperty(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setGlobalProperty(struct soap *soap, const char *tag, int id, const struct __ns1__setGlobalProperty *a, const char *type)
{
	if (soap_out_PointerTons1__setGlobalProperty(soap, "ns1:setGlobalProperty", -1, &a->ns1__setGlobalProperty_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setGlobalProperty * SOAP_FMAC4 soap_get___ns1__setGlobalProperty(struct soap *soap, struct __ns1__setGlobalProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setGlobalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__setGlobalProperty * SOAP_FMAC4 soap_in___ns1__setGlobalProperty(struct soap *soap, const char *tag, struct __ns1__setGlobalProperty *a, const char *type)
{
	size_t soap_flag_ns1__setGlobalProperty_ = 1;
	short soap_flag;
	a = (struct __ns1__setGlobalProperty *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setGlobalProperty, sizeof(struct __ns1__setGlobalProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setGlobalProperty(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setGlobalProperty_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setGlobalProperty(soap, "ns1:setGlobalProperty", &a->ns1__setGlobalProperty_, "ns1:setGlobalProperty"))
				{	soap_flag_ns1__setGlobalProperty_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__setGlobalProperty * SOAP_FMAC6 soap_new___ns1__setGlobalProperty(struct soap *soap, int n)
{	return soap_instantiate___ns1__setGlobalProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__setGlobalProperty(struct soap *soap, struct __ns1__setGlobalProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__setGlobalProperty * SOAP_FMAC4 soap_instantiate___ns1__setGlobalProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setGlobalProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setGlobalProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__setGlobalProperty;
		if (size)
			*size = sizeof(struct __ns1__setGlobalProperty);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__setGlobalProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setGlobalProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setGlobalProperty*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setGlobalProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setGlobalProperty %p -> %p\n", q, p));
	*(struct __ns1__setGlobalProperty*)p = *(struct __ns1__setGlobalProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setEventState(struct soap *soap, struct __ns1__setEventState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setEventState_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setEventState(struct soap *soap, const struct __ns1__setEventState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setEventState(soap, &a->ns1__setEventState_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setEventState(struct soap *soap, const struct __ns1__setEventState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setEventState(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setEventState(struct soap *soap, const char *tag, int id, const struct __ns1__setEventState *a, const char *type)
{
	if (soap_out_PointerTons1__setEventState(soap, "ns1:setEventState", -1, &a->ns1__setEventState_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setEventState * SOAP_FMAC4 soap_get___ns1__setEventState(struct soap *soap, struct __ns1__setEventState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setEventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__setEventState * SOAP_FMAC4 soap_in___ns1__setEventState(struct soap *soap, const char *tag, struct __ns1__setEventState *a, const char *type)
{
	size_t soap_flag_ns1__setEventState_ = 1;
	short soap_flag;
	a = (struct __ns1__setEventState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setEventState, sizeof(struct __ns1__setEventState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setEventState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setEventState_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setEventState(soap, "ns1:setEventState", &a->ns1__setEventState_, "ns1:setEventState"))
				{	soap_flag_ns1__setEventState_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__setEventState * SOAP_FMAC6 soap_new___ns1__setEventState(struct soap *soap, int n)
{	return soap_instantiate___ns1__setEventState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__setEventState(struct soap *soap, struct __ns1__setEventState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__setEventState * SOAP_FMAC4 soap_instantiate___ns1__setEventState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setEventState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setEventState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__setEventState;
		if (size)
			*size = sizeof(struct __ns1__setEventState);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__setEventState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setEventState);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setEventState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setEventState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setEventState %p -> %p\n", q, p));
	*(struct __ns1__setEventState*)p = *(struct __ns1__setEventState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setEntityProperties(struct soap *soap, struct __ns1__setEntityProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setEntityProperties_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setEntityProperties(struct soap *soap, const struct __ns1__setEntityProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setEntityProperties(soap, &a->ns1__setEntityProperties_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setEntityProperties(struct soap *soap, const struct __ns1__setEntityProperties *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setEntityProperties(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setEntityProperties(struct soap *soap, const char *tag, int id, const struct __ns1__setEntityProperties *a, const char *type)
{
	if (soap_out_PointerTons1__setEntityProperties(soap, "ns1:setEntityProperties", -1, &a->ns1__setEntityProperties_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setEntityProperties * SOAP_FMAC4 soap_get___ns1__setEntityProperties(struct soap *soap, struct __ns1__setEntityProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setEntityProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__setEntityProperties * SOAP_FMAC4 soap_in___ns1__setEntityProperties(struct soap *soap, const char *tag, struct __ns1__setEntityProperties *a, const char *type)
{
	size_t soap_flag_ns1__setEntityProperties_ = 1;
	short soap_flag;
	a = (struct __ns1__setEntityProperties *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setEntityProperties, sizeof(struct __ns1__setEntityProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setEntityProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setEntityProperties_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setEntityProperties(soap, "ns1:setEntityProperties", &a->ns1__setEntityProperties_, "ns1:setEntityProperties"))
				{	soap_flag_ns1__setEntityProperties_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__setEntityProperties * SOAP_FMAC6 soap_new___ns1__setEntityProperties(struct soap *soap, int n)
{	return soap_instantiate___ns1__setEntityProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__setEntityProperties(struct soap *soap, struct __ns1__setEntityProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__setEntityProperties * SOAP_FMAC4 soap_instantiate___ns1__setEntityProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setEntityProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setEntityProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__setEntityProperties;
		if (size)
			*size = sizeof(struct __ns1__setEntityProperties);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__setEntityProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setEntityProperties);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setEntityProperties*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setEntityProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setEntityProperties %p -> %p\n", q, p));
	*(struct __ns1__setEntityProperties*)p = *(struct __ns1__setEntityProperties*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setCollectionState(struct soap *soap, struct __ns1__setCollectionState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setCollectionState_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setCollectionState(struct soap *soap, const struct __ns1__setCollectionState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setCollectionState(soap, &a->ns1__setCollectionState_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setCollectionState(struct soap *soap, const struct __ns1__setCollectionState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setCollectionState(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setCollectionState(struct soap *soap, const char *tag, int id, const struct __ns1__setCollectionState *a, const char *type)
{
	if (soap_out_PointerTons1__setCollectionState(soap, "ns1:setCollectionState", -1, &a->ns1__setCollectionState_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setCollectionState * SOAP_FMAC4 soap_get___ns1__setCollectionState(struct soap *soap, struct __ns1__setCollectionState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setCollectionState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__setCollectionState * SOAP_FMAC4 soap_in___ns1__setCollectionState(struct soap *soap, const char *tag, struct __ns1__setCollectionState *a, const char *type)
{
	size_t soap_flag_ns1__setCollectionState_ = 1;
	short soap_flag;
	a = (struct __ns1__setCollectionState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setCollectionState, sizeof(struct __ns1__setCollectionState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setCollectionState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setCollectionState_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setCollectionState(soap, "ns1:setCollectionState", &a->ns1__setCollectionState_, "ns1:setCollectionState"))
				{	soap_flag_ns1__setCollectionState_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__setCollectionState * SOAP_FMAC6 soap_new___ns1__setCollectionState(struct soap *soap, int n)
{	return soap_instantiate___ns1__setCollectionState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__setCollectionState(struct soap *soap, struct __ns1__setCollectionState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__setCollectionState * SOAP_FMAC4 soap_instantiate___ns1__setCollectionState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setCollectionState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setCollectionState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__setCollectionState;
		if (size)
			*size = sizeof(struct __ns1__setCollectionState);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__setCollectionState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setCollectionState);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setCollectionState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setCollectionState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setCollectionState %p -> %p\n", q, p));
	*(struct __ns1__setCollectionState*)p = *(struct __ns1__setCollectionState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__schedulePolicy(struct soap *soap, struct __ns1__schedulePolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__schedulePolicy_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__schedulePolicy(struct soap *soap, const struct __ns1__schedulePolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__schedulePolicy(soap, &a->ns1__schedulePolicy_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__schedulePolicy(struct soap *soap, const struct __ns1__schedulePolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__schedulePolicy(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__schedulePolicy(struct soap *soap, const char *tag, int id, const struct __ns1__schedulePolicy *a, const char *type)
{
	if (soap_out_PointerTons1__schedulePolicy(soap, "ns1:schedulePolicy", -1, &a->ns1__schedulePolicy_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__schedulePolicy * SOAP_FMAC4 soap_get___ns1__schedulePolicy(struct soap *soap, struct __ns1__schedulePolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__schedulePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__schedulePolicy * SOAP_FMAC4 soap_in___ns1__schedulePolicy(struct soap *soap, const char *tag, struct __ns1__schedulePolicy *a, const char *type)
{
	size_t soap_flag_ns1__schedulePolicy_ = 1;
	short soap_flag;
	a = (struct __ns1__schedulePolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__schedulePolicy, sizeof(struct __ns1__schedulePolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__schedulePolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__schedulePolicy_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__schedulePolicy(soap, "ns1:schedulePolicy", &a->ns1__schedulePolicy_, "ns1:schedulePolicy"))
				{	soap_flag_ns1__schedulePolicy_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__schedulePolicy * SOAP_FMAC6 soap_new___ns1__schedulePolicy(struct soap *soap, int n)
{	return soap_instantiate___ns1__schedulePolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__schedulePolicy(struct soap *soap, struct __ns1__schedulePolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__schedulePolicy * SOAP_FMAC4 soap_instantiate___ns1__schedulePolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__schedulePolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__schedulePolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__schedulePolicy;
		if (size)
			*size = sizeof(struct __ns1__schedulePolicy);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__schedulePolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__schedulePolicy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__schedulePolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__schedulePolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__schedulePolicy %p -> %p\n", q, p));
	*(struct __ns1__schedulePolicy*)p = *(struct __ns1__schedulePolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removePolicy(struct soap *soap, struct __ns1__removePolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removePolicy_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removePolicy(struct soap *soap, const struct __ns1__removePolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removePolicy(soap, &a->ns1__removePolicy_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removePolicy(struct soap *soap, const struct __ns1__removePolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removePolicy(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removePolicy(struct soap *soap, const char *tag, int id, const struct __ns1__removePolicy *a, const char *type)
{
	if (soap_out_PointerTons1__removePolicy(soap, "ns1:removePolicy", -1, &a->ns1__removePolicy_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removePolicy * SOAP_FMAC4 soap_get___ns1__removePolicy(struct soap *soap, struct __ns1__removePolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__removePolicy * SOAP_FMAC4 soap_in___ns1__removePolicy(struct soap *soap, const char *tag, struct __ns1__removePolicy *a, const char *type)
{
	size_t soap_flag_ns1__removePolicy_ = 1;
	short soap_flag;
	a = (struct __ns1__removePolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removePolicy, sizeof(struct __ns1__removePolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removePolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removePolicy_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removePolicy(soap, "ns1:removePolicy", &a->ns1__removePolicy_, "ns1:removePolicy"))
				{	soap_flag_ns1__removePolicy_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__removePolicy * SOAP_FMAC6 soap_new___ns1__removePolicy(struct soap *soap, int n)
{	return soap_instantiate___ns1__removePolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__removePolicy(struct soap *soap, struct __ns1__removePolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__removePolicy * SOAP_FMAC4 soap_instantiate___ns1__removePolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removePolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removePolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__removePolicy;
		if (size)
			*size = sizeof(struct __ns1__removePolicy);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__removePolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removePolicy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removePolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removePolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removePolicy %p -> %p\n", q, p));
	*(struct __ns1__removePolicy*)p = *(struct __ns1__removePolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeEntity(struct soap *soap, struct __ns1__removeEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeEntity_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeEntity(struct soap *soap, const struct __ns1__removeEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeEntity(soap, &a->ns1__removeEntity_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeEntity(struct soap *soap, const struct __ns1__removeEntity *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeEntity(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeEntity(struct soap *soap, const char *tag, int id, const struct __ns1__removeEntity *a, const char *type)
{
	if (soap_out_PointerTons1__removeEntity(soap, "ns1:removeEntity", -1, &a->ns1__removeEntity_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeEntity * SOAP_FMAC4 soap_get___ns1__removeEntity(struct soap *soap, struct __ns1__removeEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__removeEntity * SOAP_FMAC4 soap_in___ns1__removeEntity(struct soap *soap, const char *tag, struct __ns1__removeEntity *a, const char *type)
{
	size_t soap_flag_ns1__removeEntity_ = 1;
	short soap_flag;
	a = (struct __ns1__removeEntity *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeEntity, sizeof(struct __ns1__removeEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeEntity(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeEntity_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeEntity(soap, "ns1:removeEntity", &a->ns1__removeEntity_, "ns1:removeEntity"))
				{	soap_flag_ns1__removeEntity_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__removeEntity * SOAP_FMAC6 soap_new___ns1__removeEntity(struct soap *soap, int n)
{	return soap_instantiate___ns1__removeEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__removeEntity(struct soap *soap, struct __ns1__removeEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__removeEntity * SOAP_FMAC4 soap_instantiate___ns1__removeEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__removeEntity;
		if (size)
			*size = sizeof(struct __ns1__removeEntity);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__removeEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeEntity);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeEntity %p -> %p\n", q, p));
	*(struct __ns1__removeEntity*)p = *(struct __ns1__removeEntity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__removeCustomEvent(struct soap *soap, struct __ns1__removeCustomEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__removeCustomEvent_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__removeCustomEvent(struct soap *soap, const struct __ns1__removeCustomEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__removeCustomEvent(soap, &a->ns1__removeCustomEvent_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__removeCustomEvent(struct soap *soap, const struct __ns1__removeCustomEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__removeCustomEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__removeCustomEvent(struct soap *soap, const char *tag, int id, const struct __ns1__removeCustomEvent *a, const char *type)
{
	if (soap_out_PointerTons1__removeCustomEvent(soap, "ns1:removeCustomEvent", -1, &a->ns1__removeCustomEvent_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__removeCustomEvent * SOAP_FMAC4 soap_get___ns1__removeCustomEvent(struct soap *soap, struct __ns1__removeCustomEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__removeCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__removeCustomEvent * SOAP_FMAC4 soap_in___ns1__removeCustomEvent(struct soap *soap, const char *tag, struct __ns1__removeCustomEvent *a, const char *type)
{
	size_t soap_flag_ns1__removeCustomEvent_ = 1;
	short soap_flag;
	a = (struct __ns1__removeCustomEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__removeCustomEvent, sizeof(struct __ns1__removeCustomEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__removeCustomEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__removeCustomEvent_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__removeCustomEvent(soap, "ns1:removeCustomEvent", &a->ns1__removeCustomEvent_, "ns1:removeCustomEvent"))
				{	soap_flag_ns1__removeCustomEvent_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__removeCustomEvent * SOAP_FMAC6 soap_new___ns1__removeCustomEvent(struct soap *soap, int n)
{	return soap_instantiate___ns1__removeCustomEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__removeCustomEvent(struct soap *soap, struct __ns1__removeCustomEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__removeCustomEvent * SOAP_FMAC4 soap_instantiate___ns1__removeCustomEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__removeCustomEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__removeCustomEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__removeCustomEvent;
		if (size)
			*size = sizeof(struct __ns1__removeCustomEvent);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__removeCustomEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__removeCustomEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__removeCustomEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__removeCustomEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__removeCustomEvent %p -> %p\n", q, p));
	*(struct __ns1__removeCustomEvent*)p = *(struct __ns1__removeCustomEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__rediscoverNodeCapabilities(struct soap *soap, struct __ns1__rediscoverNodeCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__rediscoverNodeCapabilities_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__rediscoverNodeCapabilities(struct soap *soap, const struct __ns1__rediscoverNodeCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__rediscoverNodeCapabilities(soap, &a->ns1__rediscoverNodeCapabilities_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__rediscoverNodeCapabilities(struct soap *soap, const struct __ns1__rediscoverNodeCapabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__rediscoverNodeCapabilities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__rediscoverNodeCapabilities(struct soap *soap, const char *tag, int id, const struct __ns1__rediscoverNodeCapabilities *a, const char *type)
{
	if (soap_out_PointerTons1__rediscoverNodeCapabilities(soap, "ns1:rediscoverNodeCapabilities", -1, &a->ns1__rediscoverNodeCapabilities_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__rediscoverNodeCapabilities * SOAP_FMAC4 soap_get___ns1__rediscoverNodeCapabilities(struct soap *soap, struct __ns1__rediscoverNodeCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__rediscoverNodeCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__rediscoverNodeCapabilities * SOAP_FMAC4 soap_in___ns1__rediscoverNodeCapabilities(struct soap *soap, const char *tag, struct __ns1__rediscoverNodeCapabilities *a, const char *type)
{
	size_t soap_flag_ns1__rediscoverNodeCapabilities_ = 1;
	short soap_flag;
	a = (struct __ns1__rediscoverNodeCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__rediscoverNodeCapabilities, sizeof(struct __ns1__rediscoverNodeCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__rediscoverNodeCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__rediscoverNodeCapabilities_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__rediscoverNodeCapabilities(soap, "ns1:rediscoverNodeCapabilities", &a->ns1__rediscoverNodeCapabilities_, "ns1:rediscoverNodeCapabilities"))
				{	soap_flag_ns1__rediscoverNodeCapabilities_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__rediscoverNodeCapabilities * SOAP_FMAC6 soap_new___ns1__rediscoverNodeCapabilities(struct soap *soap, int n)
{	return soap_instantiate___ns1__rediscoverNodeCapabilities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__rediscoverNodeCapabilities(struct soap *soap, struct __ns1__rediscoverNodeCapabilities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__rediscoverNodeCapabilities * SOAP_FMAC4 soap_instantiate___ns1__rediscoverNodeCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__rediscoverNodeCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__rediscoverNodeCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__rediscoverNodeCapabilities;
		if (size)
			*size = sizeof(struct __ns1__rediscoverNodeCapabilities);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__rediscoverNodeCapabilities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__rediscoverNodeCapabilities);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__rediscoverNodeCapabilities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__rediscoverNodeCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__rediscoverNodeCapabilities %p -> %p\n", q, p));
	*(struct __ns1__rediscoverNodeCapabilities*)p = *(struct __ns1__rediscoverNodeCapabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__isPolicyActive(struct soap *soap, struct __ns1__isPolicyActive *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__isPolicyActive_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__isPolicyActive(struct soap *soap, const struct __ns1__isPolicyActive *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__isPolicyActive(soap, &a->ns1__isPolicyActive_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__isPolicyActive(struct soap *soap, const struct __ns1__isPolicyActive *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__isPolicyActive(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__isPolicyActive(struct soap *soap, const char *tag, int id, const struct __ns1__isPolicyActive *a, const char *type)
{
	if (soap_out_PointerTons1__isPolicyActive(soap, "ns1:isPolicyActive", -1, &a->ns1__isPolicyActive_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__isPolicyActive * SOAP_FMAC4 soap_get___ns1__isPolicyActive(struct soap *soap, struct __ns1__isPolicyActive *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__isPolicyActive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__isPolicyActive * SOAP_FMAC4 soap_in___ns1__isPolicyActive(struct soap *soap, const char *tag, struct __ns1__isPolicyActive *a, const char *type)
{
	size_t soap_flag_ns1__isPolicyActive_ = 1;
	short soap_flag;
	a = (struct __ns1__isPolicyActive *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__isPolicyActive, sizeof(struct __ns1__isPolicyActive), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__isPolicyActive(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__isPolicyActive_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__isPolicyActive(soap, "ns1:isPolicyActive", &a->ns1__isPolicyActive_, "ns1:isPolicyActive"))
				{	soap_flag_ns1__isPolicyActive_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__isPolicyActive * SOAP_FMAC6 soap_new___ns1__isPolicyActive(struct soap *soap, int n)
{	return soap_instantiate___ns1__isPolicyActive(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__isPolicyActive(struct soap *soap, struct __ns1__isPolicyActive *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__isPolicyActive * SOAP_FMAC4 soap_instantiate___ns1__isPolicyActive(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__isPolicyActive(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__isPolicyActive, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__isPolicyActive;
		if (size)
			*size = sizeof(struct __ns1__isPolicyActive);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__isPolicyActive[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__isPolicyActive);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__isPolicyActive*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__isPolicyActive(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__isPolicyActive %p -> %p\n", q, p));
	*(struct __ns1__isPolicyActive*)p = *(struct __ns1__isPolicyActive*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__importHierarchy(struct soap *soap, struct __ns1__importHierarchy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__importHierarchy_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__importHierarchy(struct soap *soap, const struct __ns1__importHierarchy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__importHierarchy(soap, &a->ns1__importHierarchy_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__importHierarchy(struct soap *soap, const struct __ns1__importHierarchy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__importHierarchy(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__importHierarchy(struct soap *soap, const char *tag, int id, const struct __ns1__importHierarchy *a, const char *type)
{
	if (soap_out_PointerTons1__importHierarchy(soap, "ns1:importHierarchy", -1, &a->ns1__importHierarchy_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__importHierarchy * SOAP_FMAC4 soap_get___ns1__importHierarchy(struct soap *soap, struct __ns1__importHierarchy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__importHierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__importHierarchy * SOAP_FMAC4 soap_in___ns1__importHierarchy(struct soap *soap, const char *tag, struct __ns1__importHierarchy *a, const char *type)
{
	size_t soap_flag_ns1__importHierarchy_ = 1;
	short soap_flag;
	a = (struct __ns1__importHierarchy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__importHierarchy, sizeof(struct __ns1__importHierarchy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__importHierarchy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__importHierarchy_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__importHierarchy(soap, "ns1:importHierarchy", &a->ns1__importHierarchy_, "ns1:importHierarchy"))
				{	soap_flag_ns1__importHierarchy_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__importHierarchy * SOAP_FMAC6 soap_new___ns1__importHierarchy(struct soap *soap, int n)
{	return soap_instantiate___ns1__importHierarchy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__importHierarchy(struct soap *soap, struct __ns1__importHierarchy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__importHierarchy * SOAP_FMAC4 soap_instantiate___ns1__importHierarchy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__importHierarchy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__importHierarchy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__importHierarchy;
		if (size)
			*size = sizeof(struct __ns1__importHierarchy);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__importHierarchy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__importHierarchy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__importHierarchy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__importHierarchy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__importHierarchy %p -> %p\n", q, p));
	*(struct __ns1__importHierarchy*)p = *(struct __ns1__importHierarchy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getQueryData(struct soap *soap, struct __ns1__getQueryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getQueryData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getQueryData(struct soap *soap, const struct __ns1__getQueryData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getQueryData(soap, &a->ns1__getQueryData_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getQueryData(struct soap *soap, const struct __ns1__getQueryData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getQueryData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getQueryData(struct soap *soap, const char *tag, int id, const struct __ns1__getQueryData *a, const char *type)
{
	if (soap_out_PointerTons1__getQueryData(soap, "ns1:getQueryData", -1, &a->ns1__getQueryData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getQueryData * SOAP_FMAC4 soap_get___ns1__getQueryData(struct soap *soap, struct __ns1__getQueryData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getQueryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getQueryData * SOAP_FMAC4 soap_in___ns1__getQueryData(struct soap *soap, const char *tag, struct __ns1__getQueryData *a, const char *type)
{
	size_t soap_flag_ns1__getQueryData_ = 1;
	short soap_flag;
	a = (struct __ns1__getQueryData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getQueryData, sizeof(struct __ns1__getQueryData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getQueryData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getQueryData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getQueryData(soap, "ns1:getQueryData", &a->ns1__getQueryData_, "ns1:getQueryData"))
				{	soap_flag_ns1__getQueryData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getQueryData * SOAP_FMAC6 soap_new___ns1__getQueryData(struct soap *soap, int n)
{	return soap_instantiate___ns1__getQueryData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getQueryData(struct soap *soap, struct __ns1__getQueryData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getQueryData * SOAP_FMAC4 soap_instantiate___ns1__getQueryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getQueryData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getQueryData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getQueryData;
		if (size)
			*size = sizeof(struct __ns1__getQueryData);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getQueryData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getQueryData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getQueryData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getQueryData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getQueryData %p -> %p\n", q, p));
	*(struct __ns1__getQueryData*)p = *(struct __ns1__getQueryData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getQueryAggregationPeriodList(struct soap *soap, struct __ns1__getQueryAggregationPeriodList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getQueryAggregationPeriodList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getQueryAggregationPeriodList(struct soap *soap, const struct __ns1__getQueryAggregationPeriodList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getQueryAggregationPeriodList(soap, &a->ns1__getQueryAggregationPeriodList_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getQueryAggregationPeriodList(struct soap *soap, const struct __ns1__getQueryAggregationPeriodList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getQueryAggregationPeriodList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getQueryAggregationPeriodList(struct soap *soap, const char *tag, int id, const struct __ns1__getQueryAggregationPeriodList *a, const char *type)
{
	if (soap_out_PointerTons1__getQueryAggregationPeriodList(soap, "ns1:getQueryAggregationPeriodList", -1, &a->ns1__getQueryAggregationPeriodList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getQueryAggregationPeriodList * SOAP_FMAC4 soap_get___ns1__getQueryAggregationPeriodList(struct soap *soap, struct __ns1__getQueryAggregationPeriodList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getQueryAggregationPeriodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getQueryAggregationPeriodList * SOAP_FMAC4 soap_in___ns1__getQueryAggregationPeriodList(struct soap *soap, const char *tag, struct __ns1__getQueryAggregationPeriodList *a, const char *type)
{
	size_t soap_flag_ns1__getQueryAggregationPeriodList_ = 1;
	short soap_flag;
	a = (struct __ns1__getQueryAggregationPeriodList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getQueryAggregationPeriodList, sizeof(struct __ns1__getQueryAggregationPeriodList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getQueryAggregationPeriodList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getQueryAggregationPeriodList_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getQueryAggregationPeriodList(soap, "ns1:getQueryAggregationPeriodList", &a->ns1__getQueryAggregationPeriodList_, "ns1:getQueryAggregationPeriodList"))
				{	soap_flag_ns1__getQueryAggregationPeriodList_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getQueryAggregationPeriodList * SOAP_FMAC6 soap_new___ns1__getQueryAggregationPeriodList(struct soap *soap, int n)
{	return soap_instantiate___ns1__getQueryAggregationPeriodList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getQueryAggregationPeriodList(struct soap *soap, struct __ns1__getQueryAggregationPeriodList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getQueryAggregationPeriodList * SOAP_FMAC4 soap_instantiate___ns1__getQueryAggregationPeriodList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getQueryAggregationPeriodList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getQueryAggregationPeriodList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getQueryAggregationPeriodList;
		if (size)
			*size = sizeof(struct __ns1__getQueryAggregationPeriodList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getQueryAggregationPeriodList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getQueryAggregationPeriodList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getQueryAggregationPeriodList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getQueryAggregationPeriodList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getQueryAggregationPeriodList %p -> %p\n", q, p));
	*(struct __ns1__getQueryAggregationPeriodList*)p = *(struct __ns1__getQueryAggregationPeriodList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPredefinedEventTypes(struct soap *soap, struct __ns1__getPredefinedEventTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPredefinedEventTypes_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPredefinedEventTypes(struct soap *soap, const struct __ns1__getPredefinedEventTypes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPredefinedEventTypes(soap, &a->ns1__getPredefinedEventTypes_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPredefinedEventTypes(struct soap *soap, const struct __ns1__getPredefinedEventTypes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPredefinedEventTypes(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPredefinedEventTypes(struct soap *soap, const char *tag, int id, const struct __ns1__getPredefinedEventTypes *a, const char *type)
{
	if (soap_out_PointerTons1__getPredefinedEventTypes(soap, "ns1:getPredefinedEventTypes", -1, &a->ns1__getPredefinedEventTypes_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPredefinedEventTypes * SOAP_FMAC4 soap_get___ns1__getPredefinedEventTypes(struct soap *soap, struct __ns1__getPredefinedEventTypes *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPredefinedEventTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getPredefinedEventTypes * SOAP_FMAC4 soap_in___ns1__getPredefinedEventTypes(struct soap *soap, const char *tag, struct __ns1__getPredefinedEventTypes *a, const char *type)
{
	size_t soap_flag_ns1__getPredefinedEventTypes_ = 1;
	short soap_flag;
	a = (struct __ns1__getPredefinedEventTypes *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPredefinedEventTypes, sizeof(struct __ns1__getPredefinedEventTypes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPredefinedEventTypes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPredefinedEventTypes_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPredefinedEventTypes(soap, "ns1:getPredefinedEventTypes", &a->ns1__getPredefinedEventTypes_, "ns1:getPredefinedEventTypes"))
				{	soap_flag_ns1__getPredefinedEventTypes_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getPredefinedEventTypes * SOAP_FMAC6 soap_new___ns1__getPredefinedEventTypes(struct soap *soap, int n)
{	return soap_instantiate___ns1__getPredefinedEventTypes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getPredefinedEventTypes(struct soap *soap, struct __ns1__getPredefinedEventTypes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getPredefinedEventTypes * SOAP_FMAC4 soap_instantiate___ns1__getPredefinedEventTypes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPredefinedEventTypes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPredefinedEventTypes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getPredefinedEventTypes;
		if (size)
			*size = sizeof(struct __ns1__getPredefinedEventTypes);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getPredefinedEventTypes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPredefinedEventTypes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPredefinedEventTypes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPredefinedEventTypes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPredefinedEventTypes %p -> %p\n", q, p));
	*(struct __ns1__getPredefinedEventTypes*)p = *(struct __ns1__getPredefinedEventTypes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPolicyState(struct soap *soap, struct __ns1__getPolicyState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPolicyState_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPolicyState(struct soap *soap, const struct __ns1__getPolicyState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPolicyState(soap, &a->ns1__getPolicyState_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPolicyState(struct soap *soap, const struct __ns1__getPolicyState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPolicyState(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPolicyState(struct soap *soap, const char *tag, int id, const struct __ns1__getPolicyState *a, const char *type)
{
	if (soap_out_PointerTons1__getPolicyState(soap, "ns1:getPolicyState", -1, &a->ns1__getPolicyState_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPolicyState * SOAP_FMAC4 soap_get___ns1__getPolicyState(struct soap *soap, struct __ns1__getPolicyState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPolicyState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getPolicyState * SOAP_FMAC4 soap_in___ns1__getPolicyState(struct soap *soap, const char *tag, struct __ns1__getPolicyState *a, const char *type)
{
	size_t soap_flag_ns1__getPolicyState_ = 1;
	short soap_flag;
	a = (struct __ns1__getPolicyState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPolicyState, sizeof(struct __ns1__getPolicyState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPolicyState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPolicyState_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPolicyState(soap, "ns1:getPolicyState", &a->ns1__getPolicyState_, "ns1:getPolicyState"))
				{	soap_flag_ns1__getPolicyState_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getPolicyState * SOAP_FMAC6 soap_new___ns1__getPolicyState(struct soap *soap, int n)
{	return soap_instantiate___ns1__getPolicyState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getPolicyState(struct soap *soap, struct __ns1__getPolicyState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getPolicyState * SOAP_FMAC4 soap_instantiate___ns1__getPolicyState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPolicyState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPolicyState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getPolicyState;
		if (size)
			*size = sizeof(struct __ns1__getPolicyState);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getPolicyState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPolicyState);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPolicyState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPolicyState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPolicyState %p -> %p\n", q, p));
	*(struct __ns1__getPolicyState*)p = *(struct __ns1__getPolicyState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPolicyHistory(struct soap *soap, struct __ns1__getPolicyHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPolicyHistory_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPolicyHistory(struct soap *soap, const struct __ns1__getPolicyHistory *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPolicyHistory(soap, &a->ns1__getPolicyHistory_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPolicyHistory(struct soap *soap, const struct __ns1__getPolicyHistory *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPolicyHistory(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPolicyHistory(struct soap *soap, const char *tag, int id, const struct __ns1__getPolicyHistory *a, const char *type)
{
	if (soap_out_PointerTons1__getPolicyHistory(soap, "ns1:getPolicyHistory", -1, &a->ns1__getPolicyHistory_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPolicyHistory * SOAP_FMAC4 soap_get___ns1__getPolicyHistory(struct soap *soap, struct __ns1__getPolicyHistory *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPolicyHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getPolicyHistory * SOAP_FMAC4 soap_in___ns1__getPolicyHistory(struct soap *soap, const char *tag, struct __ns1__getPolicyHistory *a, const char *type)
{
	size_t soap_flag_ns1__getPolicyHistory_ = 1;
	short soap_flag;
	a = (struct __ns1__getPolicyHistory *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPolicyHistory, sizeof(struct __ns1__getPolicyHistory), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPolicyHistory(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPolicyHistory_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPolicyHistory(soap, "ns1:getPolicyHistory", &a->ns1__getPolicyHistory_, "ns1:getPolicyHistory"))
				{	soap_flag_ns1__getPolicyHistory_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getPolicyHistory * SOAP_FMAC6 soap_new___ns1__getPolicyHistory(struct soap *soap, int n)
{	return soap_instantiate___ns1__getPolicyHistory(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getPolicyHistory(struct soap *soap, struct __ns1__getPolicyHistory *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getPolicyHistory * SOAP_FMAC4 soap_instantiate___ns1__getPolicyHistory(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPolicyHistory(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPolicyHistory, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getPolicyHistory;
		if (size)
			*size = sizeof(struct __ns1__getPolicyHistory);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getPolicyHistory[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPolicyHistory);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPolicyHistory*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPolicyHistory(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPolicyHistory %p -> %p\n", q, p));
	*(struct __ns1__getPolicyHistory*)p = *(struct __ns1__getPolicyHistory*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getPolicyData(struct soap *soap, struct __ns1__getPolicyData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getPolicyData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getPolicyData(struct soap *soap, const struct __ns1__getPolicyData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getPolicyData(soap, &a->ns1__getPolicyData_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getPolicyData(struct soap *soap, const struct __ns1__getPolicyData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getPolicyData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getPolicyData(struct soap *soap, const char *tag, int id, const struct __ns1__getPolicyData *a, const char *type)
{
	if (soap_out_PointerTons1__getPolicyData(soap, "ns1:getPolicyData", -1, &a->ns1__getPolicyData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getPolicyData * SOAP_FMAC4 soap_get___ns1__getPolicyData(struct soap *soap, struct __ns1__getPolicyData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getPolicyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getPolicyData * SOAP_FMAC4 soap_in___ns1__getPolicyData(struct soap *soap, const char *tag, struct __ns1__getPolicyData *a, const char *type)
{
	size_t soap_flag_ns1__getPolicyData_ = 1;
	short soap_flag;
	a = (struct __ns1__getPolicyData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getPolicyData, sizeof(struct __ns1__getPolicyData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getPolicyData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getPolicyData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getPolicyData(soap, "ns1:getPolicyData", &a->ns1__getPolicyData_, "ns1:getPolicyData"))
				{	soap_flag_ns1__getPolicyData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getPolicyData * SOAP_FMAC6 soap_new___ns1__getPolicyData(struct soap *soap, int n)
{	return soap_instantiate___ns1__getPolicyData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getPolicyData(struct soap *soap, struct __ns1__getPolicyData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getPolicyData * SOAP_FMAC4 soap_instantiate___ns1__getPolicyData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getPolicyData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getPolicyData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getPolicyData;
		if (size)
			*size = sizeof(struct __ns1__getPolicyData);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getPolicyData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getPolicyData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getPolicyData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getPolicyData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getPolicyData %p -> %p\n", q, p));
	*(struct __ns1__getPolicyData*)p = *(struct __ns1__getPolicyData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getNextData(struct soap *soap, struct __ns1__getNextData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getNextData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getNextData(struct soap *soap, const struct __ns1__getNextData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getNextData(soap, &a->ns1__getNextData_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getNextData(struct soap *soap, const struct __ns1__getNextData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getNextData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getNextData(struct soap *soap, const char *tag, int id, const struct __ns1__getNextData *a, const char *type)
{
	if (soap_out_PointerTons1__getNextData(soap, "ns1:getNextData", -1, &a->ns1__getNextData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getNextData * SOAP_FMAC4 soap_get___ns1__getNextData(struct soap *soap, struct __ns1__getNextData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getNextData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getNextData * SOAP_FMAC4 soap_in___ns1__getNextData(struct soap *soap, const char *tag, struct __ns1__getNextData *a, const char *type)
{
	size_t soap_flag_ns1__getNextData_ = 1;
	short soap_flag;
	a = (struct __ns1__getNextData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getNextData, sizeof(struct __ns1__getNextData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getNextData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getNextData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getNextData(soap, "ns1:getNextData", &a->ns1__getNextData_, "ns1:getNextData"))
				{	soap_flag_ns1__getNextData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getNextData * SOAP_FMAC6 soap_new___ns1__getNextData(struct soap *soap, int n)
{	return soap_instantiate___ns1__getNextData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getNextData(struct soap *soap, struct __ns1__getNextData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getNextData * SOAP_FMAC4 soap_instantiate___ns1__getNextData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getNextData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getNextData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getNextData;
		if (size)
			*size = sizeof(struct __ns1__getNextData);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getNextData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getNextData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getNextData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getNextData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getNextData %p -> %p\n", q, p));
	*(struct __ns1__getNextData*)p = *(struct __ns1__getNextData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMetricData(struct soap *soap, struct __ns1__getMetricData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMetricData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMetricData(struct soap *soap, const struct __ns1__getMetricData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getMetricData(soap, &a->ns1__getMetricData_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMetricData(struct soap *soap, const struct __ns1__getMetricData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMetricData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMetricData(struct soap *soap, const char *tag, int id, const struct __ns1__getMetricData *a, const char *type)
{
	if (soap_out_PointerTons1__getMetricData(soap, "ns1:getMetricData", -1, &a->ns1__getMetricData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMetricData * SOAP_FMAC4 soap_get___ns1__getMetricData(struct soap *soap, struct __ns1__getMetricData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMetricData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getMetricData * SOAP_FMAC4 soap_in___ns1__getMetricData(struct soap *soap, const char *tag, struct __ns1__getMetricData *a, const char *type)
{
	size_t soap_flag_ns1__getMetricData_ = 1;
	short soap_flag;
	a = (struct __ns1__getMetricData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMetricData, sizeof(struct __ns1__getMetricData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMetricData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMetricData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getMetricData(soap, "ns1:getMetricData", &a->ns1__getMetricData_, "ns1:getMetricData"))
				{	soap_flag_ns1__getMetricData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getMetricData * SOAP_FMAC6 soap_new___ns1__getMetricData(struct soap *soap, int n)
{	return soap_instantiate___ns1__getMetricData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getMetricData(struct soap *soap, struct __ns1__getMetricData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getMetricData * SOAP_FMAC4 soap_instantiate___ns1__getMetricData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMetricData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMetricData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getMetricData;
		if (size)
			*size = sizeof(struct __ns1__getMetricData);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getMetricData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMetricData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMetricData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMetricData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMetricData %p -> %p\n", q, p));
	*(struct __ns1__getMetricData*)p = *(struct __ns1__getMetricData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getMetricAggregationPeriodList(struct soap *soap, struct __ns1__getMetricAggregationPeriodList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getMetricAggregationPeriodList_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getMetricAggregationPeriodList(struct soap *soap, const struct __ns1__getMetricAggregationPeriodList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getMetricAggregationPeriodList(soap, &a->ns1__getMetricAggregationPeriodList_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getMetricAggregationPeriodList(struct soap *soap, const struct __ns1__getMetricAggregationPeriodList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getMetricAggregationPeriodList(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getMetricAggregationPeriodList(struct soap *soap, const char *tag, int id, const struct __ns1__getMetricAggregationPeriodList *a, const char *type)
{
	if (soap_out_PointerTons1__getMetricAggregationPeriodList(soap, "ns1:getMetricAggregationPeriodList", -1, &a->ns1__getMetricAggregationPeriodList_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getMetricAggregationPeriodList * SOAP_FMAC4 soap_get___ns1__getMetricAggregationPeriodList(struct soap *soap, struct __ns1__getMetricAggregationPeriodList *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getMetricAggregationPeriodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getMetricAggregationPeriodList * SOAP_FMAC4 soap_in___ns1__getMetricAggregationPeriodList(struct soap *soap, const char *tag, struct __ns1__getMetricAggregationPeriodList *a, const char *type)
{
	size_t soap_flag_ns1__getMetricAggregationPeriodList_ = 1;
	short soap_flag;
	a = (struct __ns1__getMetricAggregationPeriodList *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getMetricAggregationPeriodList, sizeof(struct __ns1__getMetricAggregationPeriodList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getMetricAggregationPeriodList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getMetricAggregationPeriodList_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getMetricAggregationPeriodList(soap, "ns1:getMetricAggregationPeriodList", &a->ns1__getMetricAggregationPeriodList_, "ns1:getMetricAggregationPeriodList"))
				{	soap_flag_ns1__getMetricAggregationPeriodList_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getMetricAggregationPeriodList * SOAP_FMAC6 soap_new___ns1__getMetricAggregationPeriodList(struct soap *soap, int n)
{	return soap_instantiate___ns1__getMetricAggregationPeriodList(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getMetricAggregationPeriodList(struct soap *soap, struct __ns1__getMetricAggregationPeriodList *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getMetricAggregationPeriodList * SOAP_FMAC4 soap_instantiate___ns1__getMetricAggregationPeriodList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getMetricAggregationPeriodList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getMetricAggregationPeriodList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getMetricAggregationPeriodList;
		if (size)
			*size = sizeof(struct __ns1__getMetricAggregationPeriodList);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getMetricAggregationPeriodList[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getMetricAggregationPeriodList);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getMetricAggregationPeriodList*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getMetricAggregationPeriodList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getMetricAggregationPeriodList %p -> %p\n", q, p));
	*(struct __ns1__getMetricAggregationPeriodList*)p = *(struct __ns1__getMetricAggregationPeriodList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getGlobalProperty(struct soap *soap, struct __ns1__getGlobalProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getGlobalProperty_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getGlobalProperty(struct soap *soap, const struct __ns1__getGlobalProperty *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getGlobalProperty(soap, &a->ns1__getGlobalProperty_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getGlobalProperty(struct soap *soap, const struct __ns1__getGlobalProperty *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getGlobalProperty(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getGlobalProperty(struct soap *soap, const char *tag, int id, const struct __ns1__getGlobalProperty *a, const char *type)
{
	if (soap_out_PointerTons1__getGlobalProperty(soap, "ns1:getGlobalProperty", -1, &a->ns1__getGlobalProperty_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getGlobalProperty * SOAP_FMAC4 soap_get___ns1__getGlobalProperty(struct soap *soap, struct __ns1__getGlobalProperty *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getGlobalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getGlobalProperty * SOAP_FMAC4 soap_in___ns1__getGlobalProperty(struct soap *soap, const char *tag, struct __ns1__getGlobalProperty *a, const char *type)
{
	size_t soap_flag_ns1__getGlobalProperty_ = 1;
	short soap_flag;
	a = (struct __ns1__getGlobalProperty *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getGlobalProperty, sizeof(struct __ns1__getGlobalProperty), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getGlobalProperty(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getGlobalProperty_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getGlobalProperty(soap, "ns1:getGlobalProperty", &a->ns1__getGlobalProperty_, "ns1:getGlobalProperty"))
				{	soap_flag_ns1__getGlobalProperty_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getGlobalProperty * SOAP_FMAC6 soap_new___ns1__getGlobalProperty(struct soap *soap, int n)
{	return soap_instantiate___ns1__getGlobalProperty(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getGlobalProperty(struct soap *soap, struct __ns1__getGlobalProperty *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getGlobalProperty * SOAP_FMAC4 soap_instantiate___ns1__getGlobalProperty(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getGlobalProperty(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getGlobalProperty, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getGlobalProperty;
		if (size)
			*size = sizeof(struct __ns1__getGlobalProperty);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getGlobalProperty[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getGlobalProperty);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getGlobalProperty*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getGlobalProperty(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getGlobalProperty %p -> %p\n", q, p));
	*(struct __ns1__getGlobalProperty*)p = *(struct __ns1__getGlobalProperty*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEventState(struct soap *soap, struct __ns1__getEventState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getEventState_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEventState(struct soap *soap, const struct __ns1__getEventState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getEventState(soap, &a->ns1__getEventState_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEventState(struct soap *soap, const struct __ns1__getEventState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getEventState(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEventState(struct soap *soap, const char *tag, int id, const struct __ns1__getEventState *a, const char *type)
{
	if (soap_out_PointerTons1__getEventState(soap, "ns1:getEventState", -1, &a->ns1__getEventState_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEventState * SOAP_FMAC4 soap_get___ns1__getEventState(struct soap *soap, struct __ns1__getEventState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getEventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getEventState * SOAP_FMAC4 soap_in___ns1__getEventState(struct soap *soap, const char *tag, struct __ns1__getEventState *a, const char *type)
{
	size_t soap_flag_ns1__getEventState_ = 1;
	short soap_flag;
	a = (struct __ns1__getEventState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getEventState, sizeof(struct __ns1__getEventState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getEventState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getEventState_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getEventState(soap, "ns1:getEventState", &a->ns1__getEventState_, "ns1:getEventState"))
				{	soap_flag_ns1__getEventState_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getEventState * SOAP_FMAC6 soap_new___ns1__getEventState(struct soap *soap, int n)
{	return soap_instantiate___ns1__getEventState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getEventState(struct soap *soap, struct __ns1__getEventState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getEventState * SOAP_FMAC4 soap_instantiate___ns1__getEventState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEventState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getEventState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getEventState;
		if (size)
			*size = sizeof(struct __ns1__getEventState);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getEventState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getEventState);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getEventState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getEventState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getEventState %p -> %p\n", q, p));
	*(struct __ns1__getEventState*)p = *(struct __ns1__getEventState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEventHandler(struct soap *soap, struct __ns1__getEventHandler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getEventHandler_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEventHandler(struct soap *soap, const struct __ns1__getEventHandler *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getEventHandler(soap, &a->ns1__getEventHandler_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEventHandler(struct soap *soap, const struct __ns1__getEventHandler *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getEventHandler(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEventHandler(struct soap *soap, const char *tag, int id, const struct __ns1__getEventHandler *a, const char *type)
{
	if (soap_out_PointerTons1__getEventHandler(soap, "ns1:getEventHandler", -1, &a->ns1__getEventHandler_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEventHandler * SOAP_FMAC4 soap_get___ns1__getEventHandler(struct soap *soap, struct __ns1__getEventHandler *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getEventHandler * SOAP_FMAC4 soap_in___ns1__getEventHandler(struct soap *soap, const char *tag, struct __ns1__getEventHandler *a, const char *type)
{
	size_t soap_flag_ns1__getEventHandler_ = 1;
	short soap_flag;
	a = (struct __ns1__getEventHandler *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getEventHandler, sizeof(struct __ns1__getEventHandler), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getEventHandler(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getEventHandler_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getEventHandler(soap, "ns1:getEventHandler", &a->ns1__getEventHandler_, "ns1:getEventHandler"))
				{	soap_flag_ns1__getEventHandler_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getEventHandler * SOAP_FMAC6 soap_new___ns1__getEventHandler(struct soap *soap, int n)
{	return soap_instantiate___ns1__getEventHandler(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getEventHandler(struct soap *soap, struct __ns1__getEventHandler *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getEventHandler * SOAP_FMAC4 soap_instantiate___ns1__getEventHandler(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEventHandler(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getEventHandler, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getEventHandler;
		if (size)
			*size = sizeof(struct __ns1__getEventHandler);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getEventHandler[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getEventHandler);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getEventHandler*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getEventHandler(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getEventHandler %p -> %p\n", q, p));
	*(struct __ns1__getEventHandler*)p = *(struct __ns1__getEventHandler*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getEntityProperties(struct soap *soap, struct __ns1__getEntityProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getEntityProperties_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getEntityProperties(struct soap *soap, const struct __ns1__getEntityProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getEntityProperties(soap, &a->ns1__getEntityProperties_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getEntityProperties(struct soap *soap, const struct __ns1__getEntityProperties *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getEntityProperties(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getEntityProperties(struct soap *soap, const char *tag, int id, const struct __ns1__getEntityProperties *a, const char *type)
{
	if (soap_out_PointerTons1__getEntityProperties(soap, "ns1:getEntityProperties", -1, &a->ns1__getEntityProperties_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getEntityProperties * SOAP_FMAC4 soap_get___ns1__getEntityProperties(struct soap *soap, struct __ns1__getEntityProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getEntityProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getEntityProperties * SOAP_FMAC4 soap_in___ns1__getEntityProperties(struct soap *soap, const char *tag, struct __ns1__getEntityProperties *a, const char *type)
{
	size_t soap_flag_ns1__getEntityProperties_ = 1;
	short soap_flag;
	a = (struct __ns1__getEntityProperties *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getEntityProperties, sizeof(struct __ns1__getEntityProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getEntityProperties(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getEntityProperties_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getEntityProperties(soap, "ns1:getEntityProperties", &a->ns1__getEntityProperties_, "ns1:getEntityProperties"))
				{	soap_flag_ns1__getEntityProperties_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getEntityProperties * SOAP_FMAC6 soap_new___ns1__getEntityProperties(struct soap *soap, int n)
{	return soap_instantiate___ns1__getEntityProperties(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getEntityProperties(struct soap *soap, struct __ns1__getEntityProperties *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getEntityProperties * SOAP_FMAC4 soap_instantiate___ns1__getEntityProperties(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getEntityProperties(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getEntityProperties, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getEntityProperties;
		if (size)
			*size = sizeof(struct __ns1__getEntityProperties);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getEntityProperties[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getEntityProperties);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getEntityProperties*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getEntityProperties(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getEntityProperties %p -> %p\n", q, p));
	*(struct __ns1__getEntityProperties*)p = *(struct __ns1__getEntityProperties*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCustomEventData(struct soap *soap, struct __ns1__getCustomEventData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCustomEventData_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCustomEventData(struct soap *soap, const struct __ns1__getCustomEventData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getCustomEventData(soap, &a->ns1__getCustomEventData_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCustomEventData(struct soap *soap, const struct __ns1__getCustomEventData *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCustomEventData(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCustomEventData(struct soap *soap, const char *tag, int id, const struct __ns1__getCustomEventData *a, const char *type)
{
	if (soap_out_PointerTons1__getCustomEventData(soap, "ns1:getCustomEventData", -1, &a->ns1__getCustomEventData_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCustomEventData * SOAP_FMAC4 soap_get___ns1__getCustomEventData(struct soap *soap, struct __ns1__getCustomEventData *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCustomEventData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getCustomEventData * SOAP_FMAC4 soap_in___ns1__getCustomEventData(struct soap *soap, const char *tag, struct __ns1__getCustomEventData *a, const char *type)
{
	size_t soap_flag_ns1__getCustomEventData_ = 1;
	short soap_flag;
	a = (struct __ns1__getCustomEventData *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCustomEventData, sizeof(struct __ns1__getCustomEventData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCustomEventData(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCustomEventData_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getCustomEventData(soap, "ns1:getCustomEventData", &a->ns1__getCustomEventData_, "ns1:getCustomEventData"))
				{	soap_flag_ns1__getCustomEventData_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getCustomEventData * SOAP_FMAC6 soap_new___ns1__getCustomEventData(struct soap *soap, int n)
{	return soap_instantiate___ns1__getCustomEventData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getCustomEventData(struct soap *soap, struct __ns1__getCustomEventData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getCustomEventData * SOAP_FMAC4 soap_instantiate___ns1__getCustomEventData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCustomEventData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCustomEventData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getCustomEventData;
		if (size)
			*size = sizeof(struct __ns1__getCustomEventData);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getCustomEventData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getCustomEventData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getCustomEventData*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCustomEventData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCustomEventData %p -> %p\n", q, p));
	*(struct __ns1__getCustomEventData*)p = *(struct __ns1__getCustomEventData*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getCollectionState(struct soap *soap, struct __ns1__getCollectionState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getCollectionState_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getCollectionState(struct soap *soap, const struct __ns1__getCollectionState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getCollectionState(soap, &a->ns1__getCollectionState_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getCollectionState(struct soap *soap, const struct __ns1__getCollectionState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getCollectionState(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getCollectionState(struct soap *soap, const char *tag, int id, const struct __ns1__getCollectionState *a, const char *type)
{
	if (soap_out_PointerTons1__getCollectionState(soap, "ns1:getCollectionState", -1, &a->ns1__getCollectionState_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getCollectionState * SOAP_FMAC4 soap_get___ns1__getCollectionState(struct soap *soap, struct __ns1__getCollectionState *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getCollectionState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getCollectionState * SOAP_FMAC4 soap_in___ns1__getCollectionState(struct soap *soap, const char *tag, struct __ns1__getCollectionState *a, const char *type)
{
	size_t soap_flag_ns1__getCollectionState_ = 1;
	short soap_flag;
	a = (struct __ns1__getCollectionState *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getCollectionState, sizeof(struct __ns1__getCollectionState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getCollectionState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getCollectionState_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getCollectionState(soap, "ns1:getCollectionState", &a->ns1__getCollectionState_, "ns1:getCollectionState"))
				{	soap_flag_ns1__getCollectionState_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getCollectionState * SOAP_FMAC6 soap_new___ns1__getCollectionState(struct soap *soap, int n)
{	return soap_instantiate___ns1__getCollectionState(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getCollectionState(struct soap *soap, struct __ns1__getCollectionState *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getCollectionState * SOAP_FMAC4 soap_instantiate___ns1__getCollectionState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getCollectionState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getCollectionState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getCollectionState;
		if (size)
			*size = sizeof(struct __ns1__getCollectionState);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getCollectionState[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getCollectionState);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getCollectionState*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getCollectionState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getCollectionState %p -> %p\n", q, p));
	*(struct __ns1__getCollectionState*)p = *(struct __ns1__getCollectionState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getActionLogRecords(struct soap *soap, struct __ns1__getActionLogRecords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getActionLogRecords_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getActionLogRecords(struct soap *soap, const struct __ns1__getActionLogRecords *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getActionLogRecords(soap, &a->ns1__getActionLogRecords_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getActionLogRecords(struct soap *soap, const struct __ns1__getActionLogRecords *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getActionLogRecords(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getActionLogRecords(struct soap *soap, const char *tag, int id, const struct __ns1__getActionLogRecords *a, const char *type)
{
	if (soap_out_PointerTons1__getActionLogRecords(soap, "ns1:getActionLogRecords", -1, &a->ns1__getActionLogRecords_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getActionLogRecords * SOAP_FMAC4 soap_get___ns1__getActionLogRecords(struct soap *soap, struct __ns1__getActionLogRecords *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getActionLogRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getActionLogRecords * SOAP_FMAC4 soap_in___ns1__getActionLogRecords(struct soap *soap, const char *tag, struct __ns1__getActionLogRecords *a, const char *type)
{
	size_t soap_flag_ns1__getActionLogRecords_ = 1;
	short soap_flag;
	a = (struct __ns1__getActionLogRecords *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getActionLogRecords, sizeof(struct __ns1__getActionLogRecords), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getActionLogRecords(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getActionLogRecords_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getActionLogRecords(soap, "ns1:getActionLogRecords", &a->ns1__getActionLogRecords_, "ns1:getActionLogRecords"))
				{	soap_flag_ns1__getActionLogRecords_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getActionLogRecords * SOAP_FMAC6 soap_new___ns1__getActionLogRecords(struct soap *soap, int n)
{	return soap_instantiate___ns1__getActionLogRecords(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getActionLogRecords(struct soap *soap, struct __ns1__getActionLogRecords *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getActionLogRecords * SOAP_FMAC4 soap_instantiate___ns1__getActionLogRecords(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getActionLogRecords(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getActionLogRecords, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getActionLogRecords;
		if (size)
			*size = sizeof(struct __ns1__getActionLogRecords);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getActionLogRecords[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getActionLogRecords);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getActionLogRecords*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getActionLogRecords(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getActionLogRecords %p -> %p\n", q, p));
	*(struct __ns1__getActionLogRecords*)p = *(struct __ns1__getActionLogRecords*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__findEntities(struct soap *soap, struct __ns1__findEntities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__findEntities_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__findEntities(struct soap *soap, const struct __ns1__findEntities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__findEntities(soap, &a->ns1__findEntities_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__findEntities(struct soap *soap, const struct __ns1__findEntities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__findEntities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__findEntities(struct soap *soap, const char *tag, int id, const struct __ns1__findEntities *a, const char *type)
{
	if (soap_out_PointerTons1__findEntities(soap, "ns1:findEntities", -1, &a->ns1__findEntities_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__findEntities * SOAP_FMAC4 soap_get___ns1__findEntities(struct soap *soap, struct __ns1__findEntities *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__findEntities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__findEntities * SOAP_FMAC4 soap_in___ns1__findEntities(struct soap *soap, const char *tag, struct __ns1__findEntities *a, const char *type)
{
	size_t soap_flag_ns1__findEntities_ = 1;
	short soap_flag;
	a = (struct __ns1__findEntities *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__findEntities, sizeof(struct __ns1__findEntities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__findEntities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__findEntities_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__findEntities(soap, "ns1:findEntities", &a->ns1__findEntities_, "ns1:findEntities"))
				{	soap_flag_ns1__findEntities_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__findEntities * SOAP_FMAC6 soap_new___ns1__findEntities(struct soap *soap, int n)
{	return soap_instantiate___ns1__findEntities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__findEntities(struct soap *soap, struct __ns1__findEntities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__findEntities * SOAP_FMAC4 soap_instantiate___ns1__findEntities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__findEntities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__findEntities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__findEntities;
		if (size)
			*size = sizeof(struct __ns1__findEntities);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__findEntities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__findEntities);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__findEntities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__findEntities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__findEntities %p -> %p\n", q, p));
	*(struct __ns1__findEntities*)p = *(struct __ns1__findEntities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__exportHierarchy(struct soap *soap, struct __ns1__exportHierarchy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__exportHierarchy_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__exportHierarchy(struct soap *soap, const struct __ns1__exportHierarchy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__exportHierarchy(soap, &a->ns1__exportHierarchy_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__exportHierarchy(struct soap *soap, const struct __ns1__exportHierarchy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__exportHierarchy(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__exportHierarchy(struct soap *soap, const char *tag, int id, const struct __ns1__exportHierarchy *a, const char *type)
{
	if (soap_out_PointerTons1__exportHierarchy(soap, "ns1:exportHierarchy", -1, &a->ns1__exportHierarchy_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__exportHierarchy * SOAP_FMAC4 soap_get___ns1__exportHierarchy(struct soap *soap, struct __ns1__exportHierarchy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__exportHierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__exportHierarchy * SOAP_FMAC4 soap_in___ns1__exportHierarchy(struct soap *soap, const char *tag, struct __ns1__exportHierarchy *a, const char *type)
{
	size_t soap_flag_ns1__exportHierarchy_ = 1;
	short soap_flag;
	a = (struct __ns1__exportHierarchy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__exportHierarchy, sizeof(struct __ns1__exportHierarchy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__exportHierarchy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__exportHierarchy_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__exportHierarchy(soap, "ns1:exportHierarchy", &a->ns1__exportHierarchy_, "ns1:exportHierarchy"))
				{	soap_flag_ns1__exportHierarchy_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__exportHierarchy * SOAP_FMAC6 soap_new___ns1__exportHierarchy(struct soap *soap, int n)
{	return soap_instantiate___ns1__exportHierarchy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__exportHierarchy(struct soap *soap, struct __ns1__exportHierarchy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__exportHierarchy * SOAP_FMAC4 soap_instantiate___ns1__exportHierarchy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__exportHierarchy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__exportHierarchy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__exportHierarchy;
		if (size)
			*size = sizeof(struct __ns1__exportHierarchy);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__exportHierarchy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__exportHierarchy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__exportHierarchy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__exportHierarchy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__exportHierarchy %p -> %p\n", q, p));
	*(struct __ns1__exportHierarchy*)p = *(struct __ns1__exportHierarchy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enumeratePolicies(struct soap *soap, struct __ns1__enumeratePolicies *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__enumeratePolicies_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enumeratePolicies(struct soap *soap, const struct __ns1__enumeratePolicies *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumeratePolicies(soap, &a->ns1__enumeratePolicies_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enumeratePolicies(struct soap *soap, const struct __ns1__enumeratePolicies *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enumeratePolicies(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enumeratePolicies(struct soap *soap, const char *tag, int id, const struct __ns1__enumeratePolicies *a, const char *type)
{
	if (soap_out_PointerTons1__enumeratePolicies(soap, "ns1:enumeratePolicies", -1, &a->ns1__enumeratePolicies_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enumeratePolicies * SOAP_FMAC4 soap_get___ns1__enumeratePolicies(struct soap *soap, struct __ns1__enumeratePolicies *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enumeratePolicies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__enumeratePolicies * SOAP_FMAC4 soap_in___ns1__enumeratePolicies(struct soap *soap, const char *tag, struct __ns1__enumeratePolicies *a, const char *type)
{
	size_t soap_flag_ns1__enumeratePolicies_ = 1;
	short soap_flag;
	a = (struct __ns1__enumeratePolicies *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enumeratePolicies, sizeof(struct __ns1__enumeratePolicies), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enumeratePolicies(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__enumeratePolicies_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumeratePolicies(soap, "ns1:enumeratePolicies", &a->ns1__enumeratePolicies_, "ns1:enumeratePolicies"))
				{	soap_flag_ns1__enumeratePolicies_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__enumeratePolicies * SOAP_FMAC6 soap_new___ns1__enumeratePolicies(struct soap *soap, int n)
{	return soap_instantiate___ns1__enumeratePolicies(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__enumeratePolicies(struct soap *soap, struct __ns1__enumeratePolicies *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__enumeratePolicies * SOAP_FMAC4 soap_instantiate___ns1__enumeratePolicies(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enumeratePolicies(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enumeratePolicies, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__enumeratePolicies;
		if (size)
			*size = sizeof(struct __ns1__enumeratePolicies);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__enumeratePolicies[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__enumeratePolicies);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__enumeratePolicies*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enumeratePolicies(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enumeratePolicies %p -> %p\n", q, p));
	*(struct __ns1__enumeratePolicies*)p = *(struct __ns1__enumeratePolicies*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enumerateEventHandlers(struct soap *soap, struct __ns1__enumerateEventHandlers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__enumerateEventHandlers_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enumerateEventHandlers(struct soap *soap, const struct __ns1__enumerateEventHandlers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumerateEventHandlers(soap, &a->ns1__enumerateEventHandlers_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enumerateEventHandlers(struct soap *soap, const struct __ns1__enumerateEventHandlers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enumerateEventHandlers(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enumerateEventHandlers(struct soap *soap, const char *tag, int id, const struct __ns1__enumerateEventHandlers *a, const char *type)
{
	if (soap_out_PointerTons1__enumerateEventHandlers(soap, "ns1:enumerateEventHandlers", -1, &a->ns1__enumerateEventHandlers_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enumerateEventHandlers * SOAP_FMAC4 soap_get___ns1__enumerateEventHandlers(struct soap *soap, struct __ns1__enumerateEventHandlers *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enumerateEventHandlers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__enumerateEventHandlers * SOAP_FMAC4 soap_in___ns1__enumerateEventHandlers(struct soap *soap, const char *tag, struct __ns1__enumerateEventHandlers *a, const char *type)
{
	size_t soap_flag_ns1__enumerateEventHandlers_ = 1;
	short soap_flag;
	a = (struct __ns1__enumerateEventHandlers *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enumerateEventHandlers, sizeof(struct __ns1__enumerateEventHandlers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enumerateEventHandlers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__enumerateEventHandlers_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumerateEventHandlers(soap, "ns1:enumerateEventHandlers", &a->ns1__enumerateEventHandlers_, "ns1:enumerateEventHandlers"))
				{	soap_flag_ns1__enumerateEventHandlers_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__enumerateEventHandlers * SOAP_FMAC6 soap_new___ns1__enumerateEventHandlers(struct soap *soap, int n)
{	return soap_instantiate___ns1__enumerateEventHandlers(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__enumerateEventHandlers(struct soap *soap, struct __ns1__enumerateEventHandlers *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__enumerateEventHandlers * SOAP_FMAC4 soap_instantiate___ns1__enumerateEventHandlers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enumerateEventHandlers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enumerateEventHandlers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__enumerateEventHandlers;
		if (size)
			*size = sizeof(struct __ns1__enumerateEventHandlers);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__enumerateEventHandlers[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__enumerateEventHandlers);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__enumerateEventHandlers*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enumerateEventHandlers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enumerateEventHandlers %p -> %p\n", q, p));
	*(struct __ns1__enumerateEventHandlers*)p = *(struct __ns1__enumerateEventHandlers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enumerateEntities(struct soap *soap, struct __ns1__enumerateEntities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__enumerateEntities_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enumerateEntities(struct soap *soap, const struct __ns1__enumerateEntities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumerateEntities(soap, &a->ns1__enumerateEntities_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enumerateEntities(struct soap *soap, const struct __ns1__enumerateEntities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enumerateEntities(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enumerateEntities(struct soap *soap, const char *tag, int id, const struct __ns1__enumerateEntities *a, const char *type)
{
	if (soap_out_PointerTons1__enumerateEntities(soap, "ns1:enumerateEntities", -1, &a->ns1__enumerateEntities_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enumerateEntities * SOAP_FMAC4 soap_get___ns1__enumerateEntities(struct soap *soap, struct __ns1__enumerateEntities *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enumerateEntities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__enumerateEntities * SOAP_FMAC4 soap_in___ns1__enumerateEntities(struct soap *soap, const char *tag, struct __ns1__enumerateEntities *a, const char *type)
{
	size_t soap_flag_ns1__enumerateEntities_ = 1;
	short soap_flag;
	a = (struct __ns1__enumerateEntities *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enumerateEntities, sizeof(struct __ns1__enumerateEntities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enumerateEntities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__enumerateEntities_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumerateEntities(soap, "ns1:enumerateEntities", &a->ns1__enumerateEntities_, "ns1:enumerateEntities"))
				{	soap_flag_ns1__enumerateEntities_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__enumerateEntities * SOAP_FMAC6 soap_new___ns1__enumerateEntities(struct soap *soap, int n)
{	return soap_instantiate___ns1__enumerateEntities(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__enumerateEntities(struct soap *soap, struct __ns1__enumerateEntities *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__enumerateEntities * SOAP_FMAC4 soap_instantiate___ns1__enumerateEntities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enumerateEntities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enumerateEntities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__enumerateEntities;
		if (size)
			*size = sizeof(struct __ns1__enumerateEntities);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__enumerateEntities[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__enumerateEntities);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__enumerateEntities*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enumerateEntities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enumerateEntities %p -> %p\n", q, p));
	*(struct __ns1__enumerateEntities*)p = *(struct __ns1__enumerateEntities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__enumerateCustomEvents(struct soap *soap, struct __ns1__enumerateCustomEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__enumerateCustomEvents_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__enumerateCustomEvents(struct soap *soap, const struct __ns1__enumerateCustomEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__enumerateCustomEvents(soap, &a->ns1__enumerateCustomEvents_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__enumerateCustomEvents(struct soap *soap, const struct __ns1__enumerateCustomEvents *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__enumerateCustomEvents(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__enumerateCustomEvents(struct soap *soap, const char *tag, int id, const struct __ns1__enumerateCustomEvents *a, const char *type)
{
	if (soap_out_PointerTons1__enumerateCustomEvents(soap, "ns1:enumerateCustomEvents", -1, &a->ns1__enumerateCustomEvents_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__enumerateCustomEvents * SOAP_FMAC4 soap_get___ns1__enumerateCustomEvents(struct soap *soap, struct __ns1__enumerateCustomEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__enumerateCustomEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__enumerateCustomEvents * SOAP_FMAC4 soap_in___ns1__enumerateCustomEvents(struct soap *soap, const char *tag, struct __ns1__enumerateCustomEvents *a, const char *type)
{
	size_t soap_flag_ns1__enumerateCustomEvents_ = 1;
	short soap_flag;
	a = (struct __ns1__enumerateCustomEvents *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__enumerateCustomEvents, sizeof(struct __ns1__enumerateCustomEvents), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__enumerateCustomEvents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__enumerateCustomEvents_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__enumerateCustomEvents(soap, "ns1:enumerateCustomEvents", &a->ns1__enumerateCustomEvents_, "ns1:enumerateCustomEvents"))
				{	soap_flag_ns1__enumerateCustomEvents_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__enumerateCustomEvents * SOAP_FMAC6 soap_new___ns1__enumerateCustomEvents(struct soap *soap, int n)
{	return soap_instantiate___ns1__enumerateCustomEvents(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__enumerateCustomEvents(struct soap *soap, struct __ns1__enumerateCustomEvents *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__enumerateCustomEvents * SOAP_FMAC4 soap_instantiate___ns1__enumerateCustomEvents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__enumerateCustomEvents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__enumerateCustomEvents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__enumerateCustomEvents;
		if (size)
			*size = sizeof(struct __ns1__enumerateCustomEvents);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__enumerateCustomEvents[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__enumerateCustomEvents);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__enumerateCustomEvents*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__enumerateCustomEvents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__enumerateCustomEvents %p -> %p\n", q, p));
	*(struct __ns1__enumerateCustomEvents*)p = *(struct __ns1__enumerateCustomEvents*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__disassociateEntity(struct soap *soap, struct __ns1__disassociateEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__disassociateEntity_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__disassociateEntity(struct soap *soap, const struct __ns1__disassociateEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__disassociateEntity(soap, &a->ns1__disassociateEntity_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__disassociateEntity(struct soap *soap, const struct __ns1__disassociateEntity *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__disassociateEntity(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__disassociateEntity(struct soap *soap, const char *tag, int id, const struct __ns1__disassociateEntity *a, const char *type)
{
	if (soap_out_PointerTons1__disassociateEntity(soap, "ns1:disassociateEntity", -1, &a->ns1__disassociateEntity_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__disassociateEntity * SOAP_FMAC4 soap_get___ns1__disassociateEntity(struct soap *soap, struct __ns1__disassociateEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__disassociateEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__disassociateEntity * SOAP_FMAC4 soap_in___ns1__disassociateEntity(struct soap *soap, const char *tag, struct __ns1__disassociateEntity *a, const char *type)
{
	size_t soap_flag_ns1__disassociateEntity_ = 1;
	short soap_flag;
	a = (struct __ns1__disassociateEntity *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__disassociateEntity, sizeof(struct __ns1__disassociateEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__disassociateEntity(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__disassociateEntity_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__disassociateEntity(soap, "ns1:disassociateEntity", &a->ns1__disassociateEntity_, "ns1:disassociateEntity"))
				{	soap_flag_ns1__disassociateEntity_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__disassociateEntity * SOAP_FMAC6 soap_new___ns1__disassociateEntity(struct soap *soap, int n)
{	return soap_instantiate___ns1__disassociateEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__disassociateEntity(struct soap *soap, struct __ns1__disassociateEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__disassociateEntity * SOAP_FMAC4 soap_instantiate___ns1__disassociateEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__disassociateEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__disassociateEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__disassociateEntity;
		if (size)
			*size = sizeof(struct __ns1__disassociateEntity);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__disassociateEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__disassociateEntity);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__disassociateEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__disassociateEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__disassociateEntity %p -> %p\n", q, p));
	*(struct __ns1__disassociateEntity*)p = *(struct __ns1__disassociateEntity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__deleteSecretKey(struct soap *soap, struct __ns1__deleteSecretKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__deleteSecretKey_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__deleteSecretKey(struct soap *soap, const struct __ns1__deleteSecretKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__deleteSecretKey(soap, &a->ns1__deleteSecretKey_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__deleteSecretKey(struct soap *soap, const struct __ns1__deleteSecretKey *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__deleteSecretKey(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__deleteSecretKey(struct soap *soap, const char *tag, int id, const struct __ns1__deleteSecretKey *a, const char *type)
{
	if (soap_out_PointerTons1__deleteSecretKey(soap, "ns1:deleteSecretKey", -1, &a->ns1__deleteSecretKey_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__deleteSecretKey * SOAP_FMAC4 soap_get___ns1__deleteSecretKey(struct soap *soap, struct __ns1__deleteSecretKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__deleteSecretKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__deleteSecretKey * SOAP_FMAC4 soap_in___ns1__deleteSecretKey(struct soap *soap, const char *tag, struct __ns1__deleteSecretKey *a, const char *type)
{
	size_t soap_flag_ns1__deleteSecretKey_ = 1;
	short soap_flag;
	a = (struct __ns1__deleteSecretKey *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__deleteSecretKey, sizeof(struct __ns1__deleteSecretKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__deleteSecretKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__deleteSecretKey_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__deleteSecretKey(soap, "ns1:deleteSecretKey", &a->ns1__deleteSecretKey_, "ns1:deleteSecretKey"))
				{	soap_flag_ns1__deleteSecretKey_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__deleteSecretKey * SOAP_FMAC6 soap_new___ns1__deleteSecretKey(struct soap *soap, int n)
{	return soap_instantiate___ns1__deleteSecretKey(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__deleteSecretKey(struct soap *soap, struct __ns1__deleteSecretKey *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__deleteSecretKey * SOAP_FMAC4 soap_instantiate___ns1__deleteSecretKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__deleteSecretKey(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__deleteSecretKey, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__deleteSecretKey;
		if (size)
			*size = sizeof(struct __ns1__deleteSecretKey);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__deleteSecretKey[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__deleteSecretKey);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__deleteSecretKey*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__deleteSecretKey(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__deleteSecretKey %p -> %p\n", q, p));
	*(struct __ns1__deleteSecretKey*)p = *(struct __ns1__deleteSecretKey*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__defineCustomEvent(struct soap *soap, struct __ns1__defineCustomEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__defineCustomEvent_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__defineCustomEvent(struct soap *soap, const struct __ns1__defineCustomEvent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__defineCustomEvent(soap, &a->ns1__defineCustomEvent_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__defineCustomEvent(struct soap *soap, const struct __ns1__defineCustomEvent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__defineCustomEvent(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__defineCustomEvent(struct soap *soap, const char *tag, int id, const struct __ns1__defineCustomEvent *a, const char *type)
{
	if (soap_out_PointerTons1__defineCustomEvent(soap, "ns1:defineCustomEvent", -1, &a->ns1__defineCustomEvent_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__defineCustomEvent * SOAP_FMAC4 soap_get___ns1__defineCustomEvent(struct soap *soap, struct __ns1__defineCustomEvent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__defineCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__defineCustomEvent * SOAP_FMAC4 soap_in___ns1__defineCustomEvent(struct soap *soap, const char *tag, struct __ns1__defineCustomEvent *a, const char *type)
{
	size_t soap_flag_ns1__defineCustomEvent_ = 1;
	short soap_flag;
	a = (struct __ns1__defineCustomEvent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__defineCustomEvent, sizeof(struct __ns1__defineCustomEvent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__defineCustomEvent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__defineCustomEvent_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__defineCustomEvent(soap, "ns1:defineCustomEvent", &a->ns1__defineCustomEvent_, "ns1:defineCustomEvent"))
				{	soap_flag_ns1__defineCustomEvent_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__defineCustomEvent * SOAP_FMAC6 soap_new___ns1__defineCustomEvent(struct soap *soap, int n)
{	return soap_instantiate___ns1__defineCustomEvent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__defineCustomEvent(struct soap *soap, struct __ns1__defineCustomEvent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__defineCustomEvent * SOAP_FMAC4 soap_instantiate___ns1__defineCustomEvent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__defineCustomEvent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__defineCustomEvent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__defineCustomEvent;
		if (size)
			*size = sizeof(struct __ns1__defineCustomEvent);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__defineCustomEvent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__defineCustomEvent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__defineCustomEvent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__defineCustomEvent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__defineCustomEvent %p -> %p\n", q, p));
	*(struct __ns1__defineCustomEvent*)p = *(struct __ns1__defineCustomEvent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__associateEntity(struct soap *soap, struct __ns1__associateEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__associateEntity_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__associateEntity(struct soap *soap, const struct __ns1__associateEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__associateEntity(soap, &a->ns1__associateEntity_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__associateEntity(struct soap *soap, const struct __ns1__associateEntity *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__associateEntity(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__associateEntity(struct soap *soap, const char *tag, int id, const struct __ns1__associateEntity *a, const char *type)
{
	if (soap_out_PointerTons1__associateEntity(soap, "ns1:associateEntity", -1, &a->ns1__associateEntity_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__associateEntity * SOAP_FMAC4 soap_get___ns1__associateEntity(struct soap *soap, struct __ns1__associateEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__associateEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__associateEntity * SOAP_FMAC4 soap_in___ns1__associateEntity(struct soap *soap, const char *tag, struct __ns1__associateEntity *a, const char *type)
{
	size_t soap_flag_ns1__associateEntity_ = 1;
	short soap_flag;
	a = (struct __ns1__associateEntity *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__associateEntity, sizeof(struct __ns1__associateEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__associateEntity(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__associateEntity_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__associateEntity(soap, "ns1:associateEntity", &a->ns1__associateEntity_, "ns1:associateEntity"))
				{	soap_flag_ns1__associateEntity_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__associateEntity * SOAP_FMAC6 soap_new___ns1__associateEntity(struct soap *soap, int n)
{	return soap_instantiate___ns1__associateEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__associateEntity(struct soap *soap, struct __ns1__associateEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__associateEntity * SOAP_FMAC4 soap_instantiate___ns1__associateEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__associateEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__associateEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__associateEntity;
		if (size)
			*size = sizeof(struct __ns1__associateEntity);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__associateEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__associateEntity);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__associateEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__associateEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__associateEntity %p -> %p\n", q, p));
	*(struct __ns1__associateEntity*)p = *(struct __ns1__associateEntity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__addEntity(struct soap *soap, struct __ns1__addEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__addEntity_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__addEntity(struct soap *soap, const struct __ns1__addEntity *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__addEntity(soap, &a->ns1__addEntity_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__addEntity(struct soap *soap, const struct __ns1__addEntity *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__addEntity(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__addEntity(struct soap *soap, const char *tag, int id, const struct __ns1__addEntity *a, const char *type)
{
	if (soap_out_PointerTons1__addEntity(soap, "ns1:addEntity", -1, &a->ns1__addEntity_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__addEntity * SOAP_FMAC4 soap_get___ns1__addEntity(struct soap *soap, struct __ns1__addEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__addEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__addEntity * SOAP_FMAC4 soap_in___ns1__addEntity(struct soap *soap, const char *tag, struct __ns1__addEntity *a, const char *type)
{
	size_t soap_flag_ns1__addEntity_ = 1;
	short soap_flag;
	a = (struct __ns1__addEntity *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__addEntity, sizeof(struct __ns1__addEntity), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__addEntity(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__addEntity_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__addEntity(soap, "ns1:addEntity", &a->ns1__addEntity_, "ns1:addEntity"))
				{	soap_flag_ns1__addEntity_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__addEntity * SOAP_FMAC6 soap_new___ns1__addEntity(struct soap *soap, int n)
{	return soap_instantiate___ns1__addEntity(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__addEntity(struct soap *soap, struct __ns1__addEntity *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__addEntity * SOAP_FMAC4 soap_instantiate___ns1__addEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__addEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__addEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__addEntity;
		if (size)
			*size = sizeof(struct __ns1__addEntity);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__addEntity[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__addEntity);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__addEntity*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__addEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__addEntity %p -> %p\n", q, p));
	*(struct __ns1__addEntity*)p = *(struct __ns1__addEntity*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updatePolicy(struct soap *soap, struct __ns1__updatePolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updatePolicy_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updatePolicy(struct soap *soap, const struct __ns1__updatePolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updatePolicy(soap, &a->ns1__updatePolicy_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updatePolicy(struct soap *soap, const struct __ns1__updatePolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updatePolicy(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updatePolicy(struct soap *soap, const char *tag, int id, const struct __ns1__updatePolicy *a, const char *type)
{
	if (soap_out_PointerTons1__updatePolicy(soap, "ns1:updatePolicy", -1, &a->ns1__updatePolicy_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updatePolicy * SOAP_FMAC4 soap_get___ns1__updatePolicy(struct soap *soap, struct __ns1__updatePolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updatePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__updatePolicy * SOAP_FMAC4 soap_in___ns1__updatePolicy(struct soap *soap, const char *tag, struct __ns1__updatePolicy *a, const char *type)
{
	size_t soap_flag_ns1__updatePolicy_ = 1;
	short soap_flag;
	a = (struct __ns1__updatePolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updatePolicy, sizeof(struct __ns1__updatePolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updatePolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updatePolicy_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updatePolicy(soap, "ns1:updatePolicy", &a->ns1__updatePolicy_, "ns1:updatePolicy"))
				{	soap_flag_ns1__updatePolicy_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__updatePolicy * SOAP_FMAC6 soap_new___ns1__updatePolicy(struct soap *soap, int n)
{	return soap_instantiate___ns1__updatePolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__updatePolicy(struct soap *soap, struct __ns1__updatePolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__updatePolicy * SOAP_FMAC4 soap_instantiate___ns1__updatePolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updatePolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updatePolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__updatePolicy;
		if (size)
			*size = sizeof(struct __ns1__updatePolicy);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__updatePolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updatePolicy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updatePolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updatePolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updatePolicy %p -> %p\n", q, p));
	*(struct __ns1__updatePolicy*)p = *(struct __ns1__updatePolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__setPolicy(struct soap *soap, struct __ns1__setPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__setPolicy_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__setPolicy(struct soap *soap, const struct __ns1__setPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__setPolicy(soap, &a->ns1__setPolicy_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__setPolicy(struct soap *soap, const struct __ns1__setPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__setPolicy(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__setPolicy(struct soap *soap, const char *tag, int id, const struct __ns1__setPolicy *a, const char *type)
{
	if (soap_out_PointerTons1__setPolicy(soap, "ns1:setPolicy", -1, &a->ns1__setPolicy_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__setPolicy * SOAP_FMAC4 soap_get___ns1__setPolicy(struct soap *soap, struct __ns1__setPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__setPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__setPolicy * SOAP_FMAC4 soap_in___ns1__setPolicy(struct soap *soap, const char *tag, struct __ns1__setPolicy *a, const char *type)
{
	size_t soap_flag_ns1__setPolicy_ = 1;
	short soap_flag;
	a = (struct __ns1__setPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__setPolicy, sizeof(struct __ns1__setPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__setPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__setPolicy_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__setPolicy(soap, "ns1:setPolicy", &a->ns1__setPolicy_, "ns1:setPolicy"))
				{	soap_flag_ns1__setPolicy_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__setPolicy * SOAP_FMAC6 soap_new___ns1__setPolicy(struct soap *soap, int n)
{	return soap_instantiate___ns1__setPolicy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__setPolicy(struct soap *soap, struct __ns1__setPolicy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__setPolicy * SOAP_FMAC4 soap_instantiate___ns1__setPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__setPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__setPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__setPolicy;
		if (size)
			*size = sizeof(struct __ns1__setPolicy);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__setPolicy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__setPolicy);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__setPolicy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__setPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__setPolicy %p -> %p\n", q, p));
	*(struct __ns1__setPolicy*)p = *(struct __ns1__setPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__getVersion(struct soap *soap, struct __ns1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__getVersion_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__getVersion(struct soap *soap, const struct __ns1__getVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__getVersion(soap, &a->ns1__getVersion_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__getVersion(struct soap *soap, const struct __ns1__getVersion *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__getVersion(soap, tag, id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__getVersion(struct soap *soap, const char *tag, int id, const struct __ns1__getVersion *a, const char *type)
{
	if (soap_out_PointerTons1__getVersion(soap, "ns1:getVersion", -1, &a->ns1__getVersion_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__getVersion * SOAP_FMAC4 soap_get___ns1__getVersion(struct soap *soap, struct __ns1__getVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct __ns1__getVersion * SOAP_FMAC4 soap_in___ns1__getVersion(struct soap *soap, const char *tag, struct __ns1__getVersion *a, const char *type)
{
	size_t soap_flag_ns1__getVersion_ = 1;
	short soap_flag;
	a = (struct __ns1__getVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__getVersion, sizeof(struct __ns1__getVersion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__getVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__getVersion_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__getVersion(soap, "ns1:getVersion", &a->ns1__getVersion_, "ns1:getVersion"))
				{	soap_flag_ns1__getVersion_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC5 struct __ns1__getVersion * SOAP_FMAC6 soap_new___ns1__getVersion(struct soap *soap, int n)
{	return soap_instantiate___ns1__getVersion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___ns1__getVersion(struct soap *soap, struct __ns1__getVersion *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct __ns1__getVersion * SOAP_FMAC4 soap_instantiate___ns1__getVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__getVersion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__getVersion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct __ns1__getVersion;
		if (size)
			*size = sizeof(struct __ns1__getVersion);
	}
	else
	{	cp->ptr = (void*)new struct __ns1__getVersion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__getVersion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__getVersion*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__getVersion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__getVersion %p -> %p\n", q, p));
	*(struct __ns1__getVersion*)p = *(struct __ns1__getVersion*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Exception_ = NULL;
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__Exception(soap, &a->ns1__Exception_);
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_out_PointerTons1__Exception(soap, "ns1:Exception", -1, &a->ns1__Exception_, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag_ns1__Exception_ = 1;
	size_t soap_flag_fault = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Exception_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Exception(soap, "ns1:Exception", &a->ns1__Exception_, "ns1:Exception"))
				{	soap_flag_ns1__Exception_--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateCustomEventResponse(struct soap *soap, ns1__updateCustomEventResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateCustomEventResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateCustomEventResponse(struct soap *soap, ns1__updateCustomEventResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateCustomEventResponse);
	if (soap_out_PointerTons1__updateCustomEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateCustomEventResponse(struct soap *soap, const char *tag, int id, ns1__updateCustomEventResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateCustomEventResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateCustomEventResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateCustomEventResponse(struct soap *soap, ns1__updateCustomEventResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateCustomEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__updateCustomEventResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateCustomEventResponse(struct soap *soap, const char *tag, ns1__updateCustomEventResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateCustomEventResponse **)soap_malloc(soap, sizeof(ns1__updateCustomEventResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateCustomEventResponse *)soap_instantiate_ns1__updateCustomEventResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateCustomEventResponse ** p = (ns1__updateCustomEventResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateCustomEventResponse, sizeof(ns1__updateCustomEventResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateCustomEvent(struct soap *soap, ns1__updateCustomEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateCustomEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateCustomEvent(struct soap *soap, ns1__updateCustomEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateCustomEvent);
	if (soap_out_PointerTons1__updateCustomEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateCustomEvent(struct soap *soap, const char *tag, int id, ns1__updateCustomEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateCustomEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateCustomEvent ** SOAP_FMAC4 soap_get_PointerTons1__updateCustomEvent(struct soap *soap, ns1__updateCustomEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__updateCustomEvent ** SOAP_FMAC4 soap_in_PointerTons1__updateCustomEvent(struct soap *soap, const char *tag, ns1__updateCustomEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateCustomEvent **)soap_malloc(soap, sizeof(ns1__updateCustomEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateCustomEvent *)soap_instantiate_ns1__updateCustomEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateCustomEvent ** p = (ns1__updateCustomEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateCustomEvent, sizeof(ns1__updateCustomEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__unsubscribePredefinedEventResponse(struct soap *soap, ns1__unsubscribePredefinedEventResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__unsubscribePredefinedEventResponse(struct soap *soap, ns1__unsubscribePredefinedEventResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__unsubscribePredefinedEventResponse);
	if (soap_out_PointerTons1__unsubscribePredefinedEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__unsubscribePredefinedEventResponse(struct soap *soap, const char *tag, int id, ns1__unsubscribePredefinedEventResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEventResponse ** SOAP_FMAC4 soap_get_PointerTons1__unsubscribePredefinedEventResponse(struct soap *soap, ns1__unsubscribePredefinedEventResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__unsubscribePredefinedEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__unsubscribePredefinedEventResponse ** SOAP_FMAC4 soap_in_PointerTons1__unsubscribePredefinedEventResponse(struct soap *soap, const char *tag, ns1__unsubscribePredefinedEventResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__unsubscribePredefinedEventResponse **)soap_malloc(soap, sizeof(ns1__unsubscribePredefinedEventResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__unsubscribePredefinedEventResponse *)soap_instantiate_ns1__unsubscribePredefinedEventResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__unsubscribePredefinedEventResponse ** p = (ns1__unsubscribePredefinedEventResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__unsubscribePredefinedEventResponse, sizeof(ns1__unsubscribePredefinedEventResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__unsubscribePredefinedEvent(struct soap *soap, ns1__unsubscribePredefinedEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__unsubscribePredefinedEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__unsubscribePredefinedEvent(struct soap *soap, ns1__unsubscribePredefinedEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__unsubscribePredefinedEvent);
	if (soap_out_PointerTons1__unsubscribePredefinedEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__unsubscribePredefinedEvent(struct soap *soap, const char *tag, int id, ns1__unsubscribePredefinedEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__unsubscribePredefinedEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__unsubscribePredefinedEvent ** SOAP_FMAC4 soap_get_PointerTons1__unsubscribePredefinedEvent(struct soap *soap, ns1__unsubscribePredefinedEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__unsubscribePredefinedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__unsubscribePredefinedEvent ** SOAP_FMAC4 soap_in_PointerTons1__unsubscribePredefinedEvent(struct soap *soap, const char *tag, ns1__unsubscribePredefinedEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__unsubscribePredefinedEvent **)soap_malloc(soap, sizeof(ns1__unsubscribePredefinedEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__unsubscribePredefinedEvent *)soap_instantiate_ns1__unsubscribePredefinedEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__unsubscribePredefinedEvent ** p = (ns1__unsubscribePredefinedEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__unsubscribePredefinedEvent, sizeof(ns1__unsubscribePredefinedEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__unsubscribeEventHandlerResponse(struct soap *soap, ns1__unsubscribeEventHandlerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__unsubscribeEventHandlerResponse(struct soap *soap, ns1__unsubscribeEventHandlerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__unsubscribeEventHandlerResponse);
	if (soap_out_PointerTons1__unsubscribeEventHandlerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__unsubscribeEventHandlerResponse(struct soap *soap, const char *tag, int id, ns1__unsubscribeEventHandlerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__unsubscribeEventHandlerResponse ** SOAP_FMAC4 soap_get_PointerTons1__unsubscribeEventHandlerResponse(struct soap *soap, ns1__unsubscribeEventHandlerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__unsubscribeEventHandlerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__unsubscribeEventHandlerResponse ** SOAP_FMAC4 soap_in_PointerTons1__unsubscribeEventHandlerResponse(struct soap *soap, const char *tag, ns1__unsubscribeEventHandlerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__unsubscribeEventHandlerResponse **)soap_malloc(soap, sizeof(ns1__unsubscribeEventHandlerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__unsubscribeEventHandlerResponse *)soap_instantiate_ns1__unsubscribeEventHandlerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__unsubscribeEventHandlerResponse ** p = (ns1__unsubscribeEventHandlerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__unsubscribeEventHandlerResponse, sizeof(ns1__unsubscribeEventHandlerResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__unsubscribeEventHandler(struct soap *soap, ns1__unsubscribeEventHandler *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__unsubscribeEventHandler))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__unsubscribeEventHandler(struct soap *soap, ns1__unsubscribeEventHandler *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__unsubscribeEventHandler);
	if (soap_out_PointerTons1__unsubscribeEventHandler(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__unsubscribeEventHandler(struct soap *soap, const char *tag, int id, ns1__unsubscribeEventHandler *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__unsubscribeEventHandler);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__unsubscribeEventHandler ** SOAP_FMAC4 soap_get_PointerTons1__unsubscribeEventHandler(struct soap *soap, ns1__unsubscribeEventHandler **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__unsubscribeEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__unsubscribeEventHandler ** SOAP_FMAC4 soap_in_PointerTons1__unsubscribeEventHandler(struct soap *soap, const char *tag, ns1__unsubscribeEventHandler **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__unsubscribeEventHandler **)soap_malloc(soap, sizeof(ns1__unsubscribeEventHandler *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__unsubscribeEventHandler *)soap_instantiate_ns1__unsubscribeEventHandler(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__unsubscribeEventHandler ** p = (ns1__unsubscribeEventHandler **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__unsubscribeEventHandler, sizeof(ns1__unsubscribeEventHandler), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__subscribePredefinedEventResponse(struct soap *soap, ns1__subscribePredefinedEventResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__subscribePredefinedEventResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__subscribePredefinedEventResponse(struct soap *soap, ns1__subscribePredefinedEventResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__subscribePredefinedEventResponse);
	if (soap_out_PointerTons1__subscribePredefinedEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__subscribePredefinedEventResponse(struct soap *soap, const char *tag, int id, ns1__subscribePredefinedEventResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__subscribePredefinedEventResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__subscribePredefinedEventResponse ** SOAP_FMAC4 soap_get_PointerTons1__subscribePredefinedEventResponse(struct soap *soap, ns1__subscribePredefinedEventResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__subscribePredefinedEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__subscribePredefinedEventResponse ** SOAP_FMAC4 soap_in_PointerTons1__subscribePredefinedEventResponse(struct soap *soap, const char *tag, ns1__subscribePredefinedEventResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__subscribePredefinedEventResponse **)soap_malloc(soap, sizeof(ns1__subscribePredefinedEventResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__subscribePredefinedEventResponse *)soap_instantiate_ns1__subscribePredefinedEventResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__subscribePredefinedEventResponse ** p = (ns1__subscribePredefinedEventResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__subscribePredefinedEventResponse, sizeof(ns1__subscribePredefinedEventResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__subscribePredefinedEvent(struct soap *soap, ns1__subscribePredefinedEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__subscribePredefinedEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__subscribePredefinedEvent(struct soap *soap, ns1__subscribePredefinedEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__subscribePredefinedEvent);
	if (soap_out_PointerTons1__subscribePredefinedEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__subscribePredefinedEvent(struct soap *soap, const char *tag, int id, ns1__subscribePredefinedEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__subscribePredefinedEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__subscribePredefinedEvent ** SOAP_FMAC4 soap_get_PointerTons1__subscribePredefinedEvent(struct soap *soap, ns1__subscribePredefinedEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__subscribePredefinedEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__subscribePredefinedEvent ** SOAP_FMAC4 soap_in_PointerTons1__subscribePredefinedEvent(struct soap *soap, const char *tag, ns1__subscribePredefinedEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__subscribePredefinedEvent **)soap_malloc(soap, sizeof(ns1__subscribePredefinedEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__subscribePredefinedEvent *)soap_instantiate_ns1__subscribePredefinedEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__subscribePredefinedEvent ** p = (ns1__subscribePredefinedEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__subscribePredefinedEvent, sizeof(ns1__subscribePredefinedEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__subscribeEventHandlerResponse(struct soap *soap, ns1__subscribeEventHandlerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__subscribeEventHandlerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__subscribeEventHandlerResponse(struct soap *soap, ns1__subscribeEventHandlerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__subscribeEventHandlerResponse);
	if (soap_out_PointerTons1__subscribeEventHandlerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__subscribeEventHandlerResponse(struct soap *soap, const char *tag, int id, ns1__subscribeEventHandlerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__subscribeEventHandlerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__subscribeEventHandlerResponse ** SOAP_FMAC4 soap_get_PointerTons1__subscribeEventHandlerResponse(struct soap *soap, ns1__subscribeEventHandlerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__subscribeEventHandlerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__subscribeEventHandlerResponse ** SOAP_FMAC4 soap_in_PointerTons1__subscribeEventHandlerResponse(struct soap *soap, const char *tag, ns1__subscribeEventHandlerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__subscribeEventHandlerResponse **)soap_malloc(soap, sizeof(ns1__subscribeEventHandlerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__subscribeEventHandlerResponse *)soap_instantiate_ns1__subscribeEventHandlerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__subscribeEventHandlerResponse ** p = (ns1__subscribeEventHandlerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__subscribeEventHandlerResponse, sizeof(ns1__subscribeEventHandlerResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__subscribeEventHandler(struct soap *soap, ns1__subscribeEventHandler *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__subscribeEventHandler))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__subscribeEventHandler(struct soap *soap, ns1__subscribeEventHandler *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__subscribeEventHandler);
	if (soap_out_PointerTons1__subscribeEventHandler(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__subscribeEventHandler(struct soap *soap, const char *tag, int id, ns1__subscribeEventHandler *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__subscribeEventHandler);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__subscribeEventHandler ** SOAP_FMAC4 soap_get_PointerTons1__subscribeEventHandler(struct soap *soap, ns1__subscribeEventHandler **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__subscribeEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__subscribeEventHandler ** SOAP_FMAC4 soap_in_PointerTons1__subscribeEventHandler(struct soap *soap, const char *tag, ns1__subscribeEventHandler **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__subscribeEventHandler **)soap_malloc(soap, sizeof(ns1__subscribeEventHandler *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__subscribeEventHandler *)soap_instantiate_ns1__subscribeEventHandler(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__subscribeEventHandler ** p = (ns1__subscribeEventHandler **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__subscribeEventHandler, sizeof(ns1__subscribeEventHandler), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__submitSecretKeyResponse(struct soap *soap, ns1__submitSecretKeyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__submitSecretKeyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__submitSecretKeyResponse(struct soap *soap, ns1__submitSecretKeyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__submitSecretKeyResponse);
	if (soap_out_PointerTons1__submitSecretKeyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__submitSecretKeyResponse(struct soap *soap, const char *tag, int id, ns1__submitSecretKeyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__submitSecretKeyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__submitSecretKeyResponse ** SOAP_FMAC4 soap_get_PointerTons1__submitSecretKeyResponse(struct soap *soap, ns1__submitSecretKeyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__submitSecretKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__submitSecretKeyResponse ** SOAP_FMAC4 soap_in_PointerTons1__submitSecretKeyResponse(struct soap *soap, const char *tag, ns1__submitSecretKeyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__submitSecretKeyResponse **)soap_malloc(soap, sizeof(ns1__submitSecretKeyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__submitSecretKeyResponse *)soap_instantiate_ns1__submitSecretKeyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__submitSecretKeyResponse ** p = (ns1__submitSecretKeyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__submitSecretKeyResponse, sizeof(ns1__submitSecretKeyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__submitSecretKey(struct soap *soap, ns1__submitSecretKey *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__submitSecretKey))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__submitSecretKey(struct soap *soap, ns1__submitSecretKey *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__submitSecretKey);
	if (soap_out_PointerTons1__submitSecretKey(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__submitSecretKey(struct soap *soap, const char *tag, int id, ns1__submitSecretKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__submitSecretKey);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__submitSecretKey ** SOAP_FMAC4 soap_get_PointerTons1__submitSecretKey(struct soap *soap, ns1__submitSecretKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__submitSecretKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__submitSecretKey ** SOAP_FMAC4 soap_in_PointerTons1__submitSecretKey(struct soap *soap, const char *tag, ns1__submitSecretKey **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__submitSecretKey **)soap_malloc(soap, sizeof(ns1__submitSecretKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__submitSecretKey *)soap_instantiate_ns1__submitSecretKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__submitSecretKey ** p = (ns1__submitSecretKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__submitSecretKey, sizeof(ns1__submitSecretKey), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setPolicyStateResponse(struct soap *soap, ns1__setPolicyStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setPolicyStateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setPolicyStateResponse(struct soap *soap, ns1__setPolicyStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setPolicyStateResponse);
	if (soap_out_PointerTons1__setPolicyStateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setPolicyStateResponse(struct soap *soap, const char *tag, int id, ns1__setPolicyStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setPolicyStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setPolicyStateResponse ** SOAP_FMAC4 soap_get_PointerTons1__setPolicyStateResponse(struct soap *soap, ns1__setPolicyStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setPolicyStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setPolicyStateResponse ** SOAP_FMAC4 soap_in_PointerTons1__setPolicyStateResponse(struct soap *soap, const char *tag, ns1__setPolicyStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setPolicyStateResponse **)soap_malloc(soap, sizeof(ns1__setPolicyStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setPolicyStateResponse *)soap_instantiate_ns1__setPolicyStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setPolicyStateResponse ** p = (ns1__setPolicyStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setPolicyStateResponse, sizeof(ns1__setPolicyStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setPolicyState(struct soap *soap, ns1__setPolicyState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setPolicyState))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setPolicyState(struct soap *soap, ns1__setPolicyState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setPolicyState);
	if (soap_out_PointerTons1__setPolicyState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setPolicyState(struct soap *soap, const char *tag, int id, ns1__setPolicyState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setPolicyState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setPolicyState ** SOAP_FMAC4 soap_get_PointerTons1__setPolicyState(struct soap *soap, ns1__setPolicyState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setPolicyState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setPolicyState ** SOAP_FMAC4 soap_in_PointerTons1__setPolicyState(struct soap *soap, const char *tag, ns1__setPolicyState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setPolicyState **)soap_malloc(soap, sizeof(ns1__setPolicyState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setPolicyState *)soap_instantiate_ns1__setPolicyState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setPolicyState ** p = (ns1__setPolicyState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setPolicyState, sizeof(ns1__setPolicyState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setGlobalPropertyResponse(struct soap *soap, ns1__setGlobalPropertyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setGlobalPropertyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setGlobalPropertyResponse(struct soap *soap, ns1__setGlobalPropertyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setGlobalPropertyResponse);
	if (soap_out_PointerTons1__setGlobalPropertyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setGlobalPropertyResponse(struct soap *soap, const char *tag, int id, ns1__setGlobalPropertyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setGlobalPropertyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setGlobalPropertyResponse ** SOAP_FMAC4 soap_get_PointerTons1__setGlobalPropertyResponse(struct soap *soap, ns1__setGlobalPropertyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setGlobalPropertyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setGlobalPropertyResponse ** SOAP_FMAC4 soap_in_PointerTons1__setGlobalPropertyResponse(struct soap *soap, const char *tag, ns1__setGlobalPropertyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setGlobalPropertyResponse **)soap_malloc(soap, sizeof(ns1__setGlobalPropertyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setGlobalPropertyResponse *)soap_instantiate_ns1__setGlobalPropertyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setGlobalPropertyResponse ** p = (ns1__setGlobalPropertyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setGlobalPropertyResponse, sizeof(ns1__setGlobalPropertyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setGlobalProperty(struct soap *soap, ns1__setGlobalProperty *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setGlobalProperty))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setGlobalProperty(struct soap *soap, ns1__setGlobalProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setGlobalProperty);
	if (soap_out_PointerTons1__setGlobalProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setGlobalProperty(struct soap *soap, const char *tag, int id, ns1__setGlobalProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setGlobalProperty);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setGlobalProperty ** SOAP_FMAC4 soap_get_PointerTons1__setGlobalProperty(struct soap *soap, ns1__setGlobalProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setGlobalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setGlobalProperty ** SOAP_FMAC4 soap_in_PointerTons1__setGlobalProperty(struct soap *soap, const char *tag, ns1__setGlobalProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setGlobalProperty **)soap_malloc(soap, sizeof(ns1__setGlobalProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setGlobalProperty *)soap_instantiate_ns1__setGlobalProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setGlobalProperty ** p = (ns1__setGlobalProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setGlobalProperty, sizeof(ns1__setGlobalProperty), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setEventStateResponse(struct soap *soap, ns1__setEventStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setEventStateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setEventStateResponse(struct soap *soap, ns1__setEventStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setEventStateResponse);
	if (soap_out_PointerTons1__setEventStateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setEventStateResponse(struct soap *soap, const char *tag, int id, ns1__setEventStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setEventStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setEventStateResponse ** SOAP_FMAC4 soap_get_PointerTons1__setEventStateResponse(struct soap *soap, ns1__setEventStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setEventStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setEventStateResponse ** SOAP_FMAC4 soap_in_PointerTons1__setEventStateResponse(struct soap *soap, const char *tag, ns1__setEventStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setEventStateResponse **)soap_malloc(soap, sizeof(ns1__setEventStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setEventStateResponse *)soap_instantiate_ns1__setEventStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setEventStateResponse ** p = (ns1__setEventStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setEventStateResponse, sizeof(ns1__setEventStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setEventState(struct soap *soap, ns1__setEventState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setEventState))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setEventState(struct soap *soap, ns1__setEventState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setEventState);
	if (soap_out_PointerTons1__setEventState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setEventState(struct soap *soap, const char *tag, int id, ns1__setEventState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setEventState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setEventState ** SOAP_FMAC4 soap_get_PointerTons1__setEventState(struct soap *soap, ns1__setEventState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setEventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setEventState ** SOAP_FMAC4 soap_in_PointerTons1__setEventState(struct soap *soap, const char *tag, ns1__setEventState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setEventState **)soap_malloc(soap, sizeof(ns1__setEventState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setEventState *)soap_instantiate_ns1__setEventState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setEventState ** p = (ns1__setEventState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setEventState, sizeof(ns1__setEventState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setEntityPropertiesResponse(struct soap *soap, ns1__setEntityPropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setEntityPropertiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setEntityPropertiesResponse(struct soap *soap, ns1__setEntityPropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setEntityPropertiesResponse);
	if (soap_out_PointerTons1__setEntityPropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setEntityPropertiesResponse(struct soap *soap, const char *tag, int id, ns1__setEntityPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setEntityPropertiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setEntityPropertiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__setEntityPropertiesResponse(struct soap *soap, ns1__setEntityPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setEntityPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setEntityPropertiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__setEntityPropertiesResponse(struct soap *soap, const char *tag, ns1__setEntityPropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setEntityPropertiesResponse **)soap_malloc(soap, sizeof(ns1__setEntityPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setEntityPropertiesResponse *)soap_instantiate_ns1__setEntityPropertiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setEntityPropertiesResponse ** p = (ns1__setEntityPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setEntityPropertiesResponse, sizeof(ns1__setEntityPropertiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setEntityProperties(struct soap *soap, ns1__setEntityProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setEntityProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setEntityProperties(struct soap *soap, ns1__setEntityProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setEntityProperties);
	if (soap_out_PointerTons1__setEntityProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setEntityProperties(struct soap *soap, const char *tag, int id, ns1__setEntityProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setEntityProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setEntityProperties ** SOAP_FMAC4 soap_get_PointerTons1__setEntityProperties(struct soap *soap, ns1__setEntityProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setEntityProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setEntityProperties ** SOAP_FMAC4 soap_in_PointerTons1__setEntityProperties(struct soap *soap, const char *tag, ns1__setEntityProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setEntityProperties **)soap_malloc(soap, sizeof(ns1__setEntityProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setEntityProperties *)soap_instantiate_ns1__setEntityProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setEntityProperties ** p = (ns1__setEntityProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setEntityProperties, sizeof(ns1__setEntityProperties), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setCollectionStateResponse(struct soap *soap, ns1__setCollectionStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setCollectionStateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setCollectionStateResponse(struct soap *soap, ns1__setCollectionStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setCollectionStateResponse);
	if (soap_out_PointerTons1__setCollectionStateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setCollectionStateResponse(struct soap *soap, const char *tag, int id, ns1__setCollectionStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setCollectionStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setCollectionStateResponse ** SOAP_FMAC4 soap_get_PointerTons1__setCollectionStateResponse(struct soap *soap, ns1__setCollectionStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setCollectionStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setCollectionStateResponse ** SOAP_FMAC4 soap_in_PointerTons1__setCollectionStateResponse(struct soap *soap, const char *tag, ns1__setCollectionStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setCollectionStateResponse **)soap_malloc(soap, sizeof(ns1__setCollectionStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setCollectionStateResponse *)soap_instantiate_ns1__setCollectionStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setCollectionStateResponse ** p = (ns1__setCollectionStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setCollectionStateResponse, sizeof(ns1__setCollectionStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setCollectionState(struct soap *soap, ns1__setCollectionState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setCollectionState))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setCollectionState(struct soap *soap, ns1__setCollectionState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setCollectionState);
	if (soap_out_PointerTons1__setCollectionState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setCollectionState(struct soap *soap, const char *tag, int id, ns1__setCollectionState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setCollectionState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setCollectionState ** SOAP_FMAC4 soap_get_PointerTons1__setCollectionState(struct soap *soap, ns1__setCollectionState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setCollectionState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setCollectionState ** SOAP_FMAC4 soap_in_PointerTons1__setCollectionState(struct soap *soap, const char *tag, ns1__setCollectionState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setCollectionState **)soap_malloc(soap, sizeof(ns1__setCollectionState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setCollectionState *)soap_instantiate_ns1__setCollectionState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setCollectionState ** p = (ns1__setCollectionState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setCollectionState, sizeof(ns1__setCollectionState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__schedulePolicyResponse(struct soap *soap, ns1__schedulePolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__schedulePolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__schedulePolicyResponse(struct soap *soap, ns1__schedulePolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__schedulePolicyResponse);
	if (soap_out_PointerTons1__schedulePolicyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__schedulePolicyResponse(struct soap *soap, const char *tag, int id, ns1__schedulePolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__schedulePolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__schedulePolicyResponse ** SOAP_FMAC4 soap_get_PointerTons1__schedulePolicyResponse(struct soap *soap, ns1__schedulePolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__schedulePolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__schedulePolicyResponse ** SOAP_FMAC4 soap_in_PointerTons1__schedulePolicyResponse(struct soap *soap, const char *tag, ns1__schedulePolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__schedulePolicyResponse **)soap_malloc(soap, sizeof(ns1__schedulePolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__schedulePolicyResponse *)soap_instantiate_ns1__schedulePolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__schedulePolicyResponse ** p = (ns1__schedulePolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__schedulePolicyResponse, sizeof(ns1__schedulePolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__schedulePolicy(struct soap *soap, ns1__schedulePolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__schedulePolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__schedulePolicy(struct soap *soap, ns1__schedulePolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__schedulePolicy);
	if (soap_out_PointerTons1__schedulePolicy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__schedulePolicy(struct soap *soap, const char *tag, int id, ns1__schedulePolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__schedulePolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__schedulePolicy ** SOAP_FMAC4 soap_get_PointerTons1__schedulePolicy(struct soap *soap, ns1__schedulePolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__schedulePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__schedulePolicy ** SOAP_FMAC4 soap_in_PointerTons1__schedulePolicy(struct soap *soap, const char *tag, ns1__schedulePolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__schedulePolicy **)soap_malloc(soap, sizeof(ns1__schedulePolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__schedulePolicy *)soap_instantiate_ns1__schedulePolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__schedulePolicy ** p = (ns1__schedulePolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__schedulePolicy, sizeof(ns1__schedulePolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removePolicyResponse(struct soap *soap, ns1__removePolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removePolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removePolicyResponse(struct soap *soap, ns1__removePolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removePolicyResponse);
	if (soap_out_PointerTons1__removePolicyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removePolicyResponse(struct soap *soap, const char *tag, int id, ns1__removePolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removePolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removePolicyResponse ** SOAP_FMAC4 soap_get_PointerTons1__removePolicyResponse(struct soap *soap, ns1__removePolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removePolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__removePolicyResponse ** SOAP_FMAC4 soap_in_PointerTons1__removePolicyResponse(struct soap *soap, const char *tag, ns1__removePolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removePolicyResponse **)soap_malloc(soap, sizeof(ns1__removePolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removePolicyResponse *)soap_instantiate_ns1__removePolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removePolicyResponse ** p = (ns1__removePolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removePolicyResponse, sizeof(ns1__removePolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removePolicy(struct soap *soap, ns1__removePolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removePolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removePolicy(struct soap *soap, ns1__removePolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removePolicy);
	if (soap_out_PointerTons1__removePolicy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removePolicy(struct soap *soap, const char *tag, int id, ns1__removePolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removePolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removePolicy ** SOAP_FMAC4 soap_get_PointerTons1__removePolicy(struct soap *soap, ns1__removePolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__removePolicy ** SOAP_FMAC4 soap_in_PointerTons1__removePolicy(struct soap *soap, const char *tag, ns1__removePolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removePolicy **)soap_malloc(soap, sizeof(ns1__removePolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removePolicy *)soap_instantiate_ns1__removePolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removePolicy ** p = (ns1__removePolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removePolicy, sizeof(ns1__removePolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeEntityResponse(struct soap *soap, ns1__removeEntityResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeEntityResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeEntityResponse(struct soap *soap, ns1__removeEntityResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeEntityResponse);
	if (soap_out_PointerTons1__removeEntityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeEntityResponse(struct soap *soap, const char *tag, int id, ns1__removeEntityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeEntityResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeEntityResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeEntityResponse(struct soap *soap, ns1__removeEntityResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__removeEntityResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeEntityResponse(struct soap *soap, const char *tag, ns1__removeEntityResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeEntityResponse **)soap_malloc(soap, sizeof(ns1__removeEntityResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeEntityResponse *)soap_instantiate_ns1__removeEntityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeEntityResponse ** p = (ns1__removeEntityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeEntityResponse, sizeof(ns1__removeEntityResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeEntity(struct soap *soap, ns1__removeEntity *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeEntity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeEntity(struct soap *soap, ns1__removeEntity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeEntity);
	if (soap_out_PointerTons1__removeEntity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeEntity(struct soap *soap, const char *tag, int id, ns1__removeEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeEntity);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeEntity ** SOAP_FMAC4 soap_get_PointerTons1__removeEntity(struct soap *soap, ns1__removeEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__removeEntity ** SOAP_FMAC4 soap_in_PointerTons1__removeEntity(struct soap *soap, const char *tag, ns1__removeEntity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeEntity **)soap_malloc(soap, sizeof(ns1__removeEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeEntity *)soap_instantiate_ns1__removeEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeEntity ** p = (ns1__removeEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeEntity, sizeof(ns1__removeEntity), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeCustomEventResponse(struct soap *soap, ns1__removeCustomEventResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeCustomEventResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeCustomEventResponse(struct soap *soap, ns1__removeCustomEventResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeCustomEventResponse);
	if (soap_out_PointerTons1__removeCustomEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeCustomEventResponse(struct soap *soap, const char *tag, int id, ns1__removeCustomEventResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeCustomEventResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeCustomEventResponse ** SOAP_FMAC4 soap_get_PointerTons1__removeCustomEventResponse(struct soap *soap, ns1__removeCustomEventResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeCustomEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__removeCustomEventResponse ** SOAP_FMAC4 soap_in_PointerTons1__removeCustomEventResponse(struct soap *soap, const char *tag, ns1__removeCustomEventResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeCustomEventResponse **)soap_malloc(soap, sizeof(ns1__removeCustomEventResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeCustomEventResponse *)soap_instantiate_ns1__removeCustomEventResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeCustomEventResponse ** p = (ns1__removeCustomEventResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeCustomEventResponse, sizeof(ns1__removeCustomEventResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__removeCustomEvent(struct soap *soap, ns1__removeCustomEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__removeCustomEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__removeCustomEvent(struct soap *soap, ns1__removeCustomEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__removeCustomEvent);
	if (soap_out_PointerTons1__removeCustomEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__removeCustomEvent(struct soap *soap, const char *tag, int id, ns1__removeCustomEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__removeCustomEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__removeCustomEvent ** SOAP_FMAC4 soap_get_PointerTons1__removeCustomEvent(struct soap *soap, ns1__removeCustomEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__removeCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__removeCustomEvent ** SOAP_FMAC4 soap_in_PointerTons1__removeCustomEvent(struct soap *soap, const char *tag, ns1__removeCustomEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__removeCustomEvent **)soap_malloc(soap, sizeof(ns1__removeCustomEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__removeCustomEvent *)soap_instantiate_ns1__removeCustomEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__removeCustomEvent ** p = (ns1__removeCustomEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__removeCustomEvent, sizeof(ns1__removeCustomEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__rediscoverNodeCapabilitiesResponse(struct soap *soap, ns1__rediscoverNodeCapabilitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__rediscoverNodeCapabilitiesResponse(struct soap *soap, ns1__rediscoverNodeCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__rediscoverNodeCapabilitiesResponse);
	if (soap_out_PointerTons1__rediscoverNodeCapabilitiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__rediscoverNodeCapabilitiesResponse(struct soap *soap, const char *tag, int id, ns1__rediscoverNodeCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__rediscoverNodeCapabilitiesResponse(struct soap *soap, ns1__rediscoverNodeCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__rediscoverNodeCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__rediscoverNodeCapabilitiesResponse(struct soap *soap, const char *tag, ns1__rediscoverNodeCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__rediscoverNodeCapabilitiesResponse **)soap_malloc(soap, sizeof(ns1__rediscoverNodeCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__rediscoverNodeCapabilitiesResponse *)soap_instantiate_ns1__rediscoverNodeCapabilitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__rediscoverNodeCapabilitiesResponse ** p = (ns1__rediscoverNodeCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse, sizeof(ns1__rediscoverNodeCapabilitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__rediscoverNodeCapabilities(struct soap *soap, ns1__rediscoverNodeCapabilities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__rediscoverNodeCapabilities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__rediscoverNodeCapabilities(struct soap *soap, ns1__rediscoverNodeCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__rediscoverNodeCapabilities);
	if (soap_out_PointerTons1__rediscoverNodeCapabilities(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__rediscoverNodeCapabilities(struct soap *soap, const char *tag, int id, ns1__rediscoverNodeCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__rediscoverNodeCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilities ** SOAP_FMAC4 soap_get_PointerTons1__rediscoverNodeCapabilities(struct soap *soap, ns1__rediscoverNodeCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__rediscoverNodeCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__rediscoverNodeCapabilities ** SOAP_FMAC4 soap_in_PointerTons1__rediscoverNodeCapabilities(struct soap *soap, const char *tag, ns1__rediscoverNodeCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__rediscoverNodeCapabilities **)soap_malloc(soap, sizeof(ns1__rediscoverNodeCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__rediscoverNodeCapabilities *)soap_instantiate_ns1__rediscoverNodeCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__rediscoverNodeCapabilities ** p = (ns1__rediscoverNodeCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__rediscoverNodeCapabilities, sizeof(ns1__rediscoverNodeCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__isPolicyActiveResponse(struct soap *soap, ns1__isPolicyActiveResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__isPolicyActiveResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__isPolicyActiveResponse(struct soap *soap, ns1__isPolicyActiveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__isPolicyActiveResponse);
	if (soap_out_PointerTons1__isPolicyActiveResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__isPolicyActiveResponse(struct soap *soap, const char *tag, int id, ns1__isPolicyActiveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__isPolicyActiveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__isPolicyActiveResponse ** SOAP_FMAC4 soap_get_PointerTons1__isPolicyActiveResponse(struct soap *soap, ns1__isPolicyActiveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__isPolicyActiveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__isPolicyActiveResponse ** SOAP_FMAC4 soap_in_PointerTons1__isPolicyActiveResponse(struct soap *soap, const char *tag, ns1__isPolicyActiveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__isPolicyActiveResponse **)soap_malloc(soap, sizeof(ns1__isPolicyActiveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__isPolicyActiveResponse *)soap_instantiate_ns1__isPolicyActiveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__isPolicyActiveResponse ** p = (ns1__isPolicyActiveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__isPolicyActiveResponse, sizeof(ns1__isPolicyActiveResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__isPolicyActive(struct soap *soap, ns1__isPolicyActive *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__isPolicyActive))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__isPolicyActive(struct soap *soap, ns1__isPolicyActive *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__isPolicyActive);
	if (soap_out_PointerTons1__isPolicyActive(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__isPolicyActive(struct soap *soap, const char *tag, int id, ns1__isPolicyActive *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__isPolicyActive);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__isPolicyActive ** SOAP_FMAC4 soap_get_PointerTons1__isPolicyActive(struct soap *soap, ns1__isPolicyActive **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__isPolicyActive(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__isPolicyActive ** SOAP_FMAC4 soap_in_PointerTons1__isPolicyActive(struct soap *soap, const char *tag, ns1__isPolicyActive **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__isPolicyActive **)soap_malloc(soap, sizeof(ns1__isPolicyActive *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__isPolicyActive *)soap_instantiate_ns1__isPolicyActive(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__isPolicyActive ** p = (ns1__isPolicyActive **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__isPolicyActive, sizeof(ns1__isPolicyActive), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__importHierarchyResponse(struct soap *soap, ns1__importHierarchyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__importHierarchyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__importHierarchyResponse(struct soap *soap, ns1__importHierarchyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__importHierarchyResponse);
	if (soap_out_PointerTons1__importHierarchyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__importHierarchyResponse(struct soap *soap, const char *tag, int id, ns1__importHierarchyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__importHierarchyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__importHierarchyResponse ** SOAP_FMAC4 soap_get_PointerTons1__importHierarchyResponse(struct soap *soap, ns1__importHierarchyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__importHierarchyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__importHierarchyResponse ** SOAP_FMAC4 soap_in_PointerTons1__importHierarchyResponse(struct soap *soap, const char *tag, ns1__importHierarchyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__importHierarchyResponse **)soap_malloc(soap, sizeof(ns1__importHierarchyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__importHierarchyResponse *)soap_instantiate_ns1__importHierarchyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__importHierarchyResponse ** p = (ns1__importHierarchyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__importHierarchyResponse, sizeof(ns1__importHierarchyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__importHierarchy(struct soap *soap, ns1__importHierarchy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__importHierarchy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__importHierarchy(struct soap *soap, ns1__importHierarchy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__importHierarchy);
	if (soap_out_PointerTons1__importHierarchy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__importHierarchy(struct soap *soap, const char *tag, int id, ns1__importHierarchy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__importHierarchy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__importHierarchy ** SOAP_FMAC4 soap_get_PointerTons1__importHierarchy(struct soap *soap, ns1__importHierarchy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__importHierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__importHierarchy ** SOAP_FMAC4 soap_in_PointerTons1__importHierarchy(struct soap *soap, const char *tag, ns1__importHierarchy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__importHierarchy **)soap_malloc(soap, sizeof(ns1__importHierarchy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__importHierarchy *)soap_instantiate_ns1__importHierarchy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__importHierarchy ** p = (ns1__importHierarchy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__importHierarchy, sizeof(ns1__importHierarchy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getQueryDataResponse(struct soap *soap, ns1__getQueryDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getQueryDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getQueryDataResponse(struct soap *soap, ns1__getQueryDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getQueryDataResponse);
	if (soap_out_PointerTons1__getQueryDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getQueryDataResponse(struct soap *soap, const char *tag, int id, ns1__getQueryDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getQueryDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getQueryDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__getQueryDataResponse(struct soap *soap, ns1__getQueryDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getQueryDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getQueryDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__getQueryDataResponse(struct soap *soap, const char *tag, ns1__getQueryDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getQueryDataResponse **)soap_malloc(soap, sizeof(ns1__getQueryDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getQueryDataResponse *)soap_instantiate_ns1__getQueryDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getQueryDataResponse ** p = (ns1__getQueryDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getQueryDataResponse, sizeof(ns1__getQueryDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getQueryData(struct soap *soap, ns1__getQueryData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getQueryData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getQueryData(struct soap *soap, ns1__getQueryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getQueryData);
	if (soap_out_PointerTons1__getQueryData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getQueryData(struct soap *soap, const char *tag, int id, ns1__getQueryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getQueryData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getQueryData ** SOAP_FMAC4 soap_get_PointerTons1__getQueryData(struct soap *soap, ns1__getQueryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getQueryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getQueryData ** SOAP_FMAC4 soap_in_PointerTons1__getQueryData(struct soap *soap, const char *tag, ns1__getQueryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getQueryData **)soap_malloc(soap, sizeof(ns1__getQueryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getQueryData *)soap_instantiate_ns1__getQueryData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getQueryData ** p = (ns1__getQueryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getQueryData, sizeof(ns1__getQueryData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getQueryAggregationPeriodListResponse(struct soap *soap, ns1__getQueryAggregationPeriodListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getQueryAggregationPeriodListResponse(struct soap *soap, ns1__getQueryAggregationPeriodListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getQueryAggregationPeriodListResponse);
	if (soap_out_PointerTons1__getQueryAggregationPeriodListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getQueryAggregationPeriodListResponse(struct soap *soap, const char *tag, int id, ns1__getQueryAggregationPeriodListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodListResponse ** SOAP_FMAC4 soap_get_PointerTons1__getQueryAggregationPeriodListResponse(struct soap *soap, ns1__getQueryAggregationPeriodListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getQueryAggregationPeriodListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodListResponse ** SOAP_FMAC4 soap_in_PointerTons1__getQueryAggregationPeriodListResponse(struct soap *soap, const char *tag, ns1__getQueryAggregationPeriodListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getQueryAggregationPeriodListResponse **)soap_malloc(soap, sizeof(ns1__getQueryAggregationPeriodListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getQueryAggregationPeriodListResponse *)soap_instantiate_ns1__getQueryAggregationPeriodListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getQueryAggregationPeriodListResponse ** p = (ns1__getQueryAggregationPeriodListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse, sizeof(ns1__getQueryAggregationPeriodListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getQueryAggregationPeriodList(struct soap *soap, ns1__getQueryAggregationPeriodList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getQueryAggregationPeriodList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getQueryAggregationPeriodList(struct soap *soap, ns1__getQueryAggregationPeriodList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getQueryAggregationPeriodList);
	if (soap_out_PointerTons1__getQueryAggregationPeriodList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getQueryAggregationPeriodList(struct soap *soap, const char *tag, int id, ns1__getQueryAggregationPeriodList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getQueryAggregationPeriodList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodList ** SOAP_FMAC4 soap_get_PointerTons1__getQueryAggregationPeriodList(struct soap *soap, ns1__getQueryAggregationPeriodList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getQueryAggregationPeriodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getQueryAggregationPeriodList ** SOAP_FMAC4 soap_in_PointerTons1__getQueryAggregationPeriodList(struct soap *soap, const char *tag, ns1__getQueryAggregationPeriodList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getQueryAggregationPeriodList **)soap_malloc(soap, sizeof(ns1__getQueryAggregationPeriodList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getQueryAggregationPeriodList *)soap_instantiate_ns1__getQueryAggregationPeriodList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getQueryAggregationPeriodList ** p = (ns1__getQueryAggregationPeriodList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getQueryAggregationPeriodList, sizeof(ns1__getQueryAggregationPeriodList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPredefinedEventTypesResponse(struct soap *soap, ns1__getPredefinedEventTypesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPredefinedEventTypesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPredefinedEventTypesResponse(struct soap *soap, ns1__getPredefinedEventTypesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPredefinedEventTypesResponse);
	if (soap_out_PointerTons1__getPredefinedEventTypesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPredefinedEventTypesResponse(struct soap *soap, const char *tag, int id, ns1__getPredefinedEventTypesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPredefinedEventTypesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPredefinedEventTypesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPredefinedEventTypesResponse(struct soap *soap, ns1__getPredefinedEventTypesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPredefinedEventTypesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPredefinedEventTypesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPredefinedEventTypesResponse(struct soap *soap, const char *tag, ns1__getPredefinedEventTypesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPredefinedEventTypesResponse **)soap_malloc(soap, sizeof(ns1__getPredefinedEventTypesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPredefinedEventTypesResponse *)soap_instantiate_ns1__getPredefinedEventTypesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPredefinedEventTypesResponse ** p = (ns1__getPredefinedEventTypesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPredefinedEventTypesResponse, sizeof(ns1__getPredefinedEventTypesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPredefinedEventTypes(struct soap *soap, ns1__getPredefinedEventTypes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPredefinedEventTypes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPredefinedEventTypes(struct soap *soap, ns1__getPredefinedEventTypes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPredefinedEventTypes);
	if (soap_out_PointerTons1__getPredefinedEventTypes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPredefinedEventTypes(struct soap *soap, const char *tag, int id, ns1__getPredefinedEventTypes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPredefinedEventTypes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPredefinedEventTypes ** SOAP_FMAC4 soap_get_PointerTons1__getPredefinedEventTypes(struct soap *soap, ns1__getPredefinedEventTypes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPredefinedEventTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPredefinedEventTypes ** SOAP_FMAC4 soap_in_PointerTons1__getPredefinedEventTypes(struct soap *soap, const char *tag, ns1__getPredefinedEventTypes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPredefinedEventTypes **)soap_malloc(soap, sizeof(ns1__getPredefinedEventTypes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPredefinedEventTypes *)soap_instantiate_ns1__getPredefinedEventTypes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPredefinedEventTypes ** p = (ns1__getPredefinedEventTypes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPredefinedEventTypes, sizeof(ns1__getPredefinedEventTypes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPolicyStateResponse(struct soap *soap, ns1__getPolicyStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPolicyStateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPolicyStateResponse(struct soap *soap, ns1__getPolicyStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPolicyStateResponse);
	if (soap_out_PointerTons1__getPolicyStateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPolicyStateResponse(struct soap *soap, const char *tag, int id, ns1__getPolicyStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPolicyStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPolicyStateResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPolicyStateResponse(struct soap *soap, ns1__getPolicyStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPolicyStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPolicyStateResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPolicyStateResponse(struct soap *soap, const char *tag, ns1__getPolicyStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPolicyStateResponse **)soap_malloc(soap, sizeof(ns1__getPolicyStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPolicyStateResponse *)soap_instantiate_ns1__getPolicyStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPolicyStateResponse ** p = (ns1__getPolicyStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPolicyStateResponse, sizeof(ns1__getPolicyStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPolicyState(struct soap *soap, ns1__getPolicyState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPolicyState))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPolicyState(struct soap *soap, ns1__getPolicyState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPolicyState);
	if (soap_out_PointerTons1__getPolicyState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPolicyState(struct soap *soap, const char *tag, int id, ns1__getPolicyState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPolicyState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPolicyState ** SOAP_FMAC4 soap_get_PointerTons1__getPolicyState(struct soap *soap, ns1__getPolicyState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPolicyState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPolicyState ** SOAP_FMAC4 soap_in_PointerTons1__getPolicyState(struct soap *soap, const char *tag, ns1__getPolicyState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPolicyState **)soap_malloc(soap, sizeof(ns1__getPolicyState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPolicyState *)soap_instantiate_ns1__getPolicyState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPolicyState ** p = (ns1__getPolicyState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPolicyState, sizeof(ns1__getPolicyState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPolicyHistoryResponse(struct soap *soap, ns1__getPolicyHistoryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPolicyHistoryResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPolicyHistoryResponse(struct soap *soap, ns1__getPolicyHistoryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPolicyHistoryResponse);
	if (soap_out_PointerTons1__getPolicyHistoryResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPolicyHistoryResponse(struct soap *soap, const char *tag, int id, ns1__getPolicyHistoryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPolicyHistoryResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPolicyHistoryResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPolicyHistoryResponse(struct soap *soap, ns1__getPolicyHistoryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPolicyHistoryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPolicyHistoryResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPolicyHistoryResponse(struct soap *soap, const char *tag, ns1__getPolicyHistoryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPolicyHistoryResponse **)soap_malloc(soap, sizeof(ns1__getPolicyHistoryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPolicyHistoryResponse *)soap_instantiate_ns1__getPolicyHistoryResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPolicyHistoryResponse ** p = (ns1__getPolicyHistoryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPolicyHistoryResponse, sizeof(ns1__getPolicyHistoryResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPolicyHistory(struct soap *soap, ns1__getPolicyHistory *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPolicyHistory))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPolicyHistory(struct soap *soap, ns1__getPolicyHistory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPolicyHistory);
	if (soap_out_PointerTons1__getPolicyHistory(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPolicyHistory(struct soap *soap, const char *tag, int id, ns1__getPolicyHistory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPolicyHistory);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPolicyHistory ** SOAP_FMAC4 soap_get_PointerTons1__getPolicyHistory(struct soap *soap, ns1__getPolicyHistory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPolicyHistory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPolicyHistory ** SOAP_FMAC4 soap_in_PointerTons1__getPolicyHistory(struct soap *soap, const char *tag, ns1__getPolicyHistory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPolicyHistory **)soap_malloc(soap, sizeof(ns1__getPolicyHistory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPolicyHistory *)soap_instantiate_ns1__getPolicyHistory(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPolicyHistory ** p = (ns1__getPolicyHistory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPolicyHistory, sizeof(ns1__getPolicyHistory), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPolicyDataResponse(struct soap *soap, ns1__getPolicyDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPolicyDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPolicyDataResponse(struct soap *soap, ns1__getPolicyDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPolicyDataResponse);
	if (soap_out_PointerTons1__getPolicyDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPolicyDataResponse(struct soap *soap, const char *tag, int id, ns1__getPolicyDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPolicyDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPolicyDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__getPolicyDataResponse(struct soap *soap, ns1__getPolicyDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPolicyDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPolicyDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__getPolicyDataResponse(struct soap *soap, const char *tag, ns1__getPolicyDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPolicyDataResponse **)soap_malloc(soap, sizeof(ns1__getPolicyDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPolicyDataResponse *)soap_instantiate_ns1__getPolicyDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPolicyDataResponse ** p = (ns1__getPolicyDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPolicyDataResponse, sizeof(ns1__getPolicyDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getPolicyData(struct soap *soap, ns1__getPolicyData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getPolicyData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getPolicyData(struct soap *soap, ns1__getPolicyData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getPolicyData);
	if (soap_out_PointerTons1__getPolicyData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getPolicyData(struct soap *soap, const char *tag, int id, ns1__getPolicyData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getPolicyData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getPolicyData ** SOAP_FMAC4 soap_get_PointerTons1__getPolicyData(struct soap *soap, ns1__getPolicyData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getPolicyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getPolicyData ** SOAP_FMAC4 soap_in_PointerTons1__getPolicyData(struct soap *soap, const char *tag, ns1__getPolicyData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getPolicyData **)soap_malloc(soap, sizeof(ns1__getPolicyData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getPolicyData *)soap_instantiate_ns1__getPolicyData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getPolicyData ** p = (ns1__getPolicyData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getPolicyData, sizeof(ns1__getPolicyData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getNextDataResponse(struct soap *soap, ns1__getNextDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getNextDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getNextDataResponse(struct soap *soap, ns1__getNextDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getNextDataResponse);
	if (soap_out_PointerTons1__getNextDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getNextDataResponse(struct soap *soap, const char *tag, int id, ns1__getNextDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getNextDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getNextDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__getNextDataResponse(struct soap *soap, ns1__getNextDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getNextDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getNextDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__getNextDataResponse(struct soap *soap, const char *tag, ns1__getNextDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getNextDataResponse **)soap_malloc(soap, sizeof(ns1__getNextDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getNextDataResponse *)soap_instantiate_ns1__getNextDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getNextDataResponse ** p = (ns1__getNextDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getNextDataResponse, sizeof(ns1__getNextDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getNextData(struct soap *soap, ns1__getNextData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getNextData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getNextData(struct soap *soap, ns1__getNextData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getNextData);
	if (soap_out_PointerTons1__getNextData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getNextData(struct soap *soap, const char *tag, int id, ns1__getNextData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getNextData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getNextData ** SOAP_FMAC4 soap_get_PointerTons1__getNextData(struct soap *soap, ns1__getNextData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getNextData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getNextData ** SOAP_FMAC4 soap_in_PointerTons1__getNextData(struct soap *soap, const char *tag, ns1__getNextData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getNextData **)soap_malloc(soap, sizeof(ns1__getNextData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getNextData *)soap_instantiate_ns1__getNextData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getNextData ** p = (ns1__getNextData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getNextData, sizeof(ns1__getNextData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMetricDataResponse(struct soap *soap, ns1__getMetricDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMetricDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMetricDataResponse(struct soap *soap, ns1__getMetricDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMetricDataResponse);
	if (soap_out_PointerTons1__getMetricDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMetricDataResponse(struct soap *soap, const char *tag, int id, ns1__getMetricDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMetricDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMetricDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__getMetricDataResponse(struct soap *soap, ns1__getMetricDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMetricDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getMetricDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__getMetricDataResponse(struct soap *soap, const char *tag, ns1__getMetricDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMetricDataResponse **)soap_malloc(soap, sizeof(ns1__getMetricDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMetricDataResponse *)soap_instantiate_ns1__getMetricDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMetricDataResponse ** p = (ns1__getMetricDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMetricDataResponse, sizeof(ns1__getMetricDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMetricData(struct soap *soap, ns1__getMetricData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMetricData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMetricData(struct soap *soap, ns1__getMetricData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMetricData);
	if (soap_out_PointerTons1__getMetricData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMetricData(struct soap *soap, const char *tag, int id, ns1__getMetricData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMetricData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMetricData ** SOAP_FMAC4 soap_get_PointerTons1__getMetricData(struct soap *soap, ns1__getMetricData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMetricData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getMetricData ** SOAP_FMAC4 soap_in_PointerTons1__getMetricData(struct soap *soap, const char *tag, ns1__getMetricData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMetricData **)soap_malloc(soap, sizeof(ns1__getMetricData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMetricData *)soap_instantiate_ns1__getMetricData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMetricData ** p = (ns1__getMetricData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMetricData, sizeof(ns1__getMetricData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMetricAggregationPeriodListResponse(struct soap *soap, ns1__getMetricAggregationPeriodListResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMetricAggregationPeriodListResponse(struct soap *soap, ns1__getMetricAggregationPeriodListResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMetricAggregationPeriodListResponse);
	if (soap_out_PointerTons1__getMetricAggregationPeriodListResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMetricAggregationPeriodListResponse(struct soap *soap, const char *tag, int id, ns1__getMetricAggregationPeriodListResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodListResponse ** SOAP_FMAC4 soap_get_PointerTons1__getMetricAggregationPeriodListResponse(struct soap *soap, ns1__getMetricAggregationPeriodListResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMetricAggregationPeriodListResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodListResponse ** SOAP_FMAC4 soap_in_PointerTons1__getMetricAggregationPeriodListResponse(struct soap *soap, const char *tag, ns1__getMetricAggregationPeriodListResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMetricAggregationPeriodListResponse **)soap_malloc(soap, sizeof(ns1__getMetricAggregationPeriodListResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMetricAggregationPeriodListResponse *)soap_instantiate_ns1__getMetricAggregationPeriodListResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMetricAggregationPeriodListResponse ** p = (ns1__getMetricAggregationPeriodListResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse, sizeof(ns1__getMetricAggregationPeriodListResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getMetricAggregationPeriodList(struct soap *soap, ns1__getMetricAggregationPeriodList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getMetricAggregationPeriodList))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getMetricAggregationPeriodList(struct soap *soap, ns1__getMetricAggregationPeriodList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getMetricAggregationPeriodList);
	if (soap_out_PointerTons1__getMetricAggregationPeriodList(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getMetricAggregationPeriodList(struct soap *soap, const char *tag, int id, ns1__getMetricAggregationPeriodList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getMetricAggregationPeriodList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodList ** SOAP_FMAC4 soap_get_PointerTons1__getMetricAggregationPeriodList(struct soap *soap, ns1__getMetricAggregationPeriodList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getMetricAggregationPeriodList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getMetricAggregationPeriodList ** SOAP_FMAC4 soap_in_PointerTons1__getMetricAggregationPeriodList(struct soap *soap, const char *tag, ns1__getMetricAggregationPeriodList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getMetricAggregationPeriodList **)soap_malloc(soap, sizeof(ns1__getMetricAggregationPeriodList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getMetricAggregationPeriodList *)soap_instantiate_ns1__getMetricAggregationPeriodList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getMetricAggregationPeriodList ** p = (ns1__getMetricAggregationPeriodList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getMetricAggregationPeriodList, sizeof(ns1__getMetricAggregationPeriodList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getGlobalPropertyResponse(struct soap *soap, ns1__getGlobalPropertyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getGlobalPropertyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getGlobalPropertyResponse(struct soap *soap, ns1__getGlobalPropertyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getGlobalPropertyResponse);
	if (soap_out_PointerTons1__getGlobalPropertyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getGlobalPropertyResponse(struct soap *soap, const char *tag, int id, ns1__getGlobalPropertyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getGlobalPropertyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getGlobalPropertyResponse ** SOAP_FMAC4 soap_get_PointerTons1__getGlobalPropertyResponse(struct soap *soap, ns1__getGlobalPropertyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getGlobalPropertyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getGlobalPropertyResponse ** SOAP_FMAC4 soap_in_PointerTons1__getGlobalPropertyResponse(struct soap *soap, const char *tag, ns1__getGlobalPropertyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getGlobalPropertyResponse **)soap_malloc(soap, sizeof(ns1__getGlobalPropertyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getGlobalPropertyResponse *)soap_instantiate_ns1__getGlobalPropertyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getGlobalPropertyResponse ** p = (ns1__getGlobalPropertyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getGlobalPropertyResponse, sizeof(ns1__getGlobalPropertyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getGlobalProperty(struct soap *soap, ns1__getGlobalProperty *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getGlobalProperty))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getGlobalProperty(struct soap *soap, ns1__getGlobalProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getGlobalProperty);
	if (soap_out_PointerTons1__getGlobalProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getGlobalProperty(struct soap *soap, const char *tag, int id, ns1__getGlobalProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getGlobalProperty);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getGlobalProperty ** SOAP_FMAC4 soap_get_PointerTons1__getGlobalProperty(struct soap *soap, ns1__getGlobalProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getGlobalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getGlobalProperty ** SOAP_FMAC4 soap_in_PointerTons1__getGlobalProperty(struct soap *soap, const char *tag, ns1__getGlobalProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getGlobalProperty **)soap_malloc(soap, sizeof(ns1__getGlobalProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getGlobalProperty *)soap_instantiate_ns1__getGlobalProperty(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getGlobalProperty ** p = (ns1__getGlobalProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getGlobalProperty, sizeof(ns1__getGlobalProperty), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEventStateResponse(struct soap *soap, ns1__getEventStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getEventStateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEventStateResponse(struct soap *soap, ns1__getEventStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getEventStateResponse);
	if (soap_out_PointerTons1__getEventStateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEventStateResponse(struct soap *soap, const char *tag, int id, ns1__getEventStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getEventStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEventStateResponse ** SOAP_FMAC4 soap_get_PointerTons1__getEventStateResponse(struct soap *soap, ns1__getEventStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getEventStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getEventStateResponse ** SOAP_FMAC4 soap_in_PointerTons1__getEventStateResponse(struct soap *soap, const char *tag, ns1__getEventStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getEventStateResponse **)soap_malloc(soap, sizeof(ns1__getEventStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getEventStateResponse *)soap_instantiate_ns1__getEventStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getEventStateResponse ** p = (ns1__getEventStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getEventStateResponse, sizeof(ns1__getEventStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEventState(struct soap *soap, ns1__getEventState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getEventState))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEventState(struct soap *soap, ns1__getEventState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getEventState);
	if (soap_out_PointerTons1__getEventState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEventState(struct soap *soap, const char *tag, int id, ns1__getEventState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getEventState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEventState ** SOAP_FMAC4 soap_get_PointerTons1__getEventState(struct soap *soap, ns1__getEventState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getEventState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getEventState ** SOAP_FMAC4 soap_in_PointerTons1__getEventState(struct soap *soap, const char *tag, ns1__getEventState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getEventState **)soap_malloc(soap, sizeof(ns1__getEventState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getEventState *)soap_instantiate_ns1__getEventState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getEventState ** p = (ns1__getEventState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getEventState, sizeof(ns1__getEventState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEventHandlerResponse(struct soap *soap, ns1__getEventHandlerResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getEventHandlerResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEventHandlerResponse(struct soap *soap, ns1__getEventHandlerResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getEventHandlerResponse);
	if (soap_out_PointerTons1__getEventHandlerResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEventHandlerResponse(struct soap *soap, const char *tag, int id, ns1__getEventHandlerResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getEventHandlerResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEventHandlerResponse ** SOAP_FMAC4 soap_get_PointerTons1__getEventHandlerResponse(struct soap *soap, ns1__getEventHandlerResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getEventHandlerResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getEventHandlerResponse ** SOAP_FMAC4 soap_in_PointerTons1__getEventHandlerResponse(struct soap *soap, const char *tag, ns1__getEventHandlerResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getEventHandlerResponse **)soap_malloc(soap, sizeof(ns1__getEventHandlerResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getEventHandlerResponse *)soap_instantiate_ns1__getEventHandlerResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getEventHandlerResponse ** p = (ns1__getEventHandlerResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getEventHandlerResponse, sizeof(ns1__getEventHandlerResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEventHandler(struct soap *soap, ns1__getEventHandler *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getEventHandler))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEventHandler(struct soap *soap, ns1__getEventHandler *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getEventHandler);
	if (soap_out_PointerTons1__getEventHandler(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEventHandler(struct soap *soap, const char *tag, int id, ns1__getEventHandler *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getEventHandler);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEventHandler ** SOAP_FMAC4 soap_get_PointerTons1__getEventHandler(struct soap *soap, ns1__getEventHandler **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getEventHandler(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getEventHandler ** SOAP_FMAC4 soap_in_PointerTons1__getEventHandler(struct soap *soap, const char *tag, ns1__getEventHandler **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getEventHandler **)soap_malloc(soap, sizeof(ns1__getEventHandler *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getEventHandler *)soap_instantiate_ns1__getEventHandler(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getEventHandler ** p = (ns1__getEventHandler **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getEventHandler, sizeof(ns1__getEventHandler), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEntityPropertiesResponse(struct soap *soap, ns1__getEntityPropertiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getEntityPropertiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEntityPropertiesResponse(struct soap *soap, ns1__getEntityPropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getEntityPropertiesResponse);
	if (soap_out_PointerTons1__getEntityPropertiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEntityPropertiesResponse(struct soap *soap, const char *tag, int id, ns1__getEntityPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getEntityPropertiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEntityPropertiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__getEntityPropertiesResponse(struct soap *soap, ns1__getEntityPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getEntityPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getEntityPropertiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__getEntityPropertiesResponse(struct soap *soap, const char *tag, ns1__getEntityPropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getEntityPropertiesResponse **)soap_malloc(soap, sizeof(ns1__getEntityPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getEntityPropertiesResponse *)soap_instantiate_ns1__getEntityPropertiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getEntityPropertiesResponse ** p = (ns1__getEntityPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getEntityPropertiesResponse, sizeof(ns1__getEntityPropertiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getEntityProperties(struct soap *soap, ns1__getEntityProperties *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getEntityProperties))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getEntityProperties(struct soap *soap, ns1__getEntityProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getEntityProperties);
	if (soap_out_PointerTons1__getEntityProperties(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getEntityProperties(struct soap *soap, const char *tag, int id, ns1__getEntityProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getEntityProperties);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getEntityProperties ** SOAP_FMAC4 soap_get_PointerTons1__getEntityProperties(struct soap *soap, ns1__getEntityProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getEntityProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getEntityProperties ** SOAP_FMAC4 soap_in_PointerTons1__getEntityProperties(struct soap *soap, const char *tag, ns1__getEntityProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getEntityProperties **)soap_malloc(soap, sizeof(ns1__getEntityProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getEntityProperties *)soap_instantiate_ns1__getEntityProperties(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getEntityProperties ** p = (ns1__getEntityProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getEntityProperties, sizeof(ns1__getEntityProperties), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCustomEventDataResponse(struct soap *soap, ns1__getCustomEventDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCustomEventDataResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCustomEventDataResponse(struct soap *soap, ns1__getCustomEventDataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getCustomEventDataResponse);
	if (soap_out_PointerTons1__getCustomEventDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCustomEventDataResponse(struct soap *soap, const char *tag, int id, ns1__getCustomEventDataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCustomEventDataResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCustomEventDataResponse ** SOAP_FMAC4 soap_get_PointerTons1__getCustomEventDataResponse(struct soap *soap, ns1__getCustomEventDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCustomEventDataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getCustomEventDataResponse ** SOAP_FMAC4 soap_in_PointerTons1__getCustomEventDataResponse(struct soap *soap, const char *tag, ns1__getCustomEventDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCustomEventDataResponse **)soap_malloc(soap, sizeof(ns1__getCustomEventDataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCustomEventDataResponse *)soap_instantiate_ns1__getCustomEventDataResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCustomEventDataResponse ** p = (ns1__getCustomEventDataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCustomEventDataResponse, sizeof(ns1__getCustomEventDataResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCustomEventData(struct soap *soap, ns1__getCustomEventData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCustomEventData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCustomEventData(struct soap *soap, ns1__getCustomEventData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getCustomEventData);
	if (soap_out_PointerTons1__getCustomEventData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCustomEventData(struct soap *soap, const char *tag, int id, ns1__getCustomEventData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCustomEventData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCustomEventData ** SOAP_FMAC4 soap_get_PointerTons1__getCustomEventData(struct soap *soap, ns1__getCustomEventData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCustomEventData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getCustomEventData ** SOAP_FMAC4 soap_in_PointerTons1__getCustomEventData(struct soap *soap, const char *tag, ns1__getCustomEventData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCustomEventData **)soap_malloc(soap, sizeof(ns1__getCustomEventData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCustomEventData *)soap_instantiate_ns1__getCustomEventData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCustomEventData ** p = (ns1__getCustomEventData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCustomEventData, sizeof(ns1__getCustomEventData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCollectionStateResponse(struct soap *soap, ns1__getCollectionStateResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCollectionStateResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCollectionStateResponse(struct soap *soap, ns1__getCollectionStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getCollectionStateResponse);
	if (soap_out_PointerTons1__getCollectionStateResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCollectionStateResponse(struct soap *soap, const char *tag, int id, ns1__getCollectionStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCollectionStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCollectionStateResponse ** SOAP_FMAC4 soap_get_PointerTons1__getCollectionStateResponse(struct soap *soap, ns1__getCollectionStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCollectionStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getCollectionStateResponse ** SOAP_FMAC4 soap_in_PointerTons1__getCollectionStateResponse(struct soap *soap, const char *tag, ns1__getCollectionStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCollectionStateResponse **)soap_malloc(soap, sizeof(ns1__getCollectionStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCollectionStateResponse *)soap_instantiate_ns1__getCollectionStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCollectionStateResponse ** p = (ns1__getCollectionStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCollectionStateResponse, sizeof(ns1__getCollectionStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getCollectionState(struct soap *soap, ns1__getCollectionState *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getCollectionState))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getCollectionState(struct soap *soap, ns1__getCollectionState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getCollectionState);
	if (soap_out_PointerTons1__getCollectionState(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getCollectionState(struct soap *soap, const char *tag, int id, ns1__getCollectionState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getCollectionState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getCollectionState ** SOAP_FMAC4 soap_get_PointerTons1__getCollectionState(struct soap *soap, ns1__getCollectionState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getCollectionState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getCollectionState ** SOAP_FMAC4 soap_in_PointerTons1__getCollectionState(struct soap *soap, const char *tag, ns1__getCollectionState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getCollectionState **)soap_malloc(soap, sizeof(ns1__getCollectionState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getCollectionState *)soap_instantiate_ns1__getCollectionState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getCollectionState ** p = (ns1__getCollectionState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getCollectionState, sizeof(ns1__getCollectionState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getActionLogRecordsResponse(struct soap *soap, ns1__getActionLogRecordsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getActionLogRecordsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getActionLogRecordsResponse(struct soap *soap, ns1__getActionLogRecordsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getActionLogRecordsResponse);
	if (soap_out_PointerTons1__getActionLogRecordsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getActionLogRecordsResponse(struct soap *soap, const char *tag, int id, ns1__getActionLogRecordsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getActionLogRecordsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getActionLogRecordsResponse ** SOAP_FMAC4 soap_get_PointerTons1__getActionLogRecordsResponse(struct soap *soap, ns1__getActionLogRecordsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getActionLogRecordsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getActionLogRecordsResponse ** SOAP_FMAC4 soap_in_PointerTons1__getActionLogRecordsResponse(struct soap *soap, const char *tag, ns1__getActionLogRecordsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getActionLogRecordsResponse **)soap_malloc(soap, sizeof(ns1__getActionLogRecordsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getActionLogRecordsResponse *)soap_instantiate_ns1__getActionLogRecordsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getActionLogRecordsResponse ** p = (ns1__getActionLogRecordsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getActionLogRecordsResponse, sizeof(ns1__getActionLogRecordsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getActionLogRecords(struct soap *soap, ns1__getActionLogRecords *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getActionLogRecords))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getActionLogRecords(struct soap *soap, ns1__getActionLogRecords *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getActionLogRecords);
	if (soap_out_PointerTons1__getActionLogRecords(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getActionLogRecords(struct soap *soap, const char *tag, int id, ns1__getActionLogRecords *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getActionLogRecords);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getActionLogRecords ** SOAP_FMAC4 soap_get_PointerTons1__getActionLogRecords(struct soap *soap, ns1__getActionLogRecords **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getActionLogRecords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getActionLogRecords ** SOAP_FMAC4 soap_in_PointerTons1__getActionLogRecords(struct soap *soap, const char *tag, ns1__getActionLogRecords **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getActionLogRecords **)soap_malloc(soap, sizeof(ns1__getActionLogRecords *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getActionLogRecords *)soap_instantiate_ns1__getActionLogRecords(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getActionLogRecords ** p = (ns1__getActionLogRecords **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getActionLogRecords, sizeof(ns1__getActionLogRecords), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findEntitiesResponse(struct soap *soap, ns1__findEntitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findEntitiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findEntitiesResponse(struct soap *soap, ns1__findEntitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findEntitiesResponse);
	if (soap_out_PointerTons1__findEntitiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findEntitiesResponse(struct soap *soap, const char *tag, int id, ns1__findEntitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findEntitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findEntitiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__findEntitiesResponse(struct soap *soap, ns1__findEntitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findEntitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findEntitiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__findEntitiesResponse(struct soap *soap, const char *tag, ns1__findEntitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findEntitiesResponse **)soap_malloc(soap, sizeof(ns1__findEntitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findEntitiesResponse *)soap_instantiate_ns1__findEntitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findEntitiesResponse ** p = (ns1__findEntitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findEntitiesResponse, sizeof(ns1__findEntitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__findEntities(struct soap *soap, ns1__findEntities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__findEntities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__findEntities(struct soap *soap, ns1__findEntities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__findEntities);
	if (soap_out_PointerTons1__findEntities(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__findEntities(struct soap *soap, const char *tag, int id, ns1__findEntities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__findEntities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__findEntities ** SOAP_FMAC4 soap_get_PointerTons1__findEntities(struct soap *soap, ns1__findEntities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__findEntities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__findEntities ** SOAP_FMAC4 soap_in_PointerTons1__findEntities(struct soap *soap, const char *tag, ns1__findEntities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__findEntities **)soap_malloc(soap, sizeof(ns1__findEntities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__findEntities *)soap_instantiate_ns1__findEntities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__findEntities ** p = (ns1__findEntities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__findEntities, sizeof(ns1__findEntities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__exportHierarchyResponse(struct soap *soap, ns1__exportHierarchyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__exportHierarchyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__exportHierarchyResponse(struct soap *soap, ns1__exportHierarchyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__exportHierarchyResponse);
	if (soap_out_PointerTons1__exportHierarchyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__exportHierarchyResponse(struct soap *soap, const char *tag, int id, ns1__exportHierarchyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__exportHierarchyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__exportHierarchyResponse ** SOAP_FMAC4 soap_get_PointerTons1__exportHierarchyResponse(struct soap *soap, ns1__exportHierarchyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__exportHierarchyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__exportHierarchyResponse ** SOAP_FMAC4 soap_in_PointerTons1__exportHierarchyResponse(struct soap *soap, const char *tag, ns1__exportHierarchyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__exportHierarchyResponse **)soap_malloc(soap, sizeof(ns1__exportHierarchyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__exportHierarchyResponse *)soap_instantiate_ns1__exportHierarchyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__exportHierarchyResponse ** p = (ns1__exportHierarchyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__exportHierarchyResponse, sizeof(ns1__exportHierarchyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__exportHierarchy(struct soap *soap, ns1__exportHierarchy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__exportHierarchy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__exportHierarchy(struct soap *soap, ns1__exportHierarchy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__exportHierarchy);
	if (soap_out_PointerTons1__exportHierarchy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__exportHierarchy(struct soap *soap, const char *tag, int id, ns1__exportHierarchy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__exportHierarchy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__exportHierarchy ** SOAP_FMAC4 soap_get_PointerTons1__exportHierarchy(struct soap *soap, ns1__exportHierarchy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__exportHierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__exportHierarchy ** SOAP_FMAC4 soap_in_PointerTons1__exportHierarchy(struct soap *soap, const char *tag, ns1__exportHierarchy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__exportHierarchy **)soap_malloc(soap, sizeof(ns1__exportHierarchy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__exportHierarchy *)soap_instantiate_ns1__exportHierarchy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__exportHierarchy ** p = (ns1__exportHierarchy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__exportHierarchy, sizeof(ns1__exportHierarchy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumeratePoliciesResponse(struct soap *soap, ns1__enumeratePoliciesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumeratePoliciesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumeratePoliciesResponse(struct soap *soap, ns1__enumeratePoliciesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumeratePoliciesResponse);
	if (soap_out_PointerTons1__enumeratePoliciesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumeratePoliciesResponse(struct soap *soap, const char *tag, int id, ns1__enumeratePoliciesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumeratePoliciesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumeratePoliciesResponse ** SOAP_FMAC4 soap_get_PointerTons1__enumeratePoliciesResponse(struct soap *soap, ns1__enumeratePoliciesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumeratePoliciesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumeratePoliciesResponse ** SOAP_FMAC4 soap_in_PointerTons1__enumeratePoliciesResponse(struct soap *soap, const char *tag, ns1__enumeratePoliciesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumeratePoliciesResponse **)soap_malloc(soap, sizeof(ns1__enumeratePoliciesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumeratePoliciesResponse *)soap_instantiate_ns1__enumeratePoliciesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumeratePoliciesResponse ** p = (ns1__enumeratePoliciesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumeratePoliciesResponse, sizeof(ns1__enumeratePoliciesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumeratePolicies(struct soap *soap, ns1__enumeratePolicies *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumeratePolicies))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumeratePolicies(struct soap *soap, ns1__enumeratePolicies *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumeratePolicies);
	if (soap_out_PointerTons1__enumeratePolicies(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumeratePolicies(struct soap *soap, const char *tag, int id, ns1__enumeratePolicies *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumeratePolicies);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumeratePolicies ** SOAP_FMAC4 soap_get_PointerTons1__enumeratePolicies(struct soap *soap, ns1__enumeratePolicies **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumeratePolicies(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumeratePolicies ** SOAP_FMAC4 soap_in_PointerTons1__enumeratePolicies(struct soap *soap, const char *tag, ns1__enumeratePolicies **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumeratePolicies **)soap_malloc(soap, sizeof(ns1__enumeratePolicies *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumeratePolicies *)soap_instantiate_ns1__enumeratePolicies(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumeratePolicies ** p = (ns1__enumeratePolicies **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumeratePolicies, sizeof(ns1__enumeratePolicies), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumerateEventHandlersResponse(struct soap *soap, ns1__enumerateEventHandlersResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumerateEventHandlersResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumerateEventHandlersResponse(struct soap *soap, ns1__enumerateEventHandlersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumerateEventHandlersResponse);
	if (soap_out_PointerTons1__enumerateEventHandlersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumerateEventHandlersResponse(struct soap *soap, const char *tag, int id, ns1__enumerateEventHandlersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumerateEventHandlersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumerateEventHandlersResponse ** SOAP_FMAC4 soap_get_PointerTons1__enumerateEventHandlersResponse(struct soap *soap, ns1__enumerateEventHandlersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumerateEventHandlersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumerateEventHandlersResponse ** SOAP_FMAC4 soap_in_PointerTons1__enumerateEventHandlersResponse(struct soap *soap, const char *tag, ns1__enumerateEventHandlersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumerateEventHandlersResponse **)soap_malloc(soap, sizeof(ns1__enumerateEventHandlersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumerateEventHandlersResponse *)soap_instantiate_ns1__enumerateEventHandlersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumerateEventHandlersResponse ** p = (ns1__enumerateEventHandlersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumerateEventHandlersResponse, sizeof(ns1__enumerateEventHandlersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumerateEventHandlers(struct soap *soap, ns1__enumerateEventHandlers *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumerateEventHandlers))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumerateEventHandlers(struct soap *soap, ns1__enumerateEventHandlers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumerateEventHandlers);
	if (soap_out_PointerTons1__enumerateEventHandlers(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumerateEventHandlers(struct soap *soap, const char *tag, int id, ns1__enumerateEventHandlers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumerateEventHandlers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumerateEventHandlers ** SOAP_FMAC4 soap_get_PointerTons1__enumerateEventHandlers(struct soap *soap, ns1__enumerateEventHandlers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumerateEventHandlers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumerateEventHandlers ** SOAP_FMAC4 soap_in_PointerTons1__enumerateEventHandlers(struct soap *soap, const char *tag, ns1__enumerateEventHandlers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumerateEventHandlers **)soap_malloc(soap, sizeof(ns1__enumerateEventHandlers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumerateEventHandlers *)soap_instantiate_ns1__enumerateEventHandlers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumerateEventHandlers ** p = (ns1__enumerateEventHandlers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumerateEventHandlers, sizeof(ns1__enumerateEventHandlers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumerateEntitiesResponse(struct soap *soap, ns1__enumerateEntitiesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumerateEntitiesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumerateEntitiesResponse(struct soap *soap, ns1__enumerateEntitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumerateEntitiesResponse);
	if (soap_out_PointerTons1__enumerateEntitiesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumerateEntitiesResponse(struct soap *soap, const char *tag, int id, ns1__enumerateEntitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumerateEntitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumerateEntitiesResponse ** SOAP_FMAC4 soap_get_PointerTons1__enumerateEntitiesResponse(struct soap *soap, ns1__enumerateEntitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumerateEntitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumerateEntitiesResponse ** SOAP_FMAC4 soap_in_PointerTons1__enumerateEntitiesResponse(struct soap *soap, const char *tag, ns1__enumerateEntitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumerateEntitiesResponse **)soap_malloc(soap, sizeof(ns1__enumerateEntitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumerateEntitiesResponse *)soap_instantiate_ns1__enumerateEntitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumerateEntitiesResponse ** p = (ns1__enumerateEntitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumerateEntitiesResponse, sizeof(ns1__enumerateEntitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumerateEntities(struct soap *soap, ns1__enumerateEntities *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumerateEntities))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumerateEntities(struct soap *soap, ns1__enumerateEntities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumerateEntities);
	if (soap_out_PointerTons1__enumerateEntities(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumerateEntities(struct soap *soap, const char *tag, int id, ns1__enumerateEntities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumerateEntities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumerateEntities ** SOAP_FMAC4 soap_get_PointerTons1__enumerateEntities(struct soap *soap, ns1__enumerateEntities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumerateEntities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumerateEntities ** SOAP_FMAC4 soap_in_PointerTons1__enumerateEntities(struct soap *soap, const char *tag, ns1__enumerateEntities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumerateEntities **)soap_malloc(soap, sizeof(ns1__enumerateEntities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumerateEntities *)soap_instantiate_ns1__enumerateEntities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumerateEntities ** p = (ns1__enumerateEntities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumerateEntities, sizeof(ns1__enumerateEntities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumerateCustomEventsResponse(struct soap *soap, ns1__enumerateCustomEventsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumerateCustomEventsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumerateCustomEventsResponse(struct soap *soap, ns1__enumerateCustomEventsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumerateCustomEventsResponse);
	if (soap_out_PointerTons1__enumerateCustomEventsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumerateCustomEventsResponse(struct soap *soap, const char *tag, int id, ns1__enumerateCustomEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumerateCustomEventsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumerateCustomEventsResponse ** SOAP_FMAC4 soap_get_PointerTons1__enumerateCustomEventsResponse(struct soap *soap, ns1__enumerateCustomEventsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumerateCustomEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumerateCustomEventsResponse ** SOAP_FMAC4 soap_in_PointerTons1__enumerateCustomEventsResponse(struct soap *soap, const char *tag, ns1__enumerateCustomEventsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumerateCustomEventsResponse **)soap_malloc(soap, sizeof(ns1__enumerateCustomEventsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumerateCustomEventsResponse *)soap_instantiate_ns1__enumerateCustomEventsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumerateCustomEventsResponse ** p = (ns1__enumerateCustomEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumerateCustomEventsResponse, sizeof(ns1__enumerateCustomEventsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumerateCustomEvents(struct soap *soap, ns1__enumerateCustomEvents *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumerateCustomEvents))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumerateCustomEvents(struct soap *soap, ns1__enumerateCustomEvents *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumerateCustomEvents);
	if (soap_out_PointerTons1__enumerateCustomEvents(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumerateCustomEvents(struct soap *soap, const char *tag, int id, ns1__enumerateCustomEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumerateCustomEvents);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumerateCustomEvents ** SOAP_FMAC4 soap_get_PointerTons1__enumerateCustomEvents(struct soap *soap, ns1__enumerateCustomEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumerateCustomEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumerateCustomEvents ** SOAP_FMAC4 soap_in_PointerTons1__enumerateCustomEvents(struct soap *soap, const char *tag, ns1__enumerateCustomEvents **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumerateCustomEvents **)soap_malloc(soap, sizeof(ns1__enumerateCustomEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumerateCustomEvents *)soap_instantiate_ns1__enumerateCustomEvents(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumerateCustomEvents ** p = (ns1__enumerateCustomEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumerateCustomEvents, sizeof(ns1__enumerateCustomEvents), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__disassociateEntityResponse(struct soap *soap, ns1__disassociateEntityResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__disassociateEntityResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__disassociateEntityResponse(struct soap *soap, ns1__disassociateEntityResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__disassociateEntityResponse);
	if (soap_out_PointerTons1__disassociateEntityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__disassociateEntityResponse(struct soap *soap, const char *tag, int id, ns1__disassociateEntityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__disassociateEntityResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__disassociateEntityResponse ** SOAP_FMAC4 soap_get_PointerTons1__disassociateEntityResponse(struct soap *soap, ns1__disassociateEntityResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__disassociateEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__disassociateEntityResponse ** SOAP_FMAC4 soap_in_PointerTons1__disassociateEntityResponse(struct soap *soap, const char *tag, ns1__disassociateEntityResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__disassociateEntityResponse **)soap_malloc(soap, sizeof(ns1__disassociateEntityResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__disassociateEntityResponse *)soap_instantiate_ns1__disassociateEntityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__disassociateEntityResponse ** p = (ns1__disassociateEntityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__disassociateEntityResponse, sizeof(ns1__disassociateEntityResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__disassociateEntity(struct soap *soap, ns1__disassociateEntity *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__disassociateEntity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__disassociateEntity(struct soap *soap, ns1__disassociateEntity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__disassociateEntity);
	if (soap_out_PointerTons1__disassociateEntity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__disassociateEntity(struct soap *soap, const char *tag, int id, ns1__disassociateEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__disassociateEntity);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__disassociateEntity ** SOAP_FMAC4 soap_get_PointerTons1__disassociateEntity(struct soap *soap, ns1__disassociateEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__disassociateEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__disassociateEntity ** SOAP_FMAC4 soap_in_PointerTons1__disassociateEntity(struct soap *soap, const char *tag, ns1__disassociateEntity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__disassociateEntity **)soap_malloc(soap, sizeof(ns1__disassociateEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__disassociateEntity *)soap_instantiate_ns1__disassociateEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__disassociateEntity ** p = (ns1__disassociateEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__disassociateEntity, sizeof(ns1__disassociateEntity), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteSecretKeyResponse(struct soap *soap, ns1__deleteSecretKeyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteSecretKeyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteSecretKeyResponse(struct soap *soap, ns1__deleteSecretKeyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteSecretKeyResponse);
	if (soap_out_PointerTons1__deleteSecretKeyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteSecretKeyResponse(struct soap *soap, const char *tag, int id, ns1__deleteSecretKeyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteSecretKeyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteSecretKeyResponse ** SOAP_FMAC4 soap_get_PointerTons1__deleteSecretKeyResponse(struct soap *soap, ns1__deleteSecretKeyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteSecretKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__deleteSecretKeyResponse ** SOAP_FMAC4 soap_in_PointerTons1__deleteSecretKeyResponse(struct soap *soap, const char *tag, ns1__deleteSecretKeyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteSecretKeyResponse **)soap_malloc(soap, sizeof(ns1__deleteSecretKeyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteSecretKeyResponse *)soap_instantiate_ns1__deleteSecretKeyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteSecretKeyResponse ** p = (ns1__deleteSecretKeyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSecretKeyResponse, sizeof(ns1__deleteSecretKeyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__deleteSecretKey(struct soap *soap, ns1__deleteSecretKey *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__deleteSecretKey))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__deleteSecretKey(struct soap *soap, ns1__deleteSecretKey *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__deleteSecretKey);
	if (soap_out_PointerTons1__deleteSecretKey(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__deleteSecretKey(struct soap *soap, const char *tag, int id, ns1__deleteSecretKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__deleteSecretKey);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__deleteSecretKey ** SOAP_FMAC4 soap_get_PointerTons1__deleteSecretKey(struct soap *soap, ns1__deleteSecretKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__deleteSecretKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__deleteSecretKey ** SOAP_FMAC4 soap_in_PointerTons1__deleteSecretKey(struct soap *soap, const char *tag, ns1__deleteSecretKey **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__deleteSecretKey **)soap_malloc(soap, sizeof(ns1__deleteSecretKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__deleteSecretKey *)soap_instantiate_ns1__deleteSecretKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__deleteSecretKey ** p = (ns1__deleteSecretKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__deleteSecretKey, sizeof(ns1__deleteSecretKey), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__defineCustomEventResponse(struct soap *soap, ns1__defineCustomEventResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__defineCustomEventResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__defineCustomEventResponse(struct soap *soap, ns1__defineCustomEventResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__defineCustomEventResponse);
	if (soap_out_PointerTons1__defineCustomEventResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__defineCustomEventResponse(struct soap *soap, const char *tag, int id, ns1__defineCustomEventResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__defineCustomEventResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__defineCustomEventResponse ** SOAP_FMAC4 soap_get_PointerTons1__defineCustomEventResponse(struct soap *soap, ns1__defineCustomEventResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__defineCustomEventResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__defineCustomEventResponse ** SOAP_FMAC4 soap_in_PointerTons1__defineCustomEventResponse(struct soap *soap, const char *tag, ns1__defineCustomEventResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__defineCustomEventResponse **)soap_malloc(soap, sizeof(ns1__defineCustomEventResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__defineCustomEventResponse *)soap_instantiate_ns1__defineCustomEventResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__defineCustomEventResponse ** p = (ns1__defineCustomEventResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__defineCustomEventResponse, sizeof(ns1__defineCustomEventResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__defineCustomEvent(struct soap *soap, ns1__defineCustomEvent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__defineCustomEvent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__defineCustomEvent(struct soap *soap, ns1__defineCustomEvent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__defineCustomEvent);
	if (soap_out_PointerTons1__defineCustomEvent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__defineCustomEvent(struct soap *soap, const char *tag, int id, ns1__defineCustomEvent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__defineCustomEvent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__defineCustomEvent ** SOAP_FMAC4 soap_get_PointerTons1__defineCustomEvent(struct soap *soap, ns1__defineCustomEvent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__defineCustomEvent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__defineCustomEvent ** SOAP_FMAC4 soap_in_PointerTons1__defineCustomEvent(struct soap *soap, const char *tag, ns1__defineCustomEvent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__defineCustomEvent **)soap_malloc(soap, sizeof(ns1__defineCustomEvent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__defineCustomEvent *)soap_instantiate_ns1__defineCustomEvent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__defineCustomEvent ** p = (ns1__defineCustomEvent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__defineCustomEvent, sizeof(ns1__defineCustomEvent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__associateEntityResponse(struct soap *soap, ns1__associateEntityResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__associateEntityResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__associateEntityResponse(struct soap *soap, ns1__associateEntityResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__associateEntityResponse);
	if (soap_out_PointerTons1__associateEntityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__associateEntityResponse(struct soap *soap, const char *tag, int id, ns1__associateEntityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__associateEntityResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__associateEntityResponse ** SOAP_FMAC4 soap_get_PointerTons1__associateEntityResponse(struct soap *soap, ns1__associateEntityResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__associateEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__associateEntityResponse ** SOAP_FMAC4 soap_in_PointerTons1__associateEntityResponse(struct soap *soap, const char *tag, ns1__associateEntityResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__associateEntityResponse **)soap_malloc(soap, sizeof(ns1__associateEntityResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__associateEntityResponse *)soap_instantiate_ns1__associateEntityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__associateEntityResponse ** p = (ns1__associateEntityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__associateEntityResponse, sizeof(ns1__associateEntityResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__associateEntity(struct soap *soap, ns1__associateEntity *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__associateEntity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__associateEntity(struct soap *soap, ns1__associateEntity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__associateEntity);
	if (soap_out_PointerTons1__associateEntity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__associateEntity(struct soap *soap, const char *tag, int id, ns1__associateEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__associateEntity);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__associateEntity ** SOAP_FMAC4 soap_get_PointerTons1__associateEntity(struct soap *soap, ns1__associateEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__associateEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__associateEntity ** SOAP_FMAC4 soap_in_PointerTons1__associateEntity(struct soap *soap, const char *tag, ns1__associateEntity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__associateEntity **)soap_malloc(soap, sizeof(ns1__associateEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__associateEntity *)soap_instantiate_ns1__associateEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__associateEntity ** p = (ns1__associateEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__associateEntity, sizeof(ns1__associateEntity), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addEntityResponse(struct soap *soap, ns1__addEntityResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addEntityResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addEntityResponse(struct soap *soap, ns1__addEntityResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addEntityResponse);
	if (soap_out_PointerTons1__addEntityResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addEntityResponse(struct soap *soap, const char *tag, int id, ns1__addEntityResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addEntityResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addEntityResponse ** SOAP_FMAC4 soap_get_PointerTons1__addEntityResponse(struct soap *soap, ns1__addEntityResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addEntityResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__addEntityResponse ** SOAP_FMAC4 soap_in_PointerTons1__addEntityResponse(struct soap *soap, const char *tag, ns1__addEntityResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addEntityResponse **)soap_malloc(soap, sizeof(ns1__addEntityResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addEntityResponse *)soap_instantiate_ns1__addEntityResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addEntityResponse ** p = (ns1__addEntityResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addEntityResponse, sizeof(ns1__addEntityResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__addEntity(struct soap *soap, ns1__addEntity *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__addEntity))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__addEntity(struct soap *soap, ns1__addEntity *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__addEntity);
	if (soap_out_PointerTons1__addEntity(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__addEntity(struct soap *soap, const char *tag, int id, ns1__addEntity *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__addEntity);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__addEntity ** SOAP_FMAC4 soap_get_PointerTons1__addEntity(struct soap *soap, ns1__addEntity **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__addEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__addEntity ** SOAP_FMAC4 soap_in_PointerTons1__addEntity(struct soap *soap, const char *tag, ns1__addEntity **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__addEntity **)soap_malloc(soap, sizeof(ns1__addEntity *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__addEntity *)soap_instantiate_ns1__addEntity(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__addEntity ** p = (ns1__addEntity **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__addEntity, sizeof(ns1__addEntity), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updatePolicyResponse(struct soap *soap, ns1__updatePolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updatePolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updatePolicyResponse(struct soap *soap, ns1__updatePolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updatePolicyResponse);
	if (soap_out_PointerTons1__updatePolicyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updatePolicyResponse(struct soap *soap, const char *tag, int id, ns1__updatePolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updatePolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updatePolicyResponse ** SOAP_FMAC4 soap_get_PointerTons1__updatePolicyResponse(struct soap *soap, ns1__updatePolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updatePolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__updatePolicyResponse ** SOAP_FMAC4 soap_in_PointerTons1__updatePolicyResponse(struct soap *soap, const char *tag, ns1__updatePolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updatePolicyResponse **)soap_malloc(soap, sizeof(ns1__updatePolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updatePolicyResponse *)soap_instantiate_ns1__updatePolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updatePolicyResponse ** p = (ns1__updatePolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updatePolicyResponse, sizeof(ns1__updatePolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updatePolicy(struct soap *soap, ns1__updatePolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updatePolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updatePolicy(struct soap *soap, ns1__updatePolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updatePolicy);
	if (soap_out_PointerTons1__updatePolicy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updatePolicy(struct soap *soap, const char *tag, int id, ns1__updatePolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updatePolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updatePolicy ** SOAP_FMAC4 soap_get_PointerTons1__updatePolicy(struct soap *soap, ns1__updatePolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updatePolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__updatePolicy ** SOAP_FMAC4 soap_in_PointerTons1__updatePolicy(struct soap *soap, const char *tag, ns1__updatePolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updatePolicy **)soap_malloc(soap, sizeof(ns1__updatePolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updatePolicy *)soap_instantiate_ns1__updatePolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updatePolicy ** p = (ns1__updatePolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updatePolicy, sizeof(ns1__updatePolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setPolicyResponse(struct soap *soap, ns1__setPolicyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setPolicyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setPolicyResponse(struct soap *soap, ns1__setPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setPolicyResponse);
	if (soap_out_PointerTons1__setPolicyResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setPolicyResponse(struct soap *soap, const char *tag, int id, ns1__setPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setPolicyResponse ** SOAP_FMAC4 soap_get_PointerTons1__setPolicyResponse(struct soap *soap, ns1__setPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setPolicyResponse ** SOAP_FMAC4 soap_in_PointerTons1__setPolicyResponse(struct soap *soap, const char *tag, ns1__setPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setPolicyResponse **)soap_malloc(soap, sizeof(ns1__setPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setPolicyResponse *)soap_instantiate_ns1__setPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setPolicyResponse ** p = (ns1__setPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setPolicyResponse, sizeof(ns1__setPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__setPolicy(struct soap *soap, ns1__setPolicy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__setPolicy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__setPolicy(struct soap *soap, ns1__setPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__setPolicy);
	if (soap_out_PointerTons1__setPolicy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__setPolicy(struct soap *soap, const char *tag, int id, ns1__setPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__setPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__setPolicy ** SOAP_FMAC4 soap_get_PointerTons1__setPolicy(struct soap *soap, ns1__setPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__setPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__setPolicy ** SOAP_FMAC4 soap_in_PointerTons1__setPolicy(struct soap *soap, const char *tag, ns1__setPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__setPolicy **)soap_malloc(soap, sizeof(ns1__setPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__setPolicy *)soap_instantiate_ns1__setPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__setPolicy ** p = (ns1__setPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__setPolicy, sizeof(ns1__setPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getVersionResponse(struct soap *soap, ns1__getVersionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getVersionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getVersionResponse(struct soap *soap, ns1__getVersionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getVersionResponse);
	if (soap_out_PointerTons1__getVersionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getVersionResponse(struct soap *soap, const char *tag, int id, ns1__getVersionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getVersionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getVersionResponse ** SOAP_FMAC4 soap_get_PointerTons1__getVersionResponse(struct soap *soap, ns1__getVersionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getVersionResponse ** SOAP_FMAC4 soap_in_PointerTons1__getVersionResponse(struct soap *soap, const char *tag, ns1__getVersionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getVersionResponse **)soap_malloc(soap, sizeof(ns1__getVersionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getVersionResponse *)soap_instantiate_ns1__getVersionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getVersionResponse ** p = (ns1__getVersionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVersionResponse, sizeof(ns1__getVersionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__getVersion(struct soap *soap, ns1__getVersion *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__getVersion))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__getVersion(struct soap *soap, ns1__getVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__getVersion);
	if (soap_out_PointerTons1__getVersion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__getVersion(struct soap *soap, const char *tag, int id, ns1__getVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__getVersion);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__getVersion ** SOAP_FMAC4 soap_get_PointerTons1__getVersion(struct soap *soap, ns1__getVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__getVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__getVersion ** SOAP_FMAC4 soap_in_PointerTons1__getVersion(struct soap *soap, const char *tag, ns1__getVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__getVersion **)soap_malloc(soap, sizeof(ns1__getVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__getVersion *)soap_instantiate_ns1__getVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__getVersion ** p = (ns1__getVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__getVersion, sizeof(ns1__getVersion), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Exception(struct soap *soap, ns1__Exception *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Exception))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Exception(struct soap *soap, ns1__Exception *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Exception);
	if (soap_out_PointerTons1__Exception(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Exception(struct soap *soap, const char *tag, int id, ns1__Exception *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Exception);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__Exception ** SOAP_FMAC4 soap_get_PointerTons1__Exception(struct soap *soap, ns1__Exception **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Exception(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__Exception ** SOAP_FMAC4 soap_in_PointerTons1__Exception(struct soap *soap, const char *tag, ns1__Exception **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Exception **)soap_malloc(soap, sizeof(ns1__Exception *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Exception *)soap_instantiate_ns1__Exception(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__Exception ** p = (ns1__Exception **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Exception, sizeof(ns1__Exception), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__historyType(struct soap *soap, enum ns1__historyType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__historyType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__historyType(struct soap *soap, enum ns1__historyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__historyType);
	if (soap_out_PointerTons1__historyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__historyType(struct soap *soap, const char *tag, int id, enum ns1__historyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__historyType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__historyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__historyType ** SOAP_FMAC4 soap_get_PointerTons1__historyType(struct soap *soap, enum ns1__historyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__historyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__historyType ** SOAP_FMAC4 soap_in_PointerTons1__historyType(struct soap *soap, const char *tag, enum ns1__historyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__historyType **)soap_malloc(soap, sizeof(enum ns1__historyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__historyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__historyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__historyType, sizeof(enum ns1__historyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__actionLogType(struct soap *soap, enum ns1__actionLogType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__actionLogType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__actionLogType(struct soap *soap, enum ns1__actionLogType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__actionLogType);
	if (soap_out_PointerTons1__actionLogType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__actionLogType(struct soap *soap, const char *tag, int id, enum ns1__actionLogType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__actionLogType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__actionLogType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__actionLogType ** SOAP_FMAC4 soap_get_PointerTons1__actionLogType(struct soap *soap, enum ns1__actionLogType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__actionLogType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__actionLogType ** SOAP_FMAC4 soap_in_PointerTons1__actionLogType(struct soap *soap, const char *tag, enum ns1__actionLogType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__actionLogType **)soap_malloc(soap, sizeof(enum ns1__actionLogType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__actionLogType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__actionLogType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__actionLogType, sizeof(enum ns1__actionLogType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__policyData(struct soap *soap, ns1__policyData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__policyData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__policyData(struct soap *soap, ns1__policyData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__policyData);
	if (soap_out_PointerTons1__policyData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__policyData(struct soap *soap, const char *tag, int id, ns1__policyData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__policyData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__policyData ** SOAP_FMAC4 soap_get_PointerTons1__policyData(struct soap *soap, ns1__policyData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__policyData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__policyData ** SOAP_FMAC4 soap_in_PointerTons1__policyData(struct soap *soap, const char *tag, ns1__policyData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__policyData **)soap_malloc(soap, sizeof(ns1__policyData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__policyData *)soap_instantiate_ns1__policyData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__policyData ** p = (ns1__policyData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__policyData, sizeof(ns1__policyData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__customEventType(struct soap *soap, enum ns1__customEventType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__customEventType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__customEventType(struct soap *soap, enum ns1__customEventType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__customEventType);
	if (soap_out_PointerTons1__customEventType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__customEventType(struct soap *soap, const char *tag, int id, enum ns1__customEventType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__customEventType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__customEventType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__customEventType ** SOAP_FMAC4 soap_get_PointerTons1__customEventType(struct soap *soap, enum ns1__customEventType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__customEventType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__customEventType ** SOAP_FMAC4 soap_in_PointerTons1__customEventType(struct soap *soap, const char *tag, enum ns1__customEventType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__customEventType **)soap_malloc(soap, sizeof(enum ns1__customEventType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__customEventType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__customEventType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__customEventType, sizeof(enum ns1__customEventType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__conditionOperator(struct soap *soap, enum ns1__conditionOperator *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__conditionOperator);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__conditionOperator(struct soap *soap, enum ns1__conditionOperator *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__conditionOperator);
	if (soap_out_PointerTons1__conditionOperator(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__conditionOperator(struct soap *soap, const char *tag, int id, enum ns1__conditionOperator *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__conditionOperator);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__conditionOperator(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__conditionOperator ** SOAP_FMAC4 soap_get_PointerTons1__conditionOperator(struct soap *soap, enum ns1__conditionOperator **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__conditionOperator(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__conditionOperator ** SOAP_FMAC4 soap_in_PointerTons1__conditionOperator(struct soap *soap, const char *tag, enum ns1__conditionOperator **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__conditionOperator **)soap_malloc(soap, sizeof(enum ns1__conditionOperator *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__conditionOperator(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__conditionOperator **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__conditionOperator, sizeof(enum ns1__conditionOperator), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__customEventData(struct soap *soap, ns1__customEventData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__customEventData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__customEventData(struct soap *soap, ns1__customEventData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__customEventData);
	if (soap_out_PointerTons1__customEventData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__customEventData(struct soap *soap, const char *tag, int id, ns1__customEventData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__customEventData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__customEventData ** SOAP_FMAC4 soap_get_PointerTons1__customEventData(struct soap *soap, ns1__customEventData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__customEventData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__customEventData ** SOAP_FMAC4 soap_in_PointerTons1__customEventData(struct soap *soap, const char *tag, ns1__customEventData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__customEventData **)soap_malloc(soap, sizeof(ns1__customEventData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__customEventData *)soap_instantiate_ns1__customEventData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__customEventData ** p = (ns1__customEventData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__customEventData, sizeof(ns1__customEventData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entityType(struct soap *soap, enum ns1__entityType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__entityType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entityType(struct soap *soap, enum ns1__entityType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__entityType);
	if (soap_out_PointerTons1__entityType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entityType(struct soap *soap, const char *tag, int id, enum ns1__entityType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__entityType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__entityType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__entityType ** SOAP_FMAC4 soap_get_PointerTons1__entityType(struct soap *soap, enum ns1__entityType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__entityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__entityType ** SOAP_FMAC4 soap_in_PointerTons1__entityType(struct soap *soap, const char *tag, enum ns1__entityType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__entityType **)soap_malloc(soap, sizeof(enum ns1__entityType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__entityType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__entityType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__entityType, sizeof(enum ns1__entityType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__metricType(struct soap *soap, enum ns1__metricType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__metricType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__metricType(struct soap *soap, enum ns1__metricType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__metricType);
	if (soap_out_PointerTons1__metricType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__metricType(struct soap *soap, const char *tag, int id, enum ns1__metricType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__metricType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__metricType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__metricType ** SOAP_FMAC4 soap_get_PointerTons1__metricType(struct soap *soap, enum ns1__metricType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__metricType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__metricType ** SOAP_FMAC4 soap_in_PointerTons1__metricType(struct soap *soap, const char *tag, enum ns1__metricType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__metricType **)soap_malloc(soap, sizeof(enum ns1__metricType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__metricType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__metricType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__metricType, sizeof(enum ns1__metricType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__property(struct soap *soap, ns1__property *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__property))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__property(struct soap *soap, ns1__property *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__property);
	if (soap_out_PointerTons1__property(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__property(struct soap *soap, const char *tag, int id, ns1__property *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__property);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__property ** SOAP_FMAC4 soap_get_PointerTons1__property(struct soap *soap, ns1__property **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__property(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__property ** SOAP_FMAC4 soap_in_PointerTons1__property(struct soap *soap, const char *tag, ns1__property **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__property **)soap_malloc(soap, sizeof(ns1__property *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__property *)soap_instantiate_ns1__property(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__property ** p = (ns1__property **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__property, sizeof(ns1__property), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__globalProperty(struct soap *soap, enum ns1__globalProperty *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__globalProperty);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__globalProperty(struct soap *soap, enum ns1__globalProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__globalProperty);
	if (soap_out_PointerTons1__globalProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__globalProperty(struct soap *soap, const char *tag, int id, enum ns1__globalProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__globalProperty);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__globalProperty(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__globalProperty ** SOAP_FMAC4 soap_get_PointerTons1__globalProperty(struct soap *soap, enum ns1__globalProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__globalProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__globalProperty ** SOAP_FMAC4 soap_in_PointerTons1__globalProperty(struct soap *soap, const char *tag, enum ns1__globalProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__globalProperty **)soap_malloc(soap, sizeof(enum ns1__globalProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__globalProperty(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__globalProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__globalProperty, sizeof(enum ns1__globalProperty), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__entityProperty(struct soap *soap, enum ns1__entityProperty *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__entityProperty);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__entityProperty(struct soap *soap, enum ns1__entityProperty *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__entityProperty);
	if (soap_out_PointerTons1__entityProperty(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__entityProperty(struct soap *soap, const char *tag, int id, enum ns1__entityProperty *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__entityProperty);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__entityProperty(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__entityProperty ** SOAP_FMAC4 soap_get_PointerTons1__entityProperty(struct soap *soap, enum ns1__entityProperty **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__entityProperty(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__entityProperty ** SOAP_FMAC4 soap_in_PointerTons1__entityProperty(struct soap *soap, const char *tag, enum ns1__entityProperty **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__entityProperty **)soap_malloc(soap, sizeof(enum ns1__entityProperty *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__entityProperty(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__entityProperty **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__entityProperty, sizeof(enum ns1__entityProperty), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__aggregationPeriod(struct soap *soap, ns1__aggregationPeriod *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__aggregationPeriod))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__aggregationPeriod(struct soap *soap, ns1__aggregationPeriod *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__aggregationPeriod);
	if (soap_out_PointerTons1__aggregationPeriod(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__aggregationPeriod(struct soap *soap, const char *tag, int id, ns1__aggregationPeriod *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__aggregationPeriod);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__aggregationPeriod ** SOAP_FMAC4 soap_get_PointerTons1__aggregationPeriod(struct soap *soap, ns1__aggregationPeriod **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__aggregationPeriod(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__aggregationPeriod ** SOAP_FMAC4 soap_in_PointerTons1__aggregationPeriod(struct soap *soap, const char *tag, ns1__aggregationPeriod **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__aggregationPeriod **)soap_malloc(soap, sizeof(ns1__aggregationPeriod *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__aggregationPeriod *)soap_instantiate_ns1__aggregationPeriod(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__aggregationPeriod ** p = (ns1__aggregationPeriod **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__aggregationPeriod, sizeof(ns1__aggregationPeriod), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__policyType(struct soap *soap, enum ns1__policyType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__policyType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__policyType(struct soap *soap, enum ns1__policyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__policyType);
	if (soap_out_PointerTons1__policyType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__policyType(struct soap *soap, const char *tag, int id, enum ns1__policyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__policyType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__policyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__policyType ** SOAP_FMAC4 soap_get_PointerTons1__policyType(struct soap *soap, enum ns1__policyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__policyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__policyType ** SOAP_FMAC4 soap_in_PointerTons1__policyType(struct soap *soap, const char *tag, enum ns1__policyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__policyType **)soap_malloc(soap, sizeof(enum ns1__policyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__policyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__policyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__policyType, sizeof(enum ns1__policyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ptData(struct soap *soap, ns1__ptData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ptData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ptData(struct soap *soap, ns1__ptData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ptData);
	if (soap_out_PointerTons1__ptData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ptData(struct soap *soap, const char *tag, int id, ns1__ptData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ptData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ptData ** SOAP_FMAC4 soap_get_PointerTons1__ptData(struct soap *soap, ns1__ptData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ptData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__ptData ** SOAP_FMAC4 soap_in_PointerTons1__ptData(struct soap *soap, const char *tag, ns1__ptData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ptData **)soap_malloc(soap, sizeof(ns1__ptData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ptData *)soap_instantiate_ns1__ptData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__ptData ** p = (ns1__ptData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ptData, sizeof(ns1__ptData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__enumerationData(struct soap *soap, ns1__enumerationData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__enumerationData))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__enumerationData(struct soap *soap, ns1__enumerationData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__enumerationData);
	if (soap_out_PointerTons1__enumerationData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__enumerationData(struct soap *soap, const char *tag, int id, ns1__enumerationData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__enumerationData);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__enumerationData ** SOAP_FMAC4 soap_get_PointerTons1__enumerationData(struct soap *soap, ns1__enumerationData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__enumerationData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 ns1__enumerationData ** SOAP_FMAC4 soap_in_PointerTons1__enumerationData(struct soap *soap, const char *tag, ns1__enumerationData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__enumerationData **)soap_malloc(soap, sizeof(ns1__enumerationData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__enumerationData *)soap_instantiate_ns1__enumerationData(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__enumerationData ** p = (ns1__enumerationData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__enumerationData, sizeof(ns1__enumerationData), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__aggregationLevel(struct soap *soap, enum ns1__aggregationLevel *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__aggregationLevel);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__aggregationLevel(struct soap *soap, enum ns1__aggregationLevel *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__aggregationLevel);
	if (soap_out_PointerTons1__aggregationLevel(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__aggregationLevel(struct soap *soap, const char *tag, int id, enum ns1__aggregationLevel *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__aggregationLevel);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__aggregationLevel(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__aggregationLevel ** SOAP_FMAC4 soap_get_PointerTons1__aggregationLevel(struct soap *soap, enum ns1__aggregationLevel **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__aggregationLevel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__aggregationLevel ** SOAP_FMAC4 soap_in_PointerTons1__aggregationLevel(struct soap *soap, const char *tag, enum ns1__aggregationLevel **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__aggregationLevel **)soap_malloc(soap, sizeof(enum ns1__aggregationLevel *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__aggregationLevel(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__aggregationLevel **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__aggregationLevel, sizeof(enum ns1__aggregationLevel), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__queryType(struct soap *soap, enum ns1__queryType *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_ns1__queryType);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__queryType(struct soap *soap, enum ns1__queryType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__queryType);
	if (soap_out_PointerTons1__queryType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__queryType(struct soap *soap, const char *tag, int id, enum ns1__queryType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__queryType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__queryType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__queryType ** SOAP_FMAC4 soap_get_PointerTons1__queryType(struct soap *soap, enum ns1__queryType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__queryType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 enum ns1__queryType ** SOAP_FMAC4 soap_in_PointerTons1__queryType(struct soap *soap, const char *tag, enum ns1__queryType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__queryType **)soap_malloc(soap, sizeof(enum ns1__queryType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__queryType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__queryType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__queryType, sizeof(enum ns1__queryType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfstd__string(struct soap *soap, const std::vector<std::string >*a)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_std__string(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, int id, const std::vector<std::string >*a, const char *type)
{
	for (std::vector<std::string >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_std__string(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string >* SOAP_FMAC4 soap_in_std__vectorTemplateOfstd__string(struct soap *soap, const char *tag, std::vector<std::string >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfstd__string(soap, -1)))
		return NULL;
	std::string n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_std__string(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_std__string, SOAP_TYPE_std__vectorTemplateOfstd__string, sizeof(std::string), 0))
				break;
			if (!soap_in_std__string(soap, tag, NULL, "xsd:string"))
				break;
		}
		else
		{
			if (!soap_in_std__string(soap, tag, &n, "xsd:string"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<std::string > * SOAP_FMAC6 soap_new_std__vectorTemplateOfstd__string(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfstd__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfstd__string(struct soap *soap, std::vector<std::string >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<std::string > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfstd__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfstd__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfstd__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<std::string >;
		if (size)
			*size = sizeof(std::vector<std::string >);
	}
	else
	{	cp->ptr = (void*)new std::vector<std::string >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<std::string >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<std::string >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfstd__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<std::string > %p -> %p\n", q, p));
	*(std::vector<std::string >*)p = *(std::vector<std::string >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__property(struct soap *soap, std::vector<ns1__property * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__property(struct soap *soap, const std::vector<ns1__property * >*a)
{
	for (std::vector<ns1__property * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__property(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__property(struct soap *soap, const char *tag, int id, const std::vector<ns1__property * >*a, const char *type)
{
	for (std::vector<ns1__property * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__property(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__property * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__property(struct soap *soap, const char *tag, std::vector<ns1__property * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__property(soap, -1)))
		return NULL;
	ns1__property *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__property, SOAP_TYPE_std__vectorTemplateOfPointerTons1__property, sizeof(ns1__property), 1))
				break;
			if (!soap_in_PointerTons1__property(soap, tag, NULL, "ns1:property"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__property(soap, tag, &n, "ns1:property"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__property * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__property(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__property(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__property(struct soap *soap, std::vector<ns1__property * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__property * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__property(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__property(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__property, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__property * >;
		if (size)
			*size = sizeof(std::vector<ns1__property * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__property * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__property * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__property * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__property(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__property * > %p -> %p\n", q, p));
	*(std::vector<ns1__property * >*)p = *(std::vector<ns1__property * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, std::vector<enum ns1__predefinedEventType >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, const std::vector<enum ns1__predefinedEventType >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__predefinedEventType >*a, const char *type)
{
	for (std::vector<enum ns1__predefinedEventType >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__predefinedEventType(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__predefinedEventType >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, const char *tag, std::vector<enum ns1__predefinedEventType >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns1__predefinedEventType(soap, -1)))
		return NULL;
	enum ns1__predefinedEventType n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns1__predefinedEventType(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__predefinedEventType, SOAP_TYPE_std__vectorTemplateOfns1__predefinedEventType, sizeof(enum ns1__predefinedEventType), 0))
				break;
			if (!soap_in_ns1__predefinedEventType(soap, tag, NULL, "ns1:predefinedEventType"))
				break;
		}
		else
		{
			if (!soap_in_ns1__predefinedEventType(soap, tag, &n, "ns1:predefinedEventType"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<enum ns1__predefinedEventType > * SOAP_FMAC6 soap_new_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfns1__predefinedEventType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, std::vector<enum ns1__predefinedEventType >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<enum ns1__predefinedEventType > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__predefinedEventType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns1__predefinedEventType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<enum ns1__predefinedEventType >;
		if (size)
			*size = sizeof(std::vector<enum ns1__predefinedEventType >);
	}
	else
	{	cp->ptr = (void*)new std::vector<enum ns1__predefinedEventType >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns1__predefinedEventType >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns1__predefinedEventType >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns1__predefinedEventType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns1__predefinedEventType > %p -> %p\n", q, p));
	*(std::vector<enum ns1__predefinedEventType >*)p = *(std::vector<enum ns1__predefinedEventType >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, std::vector<ns1__aggregationPeriod * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, const std::vector<ns1__aggregationPeriod * >*a)
{
	for (std::vector<ns1__aggregationPeriod * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__aggregationPeriod(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, const char *tag, int id, const std::vector<ns1__aggregationPeriod * >*a, const char *type)
{
	for (std::vector<ns1__aggregationPeriod * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__aggregationPeriod(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__aggregationPeriod * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, const char *tag, std::vector<ns1__aggregationPeriod * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, -1)))
		return NULL;
	ns1__aggregationPeriod *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__aggregationPeriod, SOAP_TYPE_std__vectorTemplateOfPointerTons1__aggregationPeriod, sizeof(ns1__aggregationPeriod), 1))
				break;
			if (!soap_in_PointerTons1__aggregationPeriod(soap, tag, NULL, "ns1:aggregationPeriod"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__aggregationPeriod(soap, tag, &n, "ns1:aggregationPeriod"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__aggregationPeriod * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__aggregationPeriod(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, std::vector<ns1__aggregationPeriod * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__aggregationPeriod * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__aggregationPeriod(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__aggregationPeriod, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__aggregationPeriod * >;
		if (size)
			*size = sizeof(std::vector<ns1__aggregationPeriod * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__aggregationPeriod * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__aggregationPeriod * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__aggregationPeriod * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__aggregationPeriod(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__aggregationPeriod * > %p -> %p\n", q, p));
	*(std::vector<ns1__aggregationPeriod * >*)p = *(std::vector<ns1__aggregationPeriod * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfns1__day(struct soap *soap, std::vector<enum ns1__day >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfns1__day(struct soap *soap, const std::vector<enum ns1__day >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfns1__day(struct soap *soap, const char *tag, int id, const std::vector<enum ns1__day >*a, const char *type)
{
	for (std::vector<enum ns1__day >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_ns1__day(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum ns1__day >* SOAP_FMAC4 soap_in_std__vectorTemplateOfns1__day(struct soap *soap, const char *tag, std::vector<enum ns1__day >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfns1__day(soap, -1)))
		return NULL;
	enum ns1__day n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_ns1__day(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__day, SOAP_TYPE_std__vectorTemplateOfns1__day, sizeof(enum ns1__day), 0))
				break;
			if (!soap_in_ns1__day(soap, tag, NULL, "ns1:day"))
				break;
		}
		else
		{
			if (!soap_in_ns1__day(soap, tag, &n, "ns1:day"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<enum ns1__day > * SOAP_FMAC6 soap_new_std__vectorTemplateOfns1__day(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfns1__day(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfns1__day(struct soap *soap, std::vector<enum ns1__day >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<enum ns1__day > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfns1__day(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfns1__day(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfns1__day, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<enum ns1__day >;
		if (size)
			*size = sizeof(std::vector<enum ns1__day >);
	}
	else
	{	cp->ptr = (void*)new std::vector<enum ns1__day >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<enum ns1__day >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<enum ns1__day >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfns1__day(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<enum ns1__day > %p -> %p\n", q, p));
	*(std::vector<enum ns1__day >*)p = *(std::vector<enum ns1__day >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfint(struct soap *soap, const std::vector<int >*a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfint(struct soap *soap, const char *tag, int id, const std::vector<int >*a, const char *type)
{
	for (std::vector<int >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_int(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<int >* SOAP_FMAC4 soap_in_std__vectorTemplateOfint(struct soap *soap, const char *tag, std::vector<int >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfint(soap, -1)))
		return NULL;
	int n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		soap_default_int(soap, &n);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_int, SOAP_TYPE_std__vectorTemplateOfint, sizeof(int), 0))
				break;
			if (!soap_in_int(soap, tag, NULL, "xsd:int"))
				break;
		}
		else
		{
			if (!soap_in_int(soap, tag, &n, "xsd:int"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<int > * SOAP_FMAC6 soap_new_std__vectorTemplateOfint(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfint(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfint(struct soap *soap, std::vector<int >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<int > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfint(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfint(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfint, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<int >;
		if (size)
			*size = sizeof(std::vector<int >);
	}
	else
	{	cp->ptr = (void*)new std::vector<int >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<int >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<int >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfint(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<int > %p -> %p\n", q, p));
	*(std::vector<int >*)p = *(std::vector<int >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, std::vector<ns1__ptData * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, const std::vector<ns1__ptData * >*a)
{
	for (std::vector<ns1__ptData * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__ptData(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, const char *tag, int id, const std::vector<ns1__ptData * >*a, const char *type)
{
	for (std::vector<ns1__ptData * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__ptData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__ptData * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, const char *tag, std::vector<ns1__ptData * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__ptData(soap, -1)))
		return NULL;
	ns1__ptData *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__ptData, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ptData, sizeof(ns1__ptData), 1))
				break;
			if (!soap_in_PointerTons1__ptData(soap, tag, NULL, "ns1:ptData"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__ptData(soap, tag, &n, "ns1:ptData"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<ns1__ptData * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTons1__ptData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, std::vector<ns1__ptData * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<ns1__ptData * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__ptData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__ptData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<ns1__ptData * >;
		if (size)
			*size = sizeof(std::vector<ns1__ptData * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<ns1__ptData * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__ptData * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__ptData * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__ptData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__ptData * > %p -> %p\n", q, p));
	*(std::vector<ns1__ptData * >*)p = *(std::vector<ns1__ptData * >*)q;
}

/* End of soapC.cpp */
