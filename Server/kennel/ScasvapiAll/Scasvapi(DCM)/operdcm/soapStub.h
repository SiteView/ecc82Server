/* soapStub.h
   Generated by gSOAP 2.7.12 from dcm.h
   Copyright(C) 2000-2008, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__queryType
#define SOAP_TYPE_ns1__queryType (112)
/* ns1:queryType */
enum ns1__queryType {ns1__queryType__MAX_USCOREPWR = 0, ns1__queryType__AVG_USCOREPWR = 1, ns1__queryType__MIN_USCOREPWR = 2, ns1__queryType__TOTAL_USCOREMAX_USCOREPWR = 3, ns1__queryType__TOTAL_USCOREAVG_USCOREPWR = 4, ns1__queryType__TOTAL_USCOREMIN_USCOREPWR = 5, ns1__queryType__MAX_USCOREINLET_USCORETEMP = 6, ns1__queryType__AVG_USCOREINLET_USCORETEMP = 7, ns1__queryType__MIN_USCOREINLET_USCORETEMP = 8};
#endif

#ifndef SOAP_TYPE_ns1__aggregationLevel
#define SOAP_TYPE_ns1__aggregationLevel (113)
/* ns1:aggregationLevel */
enum ns1__aggregationLevel {ns1__aggregationLevel__SELF = 0, ns1__aggregationLevel__NODE = 1, ns1__aggregationLevel__RACK = 2, ns1__aggregationLevel__ROW = 3, ns1__aggregationLevel__ROOM = 4, ns1__aggregationLevel__IMMEDIATE_USCORECHILDREN = 5};
#endif

#ifndef SOAP_TYPE_ns1__policyType
#define SOAP_TYPE_ns1__policyType (114)
/* ns1:policyType */
enum ns1__policyType {ns1__policyType__CUSTOM_USCOREPWR_USCORELIMIT = 0, ns1__policyType__MIN_USCOREPWR = 1, ns1__policyType__MIN_USCOREPWR_USCOREON_USCOREINLET_USCORETEMP_USCORETRIGGER = 2, ns1__policyType__STATIC_USCOREPOWER_USCOREPOLICY = 3};
#endif

#ifndef SOAP_TYPE_ns1__day
#define SOAP_TYPE_ns1__day (115)
/* ns1:day */
enum ns1__day {ns1__day__SUNDAY = 0, ns1__day__MONDAY = 1, ns1__day__TUESDAY = 2, ns1__day__WEDNESDAY = 3, ns1__day__THURSDAY = 4, ns1__day__FRIDAY = 5, ns1__day__SATURDAY = 6};
#endif

#ifndef SOAP_TYPE_ns1__entityProperty
#define SOAP_TYPE_ns1__entityProperty (116)
/* ns1:entityProperty */
enum ns1__entityProperty {ns1__entityProperty__BMC_USCOREADDRESS = 0, ns1__entityProperty__NAME = 1, ns1__entityProperty__DESCRIPTION = 2, ns1__entityProperty__BMC_USCOREUSER = 3, ns1__entityProperty__BMC_USCOREPASSWORD = 4, ns1__entityProperty__BMC_USCOREKEY = 5, ns1__entityProperty__CAPABILITIES = 6, ns1__entityProperty__LOCATION = 7, ns1__entityProperty__DIMENSION = 8, ns1__entityProperty__ENTITY_USCORETYPE = 9, ns1__entityProperty__NAMEPLATE_USCOREPWR = 10, ns1__entityProperty__DERATED_USCOREPWR = 11, ns1__entityProperty__NAMEPLATE_USCOREPWR_USCOREUNMNGD_USCOREEQPMNT = 12, ns1__entityProperty__PDU_USCOREPWR_USCORELIMIT = 13, ns1__entityProperty__NODE_USCORESTATUS = 14};
#endif

#ifndef SOAP_TYPE_ns1__predefinedEventType
#define SOAP_TYPE_ns1__predefinedEventType (117)
/* ns1:predefinedEventType */
enum ns1__predefinedEventType {ns1__predefinedEventType__IPMI_USCOREPWR_USCOREUNIT = 0, ns1__predefinedEventType__IPMI_USCOREPWR_USCORESUPPLY = 1, ns1__predefinedEventType__IPMI_USCOREPROCESSOR_USCORETHERMAL_USCORETRIP = 2, ns1__predefinedEventType__IPMI_USCOREFAN = 3, ns1__predefinedEventType__BMC_USCORESEL_USCOREREACHING_USCOREFULL_USCORECAPACITY = 4, ns1__predefinedEventType__BMC_USCORESEL_USCOREAT_USCOREFULL_USCORECAPACITY = 5, ns1__predefinedEventType__ENTITY_USCOREPROPERTY_USCORECHANGED = 6, ns1__predefinedEventType__COMMUNICATION_USCOREWITH_USCORENODE_USCOREFAILED = 7, ns1__predefinedEventType__COMMUNICATION_USCOREWITH_USCORENODE_USCORERESTORED = 8, ns1__predefinedEventType__INSUFFICIENT_USCORENODE_USCOREPERMISSION = 9, ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCORECANNOT_USCOREBE_USCOREMAINTAINED = 10, ns1__predefinedEventType__CANT_USCORESET_USCORENODE_USCOREEVENT = 11, ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCOREAPPLIED = 12, ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCOREENDED = 13, ns1__predefinedEventType__INTERNAL_USCOREERROR = 14, ns1__predefinedEventType__CONFIGURATION_USCORECHANGED = 15, ns1__predefinedEventType__HIERARCHY_USCORECHANGED = 16, ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCORECHANGED = 17, ns1__predefinedEventType__CUSTOM_USCOREEVENT_USCORECHANGED = 18, ns1__predefinedEventType__CUSTOM_USCOREEVENT_USCOREEVALUATION_USCOREFAILURE = 19, ns1__predefinedEventType__COLLECTION_USCORESTATE_USCORECHANGED = 20, ns1__predefinedEventType__IMPORTHIERARCHY_USCORECOMPLETED = 21, ns1__predefinedEventType__DB_USCOREMAINTENANCE_USCORESTARTING = 22, ns1__predefinedEventType__DB_USCOREMAINTENANCE_USCOREENDED = 23, ns1__predefinedEventType__DB_USCORECONNECTION_USCOREFAILED = 24, ns1__predefinedEventType__DB_USCORECONNECTION_USCORERESTORED = 25, ns1__predefinedEventType__CONTROL_USCOREPOLICY_USCOREPRIORITY_USCORECONFLICT = 26};
#endif

#ifndef SOAP_TYPE_ns1__globalProperty
#define SOAP_TYPE_ns1__globalProperty (118)
/* ns1:globalProperty */
enum ns1__globalProperty {ns1__globalProperty__NODE_USCOREPOWER_USCORESAMPLING_USCOREFREQUENCY = 0, ns1__globalProperty__NODE_USCORETHERMAL_USCORESAMPLING_USCOREFREQUENCY = 1, ns1__globalProperty__ACTION_USCORELOG_USCOREBACK_USCORETRACKING_USCOREPERIOD = 2, ns1__globalProperty__APP_USCORELOG_USCOREMAX_USCORESIZE = 3, ns1__globalProperty__APP_USCORELOG_USCORELEVEL = 4, ns1__globalProperty__COOLING_USCOREMULT = 5, ns1__globalProperty__COST_USCOREPER_USCOREKW_USCOREHR = 6, ns1__globalProperty__TIME_USCOREUNTIL_USCOREDB_USCORECOMPRESSION = 7, ns1__globalProperty__MAX_USCORENUM_USCORERECORDS_USCOREINVOLVED = 8, ns1__globalProperty__TIME_USCOREUNTIL_USCOREDB_USCOREDELETION = 9, ns1__globalProperty__DB_USCOREMAINTENANCE_USCOREHOUR = 10};
#endif

#ifndef SOAP_TYPE_ns1__metricType
#define SOAP_TYPE_ns1__metricType (119)
/* ns1:metricType */
enum ns1__metricType {ns1__metricType__MNGED_USCORENODES_USCOREENERGY = 0, ns1__metricType__MNGED_USCORENODES_USCOREENERGY_USCOREBILL = 1, ns1__metricType__IT_USCOREEQPMNT_USCOREENERGY = 2, ns1__metricType__IT_USCOREEQPMNT_USCOREENERGY_USCOREBILL = 3, ns1__metricType__CALC_USCORECOOLING_USCOREENERGY = 4, ns1__metricType__CALC_USCORECOOLING_USCOREENERGY_USCOREBILL = 5, ns1__metricType__MNGED_USCORENODES_USCOREPWR = 6, ns1__metricType__IT_USCOREEQPMNT_USCOREPWR = 7, ns1__metricType__CALC_USCORECOOLING_USCOREPWR = 8, ns1__metricType__AVG_USCOREPWR_USCOREPER_USCOREDIMENSION = 9, ns1__metricType__DERATED_USCOREPWR = 10};
#endif

#ifndef SOAP_TYPE_ns1__entityType
#define SOAP_TYPE_ns1__entityType (120)
/* ns1:entityType */
enum ns1__entityType {ns1__entityType__NODE = 0, ns1__entityType__RACK = 1, ns1__entityType__ROW = 2, ns1__entityType__ROOM = 3, ns1__entityType__DATACENTER = 4, ns1__entityType__LOGICAL_USCOREGROUP = 5};
#endif

#ifndef SOAP_TYPE_ns1__conditionOperator
#define SOAP_TYPE_ns1__conditionOperator (121)
/* ns1:conditionOperator */
enum ns1__conditionOperator {ns1__conditionOperator__GREATER_USCORETHAN = 0, ns1__conditionOperator__LESS_USCORETHAN = 1};
#endif

#ifndef SOAP_TYPE_ns1__customEventType
#define SOAP_TYPE_ns1__customEventType (122)
/* ns1:customEventType */
enum ns1__customEventType {ns1__customEventType__MAX_USCOREPWR = 0, ns1__customEventType__AVG_USCOREPWR = 1, ns1__customEventType__MIN_USCOREPWR = 2, ns1__customEventType__TOTAL_USCOREMAX_USCOREPWR = 3, ns1__customEventType__TOTAL_USCOREAVG_USCOREPWR = 4, ns1__customEventType__TOTAL_USCOREMIN_USCOREPWR = 5, ns1__customEventType__MAX_USCOREINLET_USCORETEMP = 6, ns1__customEventType__AVG_USCOREINLET_USCORETEMP = 7, ns1__customEventType__MIN_USCOREINLET_USCORETEMP = 8, ns1__customEventType__AVG_USCOREWATTS_USCOREPER_USCOREDIMENSION = 9, ns1__customEventType__AVG_USCORECOOLING_USCOREPWR = 10};
#endif

#ifndef SOAP_TYPE_ns1__actionLogType
#define SOAP_TYPE_ns1__actionLogType (123)
/* ns1:actionLogType */
enum ns1__actionLogType {ns1__actionLogType__ALL = 0, ns1__actionLogType__EVENT_USCORECHANGE = 1, ns1__actionLogType__CONFIGURATION_USCORECHANGE = 2, ns1__actionLogType__HIERARCHY_USCORECHANGE = 3, ns1__actionLogType__CONTROL_USCOREPOLICY_USCORECHANGE = 4, ns1__actionLogType__EXTERNAL_USCOREACTION_USCORESUCCEEDED = 5, ns1__actionLogType__EXTERNAL_USCOREACTION_USCOREFAILED = 6, ns1__actionLogType__SYSTEM_USCORECHANGE = 7, ns1__actionLogType__POLICY_USCOREWARNING = 8, ns1__actionLogType__EVENT = 9};
#endif

#ifndef SOAP_TYPE_ns1__historyType
#define SOAP_TYPE_ns1__historyType (124)
/* ns1:historyType */
enum ns1__historyType {ns1__historyType__POWER_USCORECAP_USCOREREQUESTED = 0, ns1__historyType__POWER_USCORECAP_USCOREACTUAL = 1, ns1__historyType__THERMAL_USCORETRIGGER = 2};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__removePolicy
#define SOAP_TYPE_ns1__removePolicy (9)
/* ns1:removePolicy */
class SOAP_CMAC ns1__removePolicy
{
public:
	int policyId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__removePolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removePolicy() : policyId(0), soap(NULL) { }
	virtual ~ns1__removePolicy() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removePolicyResponse
#define SOAP_TYPE_ns1__removePolicyResponse (10)
/* ns1:removePolicyResponse */
class SOAP_CMAC ns1__removePolicyResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__removePolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removePolicyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__removePolicyResponse() { }
};
#endif

#if 0 /* volatile type: do not redeclare here */

#endif

#ifndef SOAP_TYPE_ns1__Exception
#define SOAP_TYPE_ns1__Exception (11)
/* ns1:Exception */
class SOAP_CMAC ns1__Exception
{
public:
	std::string *message;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__Exception */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Exception() : message(NULL), soap(NULL) { }
	virtual ~ns1__Exception() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getQueryData
#define SOAP_TYPE_ns1__getQueryData (12)
/* ns1:getQueryData */
class SOAP_CMAC ns1__getQueryData
{
public:
	int entityId;	/* required element of type xsd:int */
	enum ns1__queryType *queryType;	/* optional element of type ns1:queryType */
	enum ns1__aggregationLevel *aggregationLevel;	/* optional element of type ns1:aggregationLevel */
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	int aggPeriod;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__getQueryData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getQueryData() : entityId(0), queryType(NULL), aggregationLevel(NULL), startTime(NULL), endTime(NULL), aggPeriod(0), soap(NULL) { }
	virtual ~ns1__getQueryData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getQueryDataResponse
#define SOAP_TYPE_ns1__getQueryDataResponse (13)
/* ns1:getQueryDataResponse */
class SOAP_CMAC ns1__getQueryDataResponse
{
public:
	class ns1__enumerationData *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:enumerationData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__getQueryDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getQueryDataResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getQueryDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumerationData
#define SOAP_TYPE_ns1__enumerationData (14)
/* ns1:enumerationData */
class SOAP_CMAC ns1__enumerationData
{
public:
	int enumerationHandle;	/* required element of type xsd:int */
	time_t *expirationDate;	/* optional element of type xsd:dateTime */
	std::vector<class ns1__ptData * >queryData;	/* optional element of type ns1:ptData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__enumerationData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumerationData() : enumerationHandle(0), expirationDate(NULL), soap(NULL) { }
	virtual ~ns1__enumerationData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ptData
#define SOAP_TYPE_ns1__ptData (15)
/* ns1:ptData */
class SOAP_CMAC ns1__ptData
{
public:
	int entityId;	/* required element of type xsd:int */
	time_t *time;	/* optional element of type xsd:dateTime */
	int value;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__ptData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ptData() : entityId(0), time(NULL), value(0), soap(NULL) { }
	virtual ~ns1__ptData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setPolicy
#define SOAP_TYPE_ns1__setPolicy (16)
/* ns1:setPolicy */
class SOAP_CMAC ns1__setPolicy
{
public:
	int entityId;	/* required element of type xsd:int */
	enum ns1__policyType *policyType;	/* optional element of type ns1:policyType */
	int threshold;	/* required element of type xsd:int */
	std::string *policyDescription;	/* optional element of type xsd:string */
	bool enabled;	/* required element of type xsd:boolean */
	std::vector<int >lowPriorityList;	/* optional element of type xsd:int */
	std::vector<int >highPriorityList;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__setPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setPolicy() : entityId(0), policyType(NULL), threshold(0), policyDescription(NULL), enabled((bool)0), soap(NULL) { }
	virtual ~ns1__setPolicy() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setPolicyResponse
#define SOAP_TYPE_ns1__setPolicyResponse (17)
/* ns1:setPolicyResponse */
class SOAP_CMAC ns1__setPolicyResponse
{
public:
	int return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__setPolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setPolicyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__setPolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__schedulePolicy
#define SOAP_TYPE_ns1__schedulePolicy (18)
/* ns1:schedulePolicy */
class SOAP_CMAC ns1__schedulePolicy
{
public:
	int policyId;	/* required element of type xsd:int */
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	int startHour;	/* required element of type xsd:int */
	int endHour;	/* required element of type xsd:int */
	std::vector<enum ns1__day >days;	/* optional element of type ns1:day */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__schedulePolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__schedulePolicy() : policyId(0), startTime(NULL), endTime(NULL), startHour(0), endHour(0), soap(NULL) { }
	virtual ~ns1__schedulePolicy() { }
};
#endif

#ifndef SOAP_TYPE_ns1__schedulePolicyResponse
#define SOAP_TYPE_ns1__schedulePolicyResponse (19)
/* ns1:schedulePolicyResponse */
class SOAP_CMAC ns1__schedulePolicyResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__schedulePolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__schedulePolicyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__schedulePolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getNextData
#define SOAP_TYPE_ns1__getNextData (20)
/* ns1:getNextData */
class SOAP_CMAC ns1__getNextData
{
public:
	int enumerationHandle;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__getNextData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getNextData() : enumerationHandle(0), soap(NULL) { }
	virtual ~ns1__getNextData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getNextDataResponse
#define SOAP_TYPE_ns1__getNextDataResponse (21)
/* ns1:getNextDataResponse */
class SOAP_CMAC ns1__getNextDataResponse
{
public:
	ns1__enumerationData *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:enumerationData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__getNextDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getNextDataResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getNextDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__importHierarchy
#define SOAP_TYPE_ns1__importHierarchy (22)
/* ns1:importHierarchy */
class SOAP_CMAC ns1__importHierarchy
{
public:
	std::string *filePath;	/* optional element of type xsd:string */
	bool forceAddition;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__importHierarchy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__importHierarchy() : filePath(NULL), forceAddition((bool)0), soap(NULL) { }
	virtual ~ns1__importHierarchy() { }
};
#endif

#ifndef SOAP_TYPE_ns1__importHierarchyResponse
#define SOAP_TYPE_ns1__importHierarchyResponse (23)
/* ns1:importHierarchyResponse */
class SOAP_CMAC ns1__importHierarchyResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__importHierarchyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__importHierarchyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__importHierarchyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__isPolicyActive
#define SOAP_TYPE_ns1__isPolicyActive (24)
/* ns1:isPolicyActive */
class SOAP_CMAC ns1__isPolicyActive
{
public:
	int policyId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__isPolicyActive */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__isPolicyActive() : policyId(0), soap(NULL) { }
	virtual ~ns1__isPolicyActive() { }
};
#endif

#ifndef SOAP_TYPE_ns1__isPolicyActiveResponse
#define SOAP_TYPE_ns1__isPolicyActiveResponse (25)
/* ns1:isPolicyActiveResponse */
class SOAP_CMAC ns1__isPolicyActiveResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__isPolicyActiveResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__isPolicyActiveResponse() : return_((bool)0), soap(NULL) { }
	virtual ~ns1__isPolicyActiveResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getQueryAggregationPeriodList
#define SOAP_TYPE_ns1__getQueryAggregationPeriodList (26)
/* ns1:getQueryAggregationPeriodList */
class SOAP_CMAC ns1__getQueryAggregationPeriodList
{
public:
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	enum ns1__queryType *queryType;	/* optional element of type ns1:queryType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__getQueryAggregationPeriodList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getQueryAggregationPeriodList() : startTime(NULL), endTime(NULL), queryType(NULL), soap(NULL) { }
	virtual ~ns1__getQueryAggregationPeriodList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse
#define SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse (27)
/* ns1:getQueryAggregationPeriodListResponse */
class SOAP_CMAC ns1__getQueryAggregationPeriodListResponse
{
public:
	std::vector<class ns1__aggregationPeriod * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:aggregationPeriod */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__getQueryAggregationPeriodListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getQueryAggregationPeriodListResponse() : soap(NULL) { }
	virtual ~ns1__getQueryAggregationPeriodListResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__aggregationPeriod
#define SOAP_TYPE_ns1__aggregationPeriod (28)
/* ns1:aggregationPeriod */
class SOAP_CMAC ns1__aggregationPeriod
{
public:
	time_t *end;	/* optional element of type xsd:dateTime */
	time_t *start;	/* optional element of type xsd:dateTime */
	int value;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__aggregationPeriod */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__aggregationPeriod() : end(NULL), start(NULL), value(0), soap(NULL) { }
	virtual ~ns1__aggregationPeriod() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumerateEventHandlers
#define SOAP_TYPE_ns1__enumerateEventHandlers (29)
/* ns1:enumerateEventHandlers */
class SOAP_CMAC ns1__enumerateEventHandlers
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__enumerateEventHandlers */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumerateEventHandlers() : soap(NULL) { }
	virtual ~ns1__enumerateEventHandlers() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumerateEventHandlersResponse
#define SOAP_TYPE_ns1__enumerateEventHandlersResponse (30)
/* ns1:enumerateEventHandlersResponse */
class SOAP_CMAC ns1__enumerateEventHandlersResponse
{
public:
	std::vector<int >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__enumerateEventHandlersResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumerateEventHandlersResponse() : soap(NULL) { }
	virtual ~ns1__enumerateEventHandlersResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__exportHierarchy
#define SOAP_TYPE_ns1__exportHierarchy (31)
/* ns1:exportHierarchy */
class SOAP_CMAC ns1__exportHierarchy
{
public:
	std::string *filePath;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__exportHierarchy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__exportHierarchy() : filePath(NULL), soap(NULL) { }
	virtual ~ns1__exportHierarchy() { }
};
#endif

#ifndef SOAP_TYPE_ns1__exportHierarchyResponse
#define SOAP_TYPE_ns1__exportHierarchyResponse (32)
/* ns1:exportHierarchyResponse */
class SOAP_CMAC ns1__exportHierarchyResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__exportHierarchyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__exportHierarchyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__exportHierarchyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findEntities
#define SOAP_TYPE_ns1__findEntities (33)
/* ns1:findEntities */
class SOAP_CMAC ns1__findEntities
{
public:
	enum ns1__entityProperty *property;	/* optional element of type ns1:entityProperty */
	std::string *searchString;	/* optional element of type xsd:string */
	bool fullMatch;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__findEntities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findEntities() : property(NULL), searchString(NULL), fullMatch((bool)0), soap(NULL) { }
	virtual ~ns1__findEntities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__findEntitiesResponse
#define SOAP_TYPE_ns1__findEntitiesResponse (34)
/* ns1:findEntitiesResponse */
class SOAP_CMAC ns1__findEntitiesResponse
{
public:
	std::vector<int >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__findEntitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__findEntitiesResponse() : soap(NULL) { }
	virtual ~ns1__findEntitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getVersion
#define SOAP_TYPE_ns1__getVersion (35)
/* ns1:getVersion */
class SOAP_CMAC ns1__getVersion
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__getVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getVersion() : soap(NULL) { }
	virtual ~ns1__getVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getVersionResponse
#define SOAP_TYPE_ns1__getVersionResponse (36)
/* ns1:getVersionResponse */
class SOAP_CMAC ns1__getVersionResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__getVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getVersionResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__subscribePredefinedEvent
#define SOAP_TYPE_ns1__subscribePredefinedEvent (37)
/* ns1:subscribePredefinedEvent */
class SOAP_CMAC ns1__subscribePredefinedEvent
{
public:
	std::vector<enum ns1__predefinedEventType >eventTypes;	/* optional element of type ns1:predefinedEventType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__subscribePredefinedEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__subscribePredefinedEvent() : soap(NULL) { }
	virtual ~ns1__subscribePredefinedEvent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__subscribePredefinedEventResponse
#define SOAP_TYPE_ns1__subscribePredefinedEventResponse (38)
/* ns1:subscribePredefinedEventResponse */
class SOAP_CMAC ns1__subscribePredefinedEventResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__subscribePredefinedEventResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__subscribePredefinedEventResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__subscribePredefinedEventResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setGlobalProperty
#define SOAP_TYPE_ns1__setGlobalProperty (39)
/* ns1:setGlobalProperty */
class SOAP_CMAC ns1__setGlobalProperty
{
public:
	enum ns1__globalProperty *property;	/* optional element of type ns1:globalProperty */
	std::string *value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__setGlobalProperty */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setGlobalProperty() : property(NULL), value(NULL), soap(NULL) { }
	virtual ~ns1__setGlobalProperty() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setGlobalPropertyResponse
#define SOAP_TYPE_ns1__setGlobalPropertyResponse (40)
/* ns1:setGlobalPropertyResponse */
class SOAP_CMAC ns1__setGlobalPropertyResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__setGlobalPropertyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setGlobalPropertyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__setGlobalPropertyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setCollectionState
#define SOAP_TYPE_ns1__setCollectionState (41)
/* ns1:setCollectionState */
class SOAP_CMAC ns1__setCollectionState
{
public:
	bool suspend;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__setCollectionState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setCollectionState() : suspend((bool)0), soap(NULL) { }
	virtual ~ns1__setCollectionState() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setCollectionStateResponse
#define SOAP_TYPE_ns1__setCollectionStateResponse (42)
/* ns1:setCollectionStateResponse */
class SOAP_CMAC ns1__setCollectionStateResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__setCollectionStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setCollectionStateResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__setCollectionStateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeEntity
#define SOAP_TYPE_ns1__removeEntity (43)
/* ns1:removeEntity */
class SOAP_CMAC ns1__removeEntity
{
public:
	int entityId;	/* required element of type xsd:int */
	bool delCollectedData;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__removeEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeEntity() : entityId(0), delCollectedData((bool)0), soap(NULL) { }
	virtual ~ns1__removeEntity() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeEntityResponse
#define SOAP_TYPE_ns1__removeEntityResponse (44)
/* ns1:removeEntityResponse */
class SOAP_CMAC ns1__removeEntityResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__removeEntityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeEntityResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__removeEntityResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__rediscoverNodeCapabilities
#define SOAP_TYPE_ns1__rediscoverNodeCapabilities (45)
/* ns1:rediscoverNodeCapabilities */
class SOAP_CMAC ns1__rediscoverNodeCapabilities
{
public:
	int entityId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__rediscoverNodeCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__rediscoverNodeCapabilities() : entityId(0), soap(NULL) { }
	virtual ~ns1__rediscoverNodeCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse
#define SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse (46)
/* ns1:rediscoverNodeCapabilitiesResponse */
class SOAP_CMAC ns1__rediscoverNodeCapabilitiesResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__rediscoverNodeCapabilitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__rediscoverNodeCapabilitiesResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__rediscoverNodeCapabilitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updatePolicy
#define SOAP_TYPE_ns1__updatePolicy (47)
/* ns1:updatePolicy */
class SOAP_CMAC ns1__updatePolicy
{
public:
	int policyId;	/* required element of type xsd:int */
	int threshold;	/* required element of type xsd:int */
	std::string *policyDescription;	/* optional element of type xsd:string */
	bool updatePriorityLists;	/* required element of type xsd:boolean */
	std::vector<int >lowPriorityList;	/* optional element of type xsd:int */
	std::vector<int >highPriorityList;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ns1__updatePolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updatePolicy() : policyId(0), threshold(0), policyDescription(NULL), updatePriorityLists((bool)0), soap(NULL) { }
	virtual ~ns1__updatePolicy() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updatePolicyResponse
#define SOAP_TYPE_ns1__updatePolicyResponse (48)
/* ns1:updatePolicyResponse */
class SOAP_CMAC ns1__updatePolicyResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__updatePolicyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updatePolicyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__updatePolicyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getGlobalProperty
#define SOAP_TYPE_ns1__getGlobalProperty (49)
/* ns1:getGlobalProperty */
class SOAP_CMAC ns1__getGlobalProperty
{
public:
	enum ns1__globalProperty *property;	/* optional element of type ns1:globalProperty */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ns1__getGlobalProperty */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getGlobalProperty() : property(NULL), soap(NULL) { }
	virtual ~ns1__getGlobalProperty() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getGlobalPropertyResponse
#define SOAP_TYPE_ns1__getGlobalPropertyResponse (50)
/* ns1:getGlobalPropertyResponse */
class SOAP_CMAC ns1__getGlobalPropertyResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__getGlobalPropertyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getGlobalPropertyResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getGlobalPropertyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__subscribeEventHandler
#define SOAP_TYPE_ns1__subscribeEventHandler (51)
/* ns1:subscribeEventHandler */
class SOAP_CMAC ns1__subscribeEventHandler
{
public:
	std::string *url;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ns1__subscribeEventHandler */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__subscribeEventHandler() : url(NULL), soap(NULL) { }
	virtual ~ns1__subscribeEventHandler() { }
};
#endif

#ifndef SOAP_TYPE_ns1__subscribeEventHandlerResponse
#define SOAP_TYPE_ns1__subscribeEventHandlerResponse (52)
/* ns1:subscribeEventHandlerResponse */
class SOAP_CMAC ns1__subscribeEventHandlerResponse
{
public:
	int return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__subscribeEventHandlerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__subscribeEventHandlerResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__subscribeEventHandlerResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setEventState
#define SOAP_TYPE_ns1__setEventState (53)
/* ns1:setEventState */
class SOAP_CMAC ns1__setEventState
{
public:
	int eventId;	/* required element of type xsd:int */
	bool enable;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__setEventState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setEventState() : eventId(0), enable((bool)0), soap(NULL) { }
	virtual ~ns1__setEventState() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setEventStateResponse
#define SOAP_TYPE_ns1__setEventStateResponse (54)
/* ns1:setEventStateResponse */
class SOAP_CMAC ns1__setEventStateResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ns1__setEventStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setEventStateResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__setEventStateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setEntityProperties
#define SOAP_TYPE_ns1__setEntityProperties (55)
/* ns1:setEntityProperties */
class SOAP_CMAC ns1__setEntityProperties
{
public:
	int entityId;	/* required element of type xsd:int */
	std::vector<class ns1__property * >properties;	/* optional element of type ns1:property */
	bool forceSetting;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__setEntityProperties */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setEntityProperties() : entityId(0), forceSetting((bool)0), soap(NULL) { }
	virtual ~ns1__setEntityProperties() { }
};
#endif

#ifndef SOAP_TYPE_ns1__property
#define SOAP_TYPE_ns1__property (56)
/* ns1:property */
class SOAP_CMAC ns1__property
{
public:
	enum ns1__entityProperty *name;	/* optional element of type ns1:entityProperty */
	std::string *value;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__property */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__property() : name(NULL), value(NULL), soap(NULL) { }
	virtual ~ns1__property() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setEntityPropertiesResponse
#define SOAP_TYPE_ns1__setEntityPropertiesResponse (57)
/* ns1:setEntityPropertiesResponse */
class SOAP_CMAC ns1__setEntityPropertiesResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ns1__setEntityPropertiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setEntityPropertiesResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__setEntityPropertiesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__submitSecretKey
#define SOAP_TYPE_ns1__submitSecretKey (58)
/* ns1:submitSecretKey */
class SOAP_CMAC ns1__submitSecretKey
{
public:
	std::string *base64key;	/* optional element of type xsd:string */
	std::string *algorithm;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__submitSecretKey */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__submitSecretKey() : base64key(NULL), algorithm(NULL), soap(NULL) { }
	virtual ~ns1__submitSecretKey() { }
};
#endif

#ifndef SOAP_TYPE_ns1__submitSecretKeyResponse
#define SOAP_TYPE_ns1__submitSecretKeyResponse (59)
/* ns1:submitSecretKeyResponse */
class SOAP_CMAC ns1__submitSecretKeyResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__submitSecretKeyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__submitSecretKeyResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__submitSecretKeyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeCustomEvent
#define SOAP_TYPE_ns1__removeCustomEvent (60)
/* ns1:removeCustomEvent */
class SOAP_CMAC ns1__removeCustomEvent
{
public:
	int eventId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ns1__removeCustomEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeCustomEvent() : eventId(0), soap(NULL) { }
	virtual ~ns1__removeCustomEvent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__removeCustomEventResponse
#define SOAP_TYPE_ns1__removeCustomEventResponse (61)
/* ns1:removeCustomEventResponse */
class SOAP_CMAC ns1__removeCustomEventResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__removeCustomEventResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__removeCustomEventResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__removeCustomEventResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__disassociateEntity
#define SOAP_TYPE_ns1__disassociateEntity (62)
/* ns1:disassociateEntity */
class SOAP_CMAC ns1__disassociateEntity
{
public:
	int groupId;	/* required element of type xsd:int */
	int entityId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns1__disassociateEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__disassociateEntity() : groupId(0), entityId(0), soap(NULL) { }
	virtual ~ns1__disassociateEntity() { }
};
#endif

#ifndef SOAP_TYPE_ns1__disassociateEntityResponse
#define SOAP_TYPE_ns1__disassociateEntityResponse (63)
/* ns1:disassociateEntityResponse */
class SOAP_CMAC ns1__disassociateEntityResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ns1__disassociateEntityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__disassociateEntityResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__disassociateEntityResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMetricData
#define SOAP_TYPE_ns1__getMetricData (64)
/* ns1:getMetricData */
class SOAP_CMAC ns1__getMetricData
{
public:
	int entityId;	/* required element of type xsd:int */
	enum ns1__metricType *metricType;	/* optional element of type ns1:metricType */
	enum ns1__aggregationLevel *aggregationLevel;	/* optional element of type ns1:aggregationLevel */
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	int aggPeriod;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__getMetricData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMetricData() : entityId(0), metricType(NULL), aggregationLevel(NULL), startTime(NULL), endTime(NULL), aggPeriod(0), soap(NULL) { }
	virtual ~ns1__getMetricData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMetricDataResponse
#define SOAP_TYPE_ns1__getMetricDataResponse (65)
/* ns1:getMetricDataResponse */
class SOAP_CMAC ns1__getMetricDataResponse
{
public:
	ns1__enumerationData *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:enumerationData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns1__getMetricDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMetricDataResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getMetricDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addEntity
#define SOAP_TYPE_ns1__addEntity (66)
/* ns1:addEntity */
class SOAP_CMAC ns1__addEntity
{
public:
	enum ns1__entityType *entityType;	/* optional element of type ns1:entityType */
	std::vector<ns1__property * >properties;	/* optional element of type ns1:property */
	bool forceAddition;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns1__addEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addEntity() : entityType(NULL), forceAddition((bool)0), soap(NULL) { }
	virtual ~ns1__addEntity() { }
};
#endif

#ifndef SOAP_TYPE_ns1__addEntityResponse
#define SOAP_TYPE_ns1__addEntityResponse (67)
/* ns1:addEntityResponse */
class SOAP_CMAC ns1__addEntityResponse
{
public:
	int return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ns1__addEntityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__addEntityResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__addEntityResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getEventHandler
#define SOAP_TYPE_ns1__getEventHandler (68)
/* ns1:getEventHandler */
class SOAP_CMAC ns1__getEventHandler
{
public:
	int handlerId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__getEventHandler */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEventHandler() : handlerId(0), soap(NULL) { }
	virtual ~ns1__getEventHandler() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getEventHandlerResponse
#define SOAP_TYPE_ns1__getEventHandlerResponse (69)
/* ns1:getEventHandlerResponse */
class SOAP_CMAC ns1__getEventHandlerResponse
{
public:
	std::string *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ns1__getEventHandlerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEventHandlerResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getEventHandlerResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCustomEventData
#define SOAP_TYPE_ns1__getCustomEventData (70)
/* ns1:getCustomEventData */
class SOAP_CMAC ns1__getCustomEventData
{
public:
	int eventId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns1__getCustomEventData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCustomEventData() : eventId(0), soap(NULL) { }
	virtual ~ns1__getCustomEventData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCustomEventDataResponse
#define SOAP_TYPE_ns1__getCustomEventDataResponse (71)
/* ns1:getCustomEventDataResponse */
class SOAP_CMAC ns1__getCustomEventDataResponse
{
public:
	class ns1__customEventData *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:customEventData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__getCustomEventDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCustomEventDataResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getCustomEventDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__customEventData
#define SOAP_TYPE_ns1__customEventData (72)
/* ns1:customEventData */
class SOAP_CMAC ns1__customEventData
{
public:
	enum ns1__conditionOperator *conditionOperator;	/* optional element of type ns1:conditionOperator */
	int entityId;	/* required element of type xsd:int */
	int evalPeriod;	/* required element of type xsd:int */
	std::string *eventDescription;	/* optional element of type xsd:string */
	enum ns1__customEventType *eventType;	/* optional element of type ns1:customEventType */
	int threshold;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns1__customEventData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__customEventData() : conditionOperator(NULL), entityId(0), evalPeriod(0), eventDescription(NULL), eventType(NULL), threshold(0), soap(NULL) { }
	virtual ~ns1__customEventData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPredefinedEventTypes
#define SOAP_TYPE_ns1__getPredefinedEventTypes (73)
/* ns1:getPredefinedEventTypes */
class SOAP_CMAC ns1__getPredefinedEventTypes
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ns1__getPredefinedEventTypes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPredefinedEventTypes() : soap(NULL) { }
	virtual ~ns1__getPredefinedEventTypes() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPredefinedEventTypesResponse
#define SOAP_TYPE_ns1__getPredefinedEventTypesResponse (74)
/* ns1:getPredefinedEventTypesResponse */
class SOAP_CMAC ns1__getPredefinedEventTypesResponse
{
public:
	std::vector<enum ns1__predefinedEventType >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:predefinedEventType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns1__getPredefinedEventTypesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPredefinedEventTypesResponse() : soap(NULL) { }
	virtual ~ns1__getPredefinedEventTypesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumerateCustomEvents
#define SOAP_TYPE_ns1__enumerateCustomEvents (75)
/* ns1:enumerateCustomEvents */
class SOAP_CMAC ns1__enumerateCustomEvents
{
public:
	int entityId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ns1__enumerateCustomEvents */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumerateCustomEvents() : entityId(0), soap(NULL) { }
	virtual ~ns1__enumerateCustomEvents() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumerateCustomEventsResponse
#define SOAP_TYPE_ns1__enumerateCustomEventsResponse (76)
/* ns1:enumerateCustomEventsResponse */
class SOAP_CMAC ns1__enumerateCustomEventsResponse
{
public:
	std::vector<int >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns1__enumerateCustomEventsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumerateCustomEventsResponse() : soap(NULL) { }
	virtual ~ns1__enumerateCustomEventsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumeratePolicies
#define SOAP_TYPE_ns1__enumeratePolicies (77)
/* ns1:enumeratePolicies */
class SOAP_CMAC ns1__enumeratePolicies
{
public:
	int entityId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ns1__enumeratePolicies */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumeratePolicies() : entityId(0), soap(NULL) { }
	virtual ~ns1__enumeratePolicies() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumeratePoliciesResponse
#define SOAP_TYPE_ns1__enumeratePoliciesResponse (78)
/* ns1:enumeratePoliciesResponse */
class SOAP_CMAC ns1__enumeratePoliciesResponse
{
public:
	std::vector<int >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns1__enumeratePoliciesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumeratePoliciesResponse() : soap(NULL) { }
	virtual ~ns1__enumeratePoliciesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPolicyState
#define SOAP_TYPE_ns1__getPolicyState (79)
/* ns1:getPolicyState */
class SOAP_CMAC ns1__getPolicyState
{
public:
	int policyId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns1__getPolicyState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPolicyState() : policyId(0), soap(NULL) { }
	virtual ~ns1__getPolicyState() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPolicyStateResponse
#define SOAP_TYPE_ns1__getPolicyStateResponse (80)
/* ns1:getPolicyStateResponse */
class SOAP_CMAC ns1__getPolicyStateResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ns1__getPolicyStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPolicyStateResponse() : return_((bool)0), soap(NULL) { }
	virtual ~ns1__getPolicyStateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateCustomEvent
#define SOAP_TYPE_ns1__updateCustomEvent (81)
/* ns1:updateCustomEvent */
class SOAP_CMAC ns1__updateCustomEvent
{
public:
	int eventId;	/* required element of type xsd:int */
	int threshold;	/* required element of type xsd:int */
	int evalPeriod;	/* required element of type xsd:int */
	std::string *eventDescription;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns1__updateCustomEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateCustomEvent() : eventId(0), threshold(0), evalPeriod(0), eventDescription(NULL), soap(NULL) { }
	virtual ~ns1__updateCustomEvent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateCustomEventResponse
#define SOAP_TYPE_ns1__updateCustomEventResponse (82)
/* ns1:updateCustomEventResponse */
class SOAP_CMAC ns1__updateCustomEventResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ns1__updateCustomEventResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateCustomEventResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__updateCustomEventResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__unsubscribePredefinedEvent
#define SOAP_TYPE_ns1__unsubscribePredefinedEvent (83)
/* ns1:unsubscribePredefinedEvent */
class SOAP_CMAC ns1__unsubscribePredefinedEvent
{
public:
	std::vector<enum ns1__predefinedEventType >eventTypes;	/* optional element of type ns1:predefinedEventType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns1__unsubscribePredefinedEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__unsubscribePredefinedEvent() : soap(NULL) { }
	virtual ~ns1__unsubscribePredefinedEvent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__unsubscribePredefinedEventResponse
#define SOAP_TYPE_ns1__unsubscribePredefinedEventResponse (84)
/* ns1:unsubscribePredefinedEventResponse */
class SOAP_CMAC ns1__unsubscribePredefinedEventResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ns1__unsubscribePredefinedEventResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__unsubscribePredefinedEventResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__unsubscribePredefinedEventResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteSecretKey
#define SOAP_TYPE_ns1__deleteSecretKey (85)
/* ns1:deleteSecretKey */
class SOAP_CMAC ns1__deleteSecretKey
{
public:
	std::string *keyHandle;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns1__deleteSecretKey */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteSecretKey() : keyHandle(NULL), soap(NULL) { }
	virtual ~ns1__deleteSecretKey() { }
};
#endif

#ifndef SOAP_TYPE_ns1__deleteSecretKeyResponse
#define SOAP_TYPE_ns1__deleteSecretKeyResponse (86)
/* ns1:deleteSecretKeyResponse */
class SOAP_CMAC ns1__deleteSecretKeyResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ns1__deleteSecretKeyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__deleteSecretKeyResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__deleteSecretKeyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCollectionState
#define SOAP_TYPE_ns1__getCollectionState (87)
/* ns1:getCollectionState */
class SOAP_CMAC ns1__getCollectionState
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ns1__getCollectionState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCollectionState() : soap(NULL) { }
	virtual ~ns1__getCollectionState() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getCollectionStateResponse
#define SOAP_TYPE_ns1__getCollectionStateResponse (88)
/* ns1:getCollectionStateResponse */
class SOAP_CMAC ns1__getCollectionStateResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ns1__getCollectionStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getCollectionStateResponse() : return_((bool)0), soap(NULL) { }
	virtual ~ns1__getCollectionStateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumerateEntities
#define SOAP_TYPE_ns1__enumerateEntities (89)
/* ns1:enumerateEntities */
class SOAP_CMAC ns1__enumerateEntities
{
public:
	int entityId;	/* required element of type xsd:int */
	enum ns1__entityType *entityType;	/* optional element of type ns1:entityType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ns1__enumerateEntities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumerateEntities() : entityId(0), entityType(NULL), soap(NULL) { }
	virtual ~ns1__enumerateEntities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__enumerateEntitiesResponse
#define SOAP_TYPE_ns1__enumerateEntitiesResponse (90)
/* ns1:enumerateEntitiesResponse */
class SOAP_CMAC ns1__enumerateEntitiesResponse
{
public:
	std::vector<int >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ns1__enumerateEntitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__enumerateEntitiesResponse() : soap(NULL) { }
	virtual ~ns1__enumerateEntitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__defineCustomEvent
#define SOAP_TYPE_ns1__defineCustomEvent (91)
/* ns1:defineCustomEvent */
class SOAP_CMAC ns1__defineCustomEvent
{
public:
	int entityId;	/* required element of type xsd:int */
	enum ns1__customEventType *eventType;	/* optional element of type ns1:customEventType */
	enum ns1__conditionOperator *conditionOperator;	/* optional element of type ns1:conditionOperator */
	int threshold;	/* required element of type xsd:int */
	int evalPeriod;	/* required element of type xsd:int */
	std::string *eventDescription;	/* optional element of type xsd:string */
	bool enabled;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ns1__defineCustomEvent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__defineCustomEvent() : entityId(0), eventType(NULL), conditionOperator(NULL), threshold(0), evalPeriod(0), eventDescription(NULL), enabled((bool)0), soap(NULL) { }
	virtual ~ns1__defineCustomEvent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__defineCustomEventResponse
#define SOAP_TYPE_ns1__defineCustomEventResponse (92)
/* ns1:defineCustomEventResponse */
class SOAP_CMAC ns1__defineCustomEventResponse
{
public:
	int return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns1__defineCustomEventResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__defineCustomEventResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__defineCustomEventResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMetricAggregationPeriodList
#define SOAP_TYPE_ns1__getMetricAggregationPeriodList (93)
/* ns1:getMetricAggregationPeriodList */
class SOAP_CMAC ns1__getMetricAggregationPeriodList
{
public:
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	enum ns1__metricType *metricType;	/* optional element of type ns1:metricType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns1__getMetricAggregationPeriodList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMetricAggregationPeriodList() : startTime(NULL), endTime(NULL), metricType(NULL), soap(NULL) { }
	virtual ~ns1__getMetricAggregationPeriodList() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse
#define SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse (94)
/* ns1:getMetricAggregationPeriodListResponse */
class SOAP_CMAC ns1__getMetricAggregationPeriodListResponse
{
public:
	std::vector<ns1__aggregationPeriod * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:aggregationPeriod */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns1__getMetricAggregationPeriodListResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getMetricAggregationPeriodListResponse() : soap(NULL) { }
	virtual ~ns1__getMetricAggregationPeriodListResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPolicyData
#define SOAP_TYPE_ns1__getPolicyData (95)
/* ns1:getPolicyData */
class SOAP_CMAC ns1__getPolicyData
{
public:
	int policyId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns1__getPolicyData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPolicyData() : policyId(0), soap(NULL) { }
	virtual ~ns1__getPolicyData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPolicyDataResponse
#define SOAP_TYPE_ns1__getPolicyDataResponse (96)
/* ns1:getPolicyDataResponse */
class SOAP_CMAC ns1__getPolicyDataResponse
{
public:
	class ns1__policyData *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:policyData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns1__getPolicyDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPolicyDataResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getPolicyDataResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__policyData
#define SOAP_TYPE_ns1__policyData (97)
/* ns1:policyData */
class SOAP_CMAC ns1__policyData
{
public:
	std::vector<enum ns1__day >days;	/* optional element of type ns1:day */
	int endHour;	/* required element of type xsd:int */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	int entityId;	/* required element of type xsd:int */
	std::vector<int >highPriorityList;	/* optional element of type xsd:int */
	std::vector<int >lowPriorityList;	/* optional element of type xsd:int */
	std::string *policyDescription;	/* optional element of type xsd:string */
	enum ns1__policyType *policyType;	/* optional element of type ns1:policyType */
	int startHour;	/* required element of type xsd:int */
	time_t *startTime;	/* optional element of type xsd:dateTime */
	int threshold;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns1__policyData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__policyData() : endHour(0), endTime(NULL), entityId(0), policyDescription(NULL), policyType(NULL), startHour(0), startTime(NULL), threshold(0), soap(NULL) { }
	virtual ~ns1__policyData() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setPolicyState
#define SOAP_TYPE_ns1__setPolicyState (98)
/* ns1:setPolicyState */
class SOAP_CMAC ns1__setPolicyState
{
public:
	int policyId;	/* required element of type xsd:int */
	bool enable;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns1__setPolicyState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setPolicyState() : policyId(0), enable((bool)0), soap(NULL) { }
	virtual ~ns1__setPolicyState() { }
};
#endif

#ifndef SOAP_TYPE_ns1__setPolicyStateResponse
#define SOAP_TYPE_ns1__setPolicyStateResponse (99)
/* ns1:setPolicyStateResponse */
class SOAP_CMAC ns1__setPolicyStateResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns1__setPolicyStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__setPolicyStateResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__setPolicyStateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getActionLogRecords
#define SOAP_TYPE_ns1__getActionLogRecords (100)
/* ns1:getActionLogRecords */
class SOAP_CMAC ns1__getActionLogRecords
{
public:
	enum ns1__actionLogType *logType;	/* optional element of type ns1:actionLogType */
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns1__getActionLogRecords */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getActionLogRecords() : logType(NULL), startTime(NULL), endTime(NULL), soap(NULL) { }
	virtual ~ns1__getActionLogRecords() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getActionLogRecordsResponse
#define SOAP_TYPE_ns1__getActionLogRecordsResponse (101)
/* ns1:getActionLogRecordsResponse */
class SOAP_CMAC ns1__getActionLogRecordsResponse
{
public:
	std::vector<std::string >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns1__getActionLogRecordsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getActionLogRecordsResponse() : soap(NULL) { }
	virtual ~ns1__getActionLogRecordsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPolicyHistory
#define SOAP_TYPE_ns1__getPolicyHistory (102)
/* ns1:getPolicyHistory */
class SOAP_CMAC ns1__getPolicyHistory
{
public:
	int entityId;	/* required element of type xsd:int */
	enum ns1__historyType *historyType;	/* optional element of type ns1:historyType */
	enum ns1__aggregationLevel *aggregationLevel;	/* optional element of type ns1:aggregationLevel */
	time_t *startTime;	/* optional element of type xsd:dateTime */
	time_t *endTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns1__getPolicyHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPolicyHistory() : entityId(0), historyType(NULL), aggregationLevel(NULL), startTime(NULL), endTime(NULL), soap(NULL) { }
	virtual ~ns1__getPolicyHistory() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getPolicyHistoryResponse
#define SOAP_TYPE_ns1__getPolicyHistoryResponse (103)
/* ns1:getPolicyHistoryResponse */
class SOAP_CMAC ns1__getPolicyHistoryResponse
{
public:
	ns1__enumerationData *return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:enumerationData */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ns1__getPolicyHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getPolicyHistoryResponse() : return_(NULL), soap(NULL) { }
	virtual ~ns1__getPolicyHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__associateEntity
#define SOAP_TYPE_ns1__associateEntity (104)
/* ns1:associateEntity */
class SOAP_CMAC ns1__associateEntity
{
public:
	int groupId;	/* required element of type xsd:int */
	int entityId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns1__associateEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__associateEntity() : groupId(0), entityId(0), soap(NULL) { }
	virtual ~ns1__associateEntity() { }
};
#endif

#ifndef SOAP_TYPE_ns1__associateEntityResponse
#define SOAP_TYPE_ns1__associateEntityResponse (105)
/* ns1:associateEntityResponse */
class SOAP_CMAC ns1__associateEntityResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns1__associateEntityResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__associateEntityResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__associateEntityResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getEventState
#define SOAP_TYPE_ns1__getEventState (106)
/* ns1:getEventState */
class SOAP_CMAC ns1__getEventState
{
public:
	int eventId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns1__getEventState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEventState() : eventId(0), soap(NULL) { }
	virtual ~ns1__getEventState() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getEventStateResponse
#define SOAP_TYPE_ns1__getEventStateResponse (107)
/* ns1:getEventStateResponse */
class SOAP_CMAC ns1__getEventStateResponse
{
public:
	bool return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns1__getEventStateResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEventStateResponse() : return_((bool)0), soap(NULL) { }
	virtual ~ns1__getEventStateResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getEntityProperties
#define SOAP_TYPE_ns1__getEntityProperties (108)
/* ns1:getEntityProperties */
class SOAP_CMAC ns1__getEntityProperties
{
public:
	int entityId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns1__getEntityProperties */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEntityProperties() : entityId(0), soap(NULL) { }
	virtual ~ns1__getEntityProperties() { }
};
#endif

#ifndef SOAP_TYPE_ns1__getEntityPropertiesResponse
#define SOAP_TYPE_ns1__getEntityPropertiesResponse (109)
/* ns1:getEntityPropertiesResponse */
class SOAP_CMAC ns1__getEntityPropertiesResponse
{
public:
	std::vector<ns1__property * >return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:property */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns1__getEntityPropertiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__getEntityPropertiesResponse() : soap(NULL) { }
	virtual ~ns1__getEntityPropertiesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__unsubscribeEventHandler
#define SOAP_TYPE_ns1__unsubscribeEventHandler (110)
/* ns1:unsubscribeEventHandler */
class SOAP_CMAC ns1__unsubscribeEventHandler
{
public:
	int handlerId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns1__unsubscribeEventHandler */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__unsubscribeEventHandler() : handlerId(0), soap(NULL) { }
	virtual ~ns1__unsubscribeEventHandler() { }
};
#endif

#ifndef SOAP_TYPE_ns1__unsubscribeEventHandlerResponse
#define SOAP_TYPE_ns1__unsubscribeEventHandlerResponse (111)
/* ns1:unsubscribeEventHandlerResponse */
class SOAP_CMAC ns1__unsubscribeEventHandlerResponse
{
public:
	char return_;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:byte */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns1__unsubscribeEventHandlerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__unsubscribeEventHandlerResponse() : return_(0), soap(NULL) { }
	virtual ~ns1__unsubscribeEventHandlerResponse() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (155)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	ns1__Exception *ns1__Exception_;	/* optional element of type ns1:Exception */
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE___ns1__getVersion
#define SOAP_TYPE___ns1__getVersion (162)
/* Operation wrapper: */
struct __ns1__getVersion
{
public:
	ns1__getVersion *ns1__getVersion_;	/* optional element of type ns1:getVersion */
};
#endif

#ifndef SOAP_TYPE___ns1__setPolicy
#define SOAP_TYPE___ns1__setPolicy (166)
/* Operation wrapper: */
struct __ns1__setPolicy
{
public:
	ns1__setPolicy *ns1__setPolicy_;	/* optional element of type ns1:setPolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__updatePolicy
#define SOAP_TYPE___ns1__updatePolicy (170)
/* Operation wrapper: */
struct __ns1__updatePolicy
{
public:
	ns1__updatePolicy *ns1__updatePolicy_;	/* optional element of type ns1:updatePolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__addEntity
#define SOAP_TYPE___ns1__addEntity (174)
/* Operation wrapper: */
struct __ns1__addEntity
{
public:
	ns1__addEntity *ns1__addEntity_;	/* optional element of type ns1:addEntity */
};
#endif

#ifndef SOAP_TYPE___ns1__associateEntity
#define SOAP_TYPE___ns1__associateEntity (178)
/* Operation wrapper: */
struct __ns1__associateEntity
{
public:
	ns1__associateEntity *ns1__associateEntity_;	/* optional element of type ns1:associateEntity */
};
#endif

#ifndef SOAP_TYPE___ns1__defineCustomEvent
#define SOAP_TYPE___ns1__defineCustomEvent (182)
/* Operation wrapper: */
struct __ns1__defineCustomEvent
{
public:
	ns1__defineCustomEvent *ns1__defineCustomEvent_;	/* optional element of type ns1:defineCustomEvent */
};
#endif

#ifndef SOAP_TYPE___ns1__deleteSecretKey
#define SOAP_TYPE___ns1__deleteSecretKey (186)
/* Operation wrapper: */
struct __ns1__deleteSecretKey
{
public:
	ns1__deleteSecretKey *ns1__deleteSecretKey_;	/* optional element of type ns1:deleteSecretKey */
};
#endif

#ifndef SOAP_TYPE___ns1__disassociateEntity
#define SOAP_TYPE___ns1__disassociateEntity (190)
/* Operation wrapper: */
struct __ns1__disassociateEntity
{
public:
	ns1__disassociateEntity *ns1__disassociateEntity_;	/* optional element of type ns1:disassociateEntity */
};
#endif

#ifndef SOAP_TYPE___ns1__enumerateCustomEvents
#define SOAP_TYPE___ns1__enumerateCustomEvents (194)
/* Operation wrapper: */
struct __ns1__enumerateCustomEvents
{
public:
	ns1__enumerateCustomEvents *ns1__enumerateCustomEvents_;	/* optional element of type ns1:enumerateCustomEvents */
};
#endif

#ifndef SOAP_TYPE___ns1__enumerateEntities
#define SOAP_TYPE___ns1__enumerateEntities (198)
/* Operation wrapper: */
struct __ns1__enumerateEntities
{
public:
	ns1__enumerateEntities *ns1__enumerateEntities_;	/* optional element of type ns1:enumerateEntities */
};
#endif

#ifndef SOAP_TYPE___ns1__enumerateEventHandlers
#define SOAP_TYPE___ns1__enumerateEventHandlers (202)
/* Operation wrapper: */
struct __ns1__enumerateEventHandlers
{
public:
	ns1__enumerateEventHandlers *ns1__enumerateEventHandlers_;	/* optional element of type ns1:enumerateEventHandlers */
};
#endif

#ifndef SOAP_TYPE___ns1__enumeratePolicies
#define SOAP_TYPE___ns1__enumeratePolicies (206)
/* Operation wrapper: */
struct __ns1__enumeratePolicies
{
public:
	ns1__enumeratePolicies *ns1__enumeratePolicies_;	/* optional element of type ns1:enumeratePolicies */
};
#endif

#ifndef SOAP_TYPE___ns1__exportHierarchy
#define SOAP_TYPE___ns1__exportHierarchy (210)
/* Operation wrapper: */
struct __ns1__exportHierarchy
{
public:
	ns1__exportHierarchy *ns1__exportHierarchy_;	/* optional element of type ns1:exportHierarchy */
};
#endif

#ifndef SOAP_TYPE___ns1__findEntities
#define SOAP_TYPE___ns1__findEntities (214)
/* Operation wrapper: */
struct __ns1__findEntities
{
public:
	ns1__findEntities *ns1__findEntities_;	/* optional element of type ns1:findEntities */
};
#endif

#ifndef SOAP_TYPE___ns1__getActionLogRecords
#define SOAP_TYPE___ns1__getActionLogRecords (218)
/* Operation wrapper: */
struct __ns1__getActionLogRecords
{
public:
	ns1__getActionLogRecords *ns1__getActionLogRecords_;	/* optional element of type ns1:getActionLogRecords */
};
#endif

#ifndef SOAP_TYPE___ns1__getCollectionState
#define SOAP_TYPE___ns1__getCollectionState (222)
/* Operation wrapper: */
struct __ns1__getCollectionState
{
public:
	ns1__getCollectionState *ns1__getCollectionState_;	/* optional element of type ns1:getCollectionState */
};
#endif

#ifndef SOAP_TYPE___ns1__getCustomEventData
#define SOAP_TYPE___ns1__getCustomEventData (226)
/* Operation wrapper: */
struct __ns1__getCustomEventData
{
public:
	ns1__getCustomEventData *ns1__getCustomEventData_;	/* optional element of type ns1:getCustomEventData */
};
#endif

#ifndef SOAP_TYPE___ns1__getEntityProperties
#define SOAP_TYPE___ns1__getEntityProperties (230)
/* Operation wrapper: */
struct __ns1__getEntityProperties
{
public:
	ns1__getEntityProperties *ns1__getEntityProperties_;	/* optional element of type ns1:getEntityProperties */
};
#endif

#ifndef SOAP_TYPE___ns1__getEventHandler
#define SOAP_TYPE___ns1__getEventHandler (234)
/* Operation wrapper: */
struct __ns1__getEventHandler
{
public:
	ns1__getEventHandler *ns1__getEventHandler_;	/* optional element of type ns1:getEventHandler */
};
#endif

#ifndef SOAP_TYPE___ns1__getEventState
#define SOAP_TYPE___ns1__getEventState (238)
/* Operation wrapper: */
struct __ns1__getEventState
{
public:
	ns1__getEventState *ns1__getEventState_;	/* optional element of type ns1:getEventState */
};
#endif

#ifndef SOAP_TYPE___ns1__getGlobalProperty
#define SOAP_TYPE___ns1__getGlobalProperty (242)
/* Operation wrapper: */
struct __ns1__getGlobalProperty
{
public:
	ns1__getGlobalProperty *ns1__getGlobalProperty_;	/* optional element of type ns1:getGlobalProperty */
};
#endif

#ifndef SOAP_TYPE___ns1__getMetricAggregationPeriodList
#define SOAP_TYPE___ns1__getMetricAggregationPeriodList (246)
/* Operation wrapper: */
struct __ns1__getMetricAggregationPeriodList
{
public:
	ns1__getMetricAggregationPeriodList *ns1__getMetricAggregationPeriodList_;	/* optional element of type ns1:getMetricAggregationPeriodList */
};
#endif

#ifndef SOAP_TYPE___ns1__getMetricData
#define SOAP_TYPE___ns1__getMetricData (250)
/* Operation wrapper: */
struct __ns1__getMetricData
{
public:
	ns1__getMetricData *ns1__getMetricData_;	/* optional element of type ns1:getMetricData */
};
#endif

#ifndef SOAP_TYPE___ns1__getNextData
#define SOAP_TYPE___ns1__getNextData (254)
/* Operation wrapper: */
struct __ns1__getNextData
{
public:
	ns1__getNextData *ns1__getNextData_;	/* optional element of type ns1:getNextData */
};
#endif

#ifndef SOAP_TYPE___ns1__getPolicyData
#define SOAP_TYPE___ns1__getPolicyData (258)
/* Operation wrapper: */
struct __ns1__getPolicyData
{
public:
	ns1__getPolicyData *ns1__getPolicyData_;	/* optional element of type ns1:getPolicyData */
};
#endif

#ifndef SOAP_TYPE___ns1__getPolicyHistory
#define SOAP_TYPE___ns1__getPolicyHistory (262)
/* Operation wrapper: */
struct __ns1__getPolicyHistory
{
public:
	ns1__getPolicyHistory *ns1__getPolicyHistory_;	/* optional element of type ns1:getPolicyHistory */
};
#endif

#ifndef SOAP_TYPE___ns1__getPolicyState
#define SOAP_TYPE___ns1__getPolicyState (266)
/* Operation wrapper: */
struct __ns1__getPolicyState
{
public:
	ns1__getPolicyState *ns1__getPolicyState_;	/* optional element of type ns1:getPolicyState */
};
#endif

#ifndef SOAP_TYPE___ns1__getPredefinedEventTypes
#define SOAP_TYPE___ns1__getPredefinedEventTypes (270)
/* Operation wrapper: */
struct __ns1__getPredefinedEventTypes
{
public:
	ns1__getPredefinedEventTypes *ns1__getPredefinedEventTypes_;	/* optional element of type ns1:getPredefinedEventTypes */
};
#endif

#ifndef SOAP_TYPE___ns1__getQueryAggregationPeriodList
#define SOAP_TYPE___ns1__getQueryAggregationPeriodList (274)
/* Operation wrapper: */
struct __ns1__getQueryAggregationPeriodList
{
public:
	ns1__getQueryAggregationPeriodList *ns1__getQueryAggregationPeriodList_;	/* optional element of type ns1:getQueryAggregationPeriodList */
};
#endif

#ifndef SOAP_TYPE___ns1__getQueryData
#define SOAP_TYPE___ns1__getQueryData (278)
/* Operation wrapper: */
struct __ns1__getQueryData
{
public:
	ns1__getQueryData *ns1__getQueryData_;	/* optional element of type ns1:getQueryData */
};
#endif

#ifndef SOAP_TYPE___ns1__importHierarchy
#define SOAP_TYPE___ns1__importHierarchy (282)
/* Operation wrapper: */
struct __ns1__importHierarchy
{
public:
	ns1__importHierarchy *ns1__importHierarchy_;	/* optional element of type ns1:importHierarchy */
};
#endif

#ifndef SOAP_TYPE___ns1__isPolicyActive
#define SOAP_TYPE___ns1__isPolicyActive (286)
/* Operation wrapper: */
struct __ns1__isPolicyActive
{
public:
	ns1__isPolicyActive *ns1__isPolicyActive_;	/* optional element of type ns1:isPolicyActive */
};
#endif

#ifndef SOAP_TYPE___ns1__rediscoverNodeCapabilities
#define SOAP_TYPE___ns1__rediscoverNodeCapabilities (290)
/* Operation wrapper: */
struct __ns1__rediscoverNodeCapabilities
{
public:
	ns1__rediscoverNodeCapabilities *ns1__rediscoverNodeCapabilities_;	/* optional element of type ns1:rediscoverNodeCapabilities */
};
#endif

#ifndef SOAP_TYPE___ns1__removeCustomEvent
#define SOAP_TYPE___ns1__removeCustomEvent (294)
/* Operation wrapper: */
struct __ns1__removeCustomEvent
{
public:
	ns1__removeCustomEvent *ns1__removeCustomEvent_;	/* optional element of type ns1:removeCustomEvent */
};
#endif

#ifndef SOAP_TYPE___ns1__removeEntity
#define SOAP_TYPE___ns1__removeEntity (298)
/* Operation wrapper: */
struct __ns1__removeEntity
{
public:
	ns1__removeEntity *ns1__removeEntity_;	/* optional element of type ns1:removeEntity */
};
#endif

#ifndef SOAP_TYPE___ns1__removePolicy
#define SOAP_TYPE___ns1__removePolicy (302)
/* Operation wrapper: */
struct __ns1__removePolicy
{
public:
	ns1__removePolicy *ns1__removePolicy_;	/* optional element of type ns1:removePolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__schedulePolicy
#define SOAP_TYPE___ns1__schedulePolicy (306)
/* Operation wrapper: */
struct __ns1__schedulePolicy
{
public:
	ns1__schedulePolicy *ns1__schedulePolicy_;	/* optional element of type ns1:schedulePolicy */
};
#endif

#ifndef SOAP_TYPE___ns1__setCollectionState
#define SOAP_TYPE___ns1__setCollectionState (310)
/* Operation wrapper: */
struct __ns1__setCollectionState
{
public:
	ns1__setCollectionState *ns1__setCollectionState_;	/* optional element of type ns1:setCollectionState */
};
#endif

#ifndef SOAP_TYPE___ns1__setEntityProperties
#define SOAP_TYPE___ns1__setEntityProperties (314)
/* Operation wrapper: */
struct __ns1__setEntityProperties
{
public:
	ns1__setEntityProperties *ns1__setEntityProperties_;	/* optional element of type ns1:setEntityProperties */
};
#endif

#ifndef SOAP_TYPE___ns1__setEventState
#define SOAP_TYPE___ns1__setEventState (318)
/* Operation wrapper: */
struct __ns1__setEventState
{
public:
	ns1__setEventState *ns1__setEventState_;	/* optional element of type ns1:setEventState */
};
#endif

#ifndef SOAP_TYPE___ns1__setGlobalProperty
#define SOAP_TYPE___ns1__setGlobalProperty (322)
/* Operation wrapper: */
struct __ns1__setGlobalProperty
{
public:
	ns1__setGlobalProperty *ns1__setGlobalProperty_;	/* optional element of type ns1:setGlobalProperty */
};
#endif

#ifndef SOAP_TYPE___ns1__setPolicyState
#define SOAP_TYPE___ns1__setPolicyState (326)
/* Operation wrapper: */
struct __ns1__setPolicyState
{
public:
	ns1__setPolicyState *ns1__setPolicyState_;	/* optional element of type ns1:setPolicyState */
};
#endif

#ifndef SOAP_TYPE___ns1__submitSecretKey
#define SOAP_TYPE___ns1__submitSecretKey (330)
/* Operation wrapper: */
struct __ns1__submitSecretKey
{
public:
	ns1__submitSecretKey *ns1__submitSecretKey_;	/* optional element of type ns1:submitSecretKey */
};
#endif

#ifndef SOAP_TYPE___ns1__subscribeEventHandler
#define SOAP_TYPE___ns1__subscribeEventHandler (334)
/* Operation wrapper: */
struct __ns1__subscribeEventHandler
{
public:
	ns1__subscribeEventHandler *ns1__subscribeEventHandler_;	/* optional element of type ns1:subscribeEventHandler */
};
#endif

#ifndef SOAP_TYPE___ns1__subscribePredefinedEvent
#define SOAP_TYPE___ns1__subscribePredefinedEvent (338)
/* Operation wrapper: */
struct __ns1__subscribePredefinedEvent
{
public:
	ns1__subscribePredefinedEvent *ns1__subscribePredefinedEvent_;	/* optional element of type ns1:subscribePredefinedEvent */
};
#endif

#ifndef SOAP_TYPE___ns1__unsubscribeEventHandler
#define SOAP_TYPE___ns1__unsubscribeEventHandler (342)
/* Operation wrapper: */
struct __ns1__unsubscribeEventHandler
{
public:
	ns1__unsubscribeEventHandler *ns1__unsubscribeEventHandler_;	/* optional element of type ns1:unsubscribeEventHandler */
};
#endif

#ifndef SOAP_TYPE___ns1__unsubscribePredefinedEvent
#define SOAP_TYPE___ns1__unsubscribePredefinedEvent (346)
/* Operation wrapper: */
struct __ns1__unsubscribePredefinedEvent
{
public:
	ns1__unsubscribePredefinedEvent *ns1__unsubscribePredefinedEvent_;	/* optional element of type ns1:unsubscribePredefinedEvent */
};
#endif

#ifndef SOAP_TYPE___ns1__updateCustomEvent
#define SOAP_TYPE___ns1__updateCustomEvent (350)
/* Operation wrapper: */
struct __ns1__updateCustomEvent
{
public:
	ns1__updateCustomEvent *ns1__updateCustomEvent_;	/* optional element of type ns1:updateCustomEvent */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (351)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (352)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (354)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (355)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (8)
typedef char xsd__byte;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Stubs                                                                      *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getVersion(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getVersion *ns1__getVersion_, ns1__getVersionResponse *ns1__getVersionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setPolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__setPolicy *ns1__setPolicy_, ns1__setPolicyResponse *ns1__setPolicyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updatePolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__updatePolicy *ns1__updatePolicy_, ns1__updatePolicyResponse *ns1__updatePolicyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__addEntity(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__addEntity *ns1__addEntity_, ns1__addEntityResponse *ns1__addEntityResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__associateEntity(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__associateEntity *ns1__associateEntity_, ns1__associateEntityResponse *ns1__associateEntityResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__defineCustomEvent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__defineCustomEvent *ns1__defineCustomEvent_, ns1__defineCustomEventResponse *ns1__defineCustomEventResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__deleteSecretKey(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__deleteSecretKey *ns1__deleteSecretKey_, ns1__deleteSecretKeyResponse *ns1__deleteSecretKeyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__disassociateEntity(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__disassociateEntity *ns1__disassociateEntity_, ns1__disassociateEntityResponse *ns1__disassociateEntityResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__enumerateCustomEvents(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__enumerateCustomEvents *ns1__enumerateCustomEvents_, ns1__enumerateCustomEventsResponse *ns1__enumerateCustomEventsResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__enumerateEntities(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__enumerateEntities *ns1__enumerateEntities_, ns1__enumerateEntitiesResponse *ns1__enumerateEntitiesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__enumerateEventHandlers(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__enumerateEventHandlers *ns1__enumerateEventHandlers_, ns1__enumerateEventHandlersResponse *ns1__enumerateEventHandlersResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__enumeratePolicies(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__enumeratePolicies *ns1__enumeratePolicies_, ns1__enumeratePoliciesResponse *ns1__enumeratePoliciesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__exportHierarchy(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__exportHierarchy *ns1__exportHierarchy_, ns1__exportHierarchyResponse *ns1__exportHierarchyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__findEntities(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__findEntities *ns1__findEntities_, ns1__findEntitiesResponse *ns1__findEntitiesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getActionLogRecords(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getActionLogRecords *ns1__getActionLogRecords_, ns1__getActionLogRecordsResponse *ns1__getActionLogRecordsResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getCollectionState(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getCollectionState *ns1__getCollectionState_, ns1__getCollectionStateResponse *ns1__getCollectionStateResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getCustomEventData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getCustomEventData *ns1__getCustomEventData_, ns1__getCustomEventDataResponse *ns1__getCustomEventDataResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getEntityProperties(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getEntityProperties *ns1__getEntityProperties_, ns1__getEntityPropertiesResponse *ns1__getEntityPropertiesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getEventHandler(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getEventHandler *ns1__getEventHandler_, ns1__getEventHandlerResponse *ns1__getEventHandlerResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getEventState(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getEventState *ns1__getEventState_, ns1__getEventStateResponse *ns1__getEventStateResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getGlobalProperty(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getGlobalProperty *ns1__getGlobalProperty_, ns1__getGlobalPropertyResponse *ns1__getGlobalPropertyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMetricAggregationPeriodList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getMetricAggregationPeriodList *ns1__getMetricAggregationPeriodList_, ns1__getMetricAggregationPeriodListResponse *ns1__getMetricAggregationPeriodListResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getMetricData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getMetricData *ns1__getMetricData_, ns1__getMetricDataResponse *ns1__getMetricDataResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getNextData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getNextData *ns1__getNextData_, ns1__getNextDataResponse *ns1__getNextDataResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPolicyData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getPolicyData *ns1__getPolicyData_, ns1__getPolicyDataResponse *ns1__getPolicyDataResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPolicyHistory(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getPolicyHistory *ns1__getPolicyHistory_, ns1__getPolicyHistoryResponse *ns1__getPolicyHistoryResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPolicyState(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getPolicyState *ns1__getPolicyState_, ns1__getPolicyStateResponse *ns1__getPolicyStateResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getPredefinedEventTypes(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getPredefinedEventTypes *ns1__getPredefinedEventTypes_, ns1__getPredefinedEventTypesResponse *ns1__getPredefinedEventTypesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getQueryAggregationPeriodList(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getQueryAggregationPeriodList *ns1__getQueryAggregationPeriodList_, ns1__getQueryAggregationPeriodListResponse *ns1__getQueryAggregationPeriodListResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__getQueryData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__getQueryData *ns1__getQueryData_, ns1__getQueryDataResponse *ns1__getQueryDataResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__importHierarchy(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__importHierarchy *ns1__importHierarchy_, ns1__importHierarchyResponse *ns1__importHierarchyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__isPolicyActive(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__isPolicyActive *ns1__isPolicyActive_, ns1__isPolicyActiveResponse *ns1__isPolicyActiveResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__rediscoverNodeCapabilities(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__rediscoverNodeCapabilities *ns1__rediscoverNodeCapabilities_, ns1__rediscoverNodeCapabilitiesResponse *ns1__rediscoverNodeCapabilitiesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeCustomEvent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__removeCustomEvent *ns1__removeCustomEvent_, ns1__removeCustomEventResponse *ns1__removeCustomEventResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removeEntity(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__removeEntity *ns1__removeEntity_, ns1__removeEntityResponse *ns1__removeEntityResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__removePolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__removePolicy *ns1__removePolicy_, ns1__removePolicyResponse *ns1__removePolicyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__schedulePolicy(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__schedulePolicy *ns1__schedulePolicy_, ns1__schedulePolicyResponse *ns1__schedulePolicyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setCollectionState(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__setCollectionState *ns1__setCollectionState_, ns1__setCollectionStateResponse *ns1__setCollectionStateResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setEntityProperties(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__setEntityProperties *ns1__setEntityProperties_, ns1__setEntityPropertiesResponse *ns1__setEntityPropertiesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setEventState(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__setEventState *ns1__setEventState_, ns1__setEventStateResponse *ns1__setEventStateResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setGlobalProperty(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__setGlobalProperty *ns1__setGlobalProperty_, ns1__setGlobalPropertyResponse *ns1__setGlobalPropertyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__setPolicyState(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__setPolicyState *ns1__setPolicyState_, ns1__setPolicyStateResponse *ns1__setPolicyStateResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__submitSecretKey(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__submitSecretKey *ns1__submitSecretKey_, ns1__submitSecretKeyResponse *ns1__submitSecretKeyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__subscribeEventHandler(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__subscribeEventHandler *ns1__subscribeEventHandler_, ns1__subscribeEventHandlerResponse *ns1__subscribeEventHandlerResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__subscribePredefinedEvent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__subscribePredefinedEvent *ns1__subscribePredefinedEvent_, ns1__subscribePredefinedEventResponse *ns1__subscribePredefinedEventResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__unsubscribeEventHandler(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__unsubscribeEventHandler *ns1__unsubscribeEventHandler_, ns1__unsubscribeEventHandlerResponse *ns1__unsubscribeEventHandlerResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__unsubscribePredefinedEvent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__unsubscribePredefinedEvent *ns1__unsubscribePredefinedEvent_, ns1__unsubscribePredefinedEventResponse *ns1__unsubscribePredefinedEventResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updateCustomEvent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__updateCustomEvent *ns1__updateCustomEvent_, ns1__updateCustomEventResponse *ns1__updateCustomEventResponse_);

#endif

/* End of soapStub.h */
