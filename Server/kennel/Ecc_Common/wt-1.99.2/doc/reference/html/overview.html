<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Wt: Library overview</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="overview">Library overview</a></h1><h2><a class="anchor" name="wwidget_sec">
1. Wt::WWidget</a></h2>
One of the key classes in Wt is <a class="el" href="classWt_1_1WWidget.html">Wt::WWidget</a>. A WWidget provides abstraction of a visual entity. The entire user-interface is specified by creating a hierarchical structure of WWidgets, starting at the <a class="el" href="classWt_1_1WApplication.html#a5">Wt::WApplication::root()</a>, and letting these widgets respond to events.<p>
When a widget is inserted in the tree, ownership is transferred to the tree. Whenever a widget is deleted, all its children are deleted as well. When the WApplication object is deleted, the root of the tree is deleted, and in this way all resources associated with any widget are freed.<p>
Any descendent class of WWidget is a self-contained class that effectively encapsulates all of its internal complexity.<h3><a class="anchor" name="layout">
1.1 Layout.</a></h3>
The layout of the widgets follows (with a few exceptions) this hierarchical structure. Unlike many other GUI widget frameworks, Wt does not contain layout classes. While useful, they do not map very well to the capabilities of HTML/CSS. Instead, Wt exposes the layout mechanisms built-in HTML/CSS: every WWidget has some control over its own layout in reference to its immediate parent or siblings.<p>
CSS layout considers two important categories of layout. Text-like layout (<a class="el" href="classWt_1_1WWidget.html#a22">inline</a>) flow with sibling <a class="el" href="classWt_1_1WWidget.html#a22">inline </a> widgets in lines, wrapping at the right edge of the parent container. In contrast, <a class="el" href="classWt_1_1WWidget.html#a22">stacked </a> widgets stack vertically with respect to sibling widgets.<h3><a class="anchor" name="style">
1.2 Style.</a></h3>
For visual markup of widgets, the recommended way is to use CSS style sheets. These allow the visual look to be defined seperately from the the rest of the application. The location of the stylesheet may be configured using <a class="el" href="classWt_1_1WApplication.html#a4">Wt::WApplication::useStyleSheet()</a>.<p>
CSS Style selectors may be used in conjunction with widget style classes that may be set for any widget using <a class="el" href="classWt_1_1WWidget.html#a25">Wt::WWidget::setStyleClass()</a>. The recommended way for visual response to events is by changing the style class for the widget.<p>
In addition to configuration using style sheets, Wt also supports inline specification of style, using <a class="el" href="classWt_1_1WWidget.html#a24">Wt::WWidget::decorationStyle()</a>.<h2><a class="anchor" name="application_sec">
2. Wt::WApplication</a></h2>
For every new session (which corresponds to a new user surfing to your web application), a new <a class="el" href="classWt_1_1WApplication.html">Wt::WApplication</a> is created. The WApplication may be used to inspect startup arguments and settings (using <a class="el" href="classWt_1_1WApplication.html#a2">Wt::WApplication::environment()</a>), to set or change the application title (<a class="el" href="classWt_1_1WApplication.html#a7">Wt::WApplication::setTitle()</a>), to specify a character encoding (Wt::WApplication::setCharacterEncoding()) and locale (<a class="el" href="classWt_1_1WApplication.html#a10">Wt::WApplication::setLocale()</a>) for rendering, and other application-wide settings.<p>
An application is exited when the user browses away from the application, or when WApplication::quit() is called. In any case, the entire widget tree is properly deleted, where all resources held by the application may be released.<p>
During the lifetime of a session, the session's WApplication instance is accessible using <a class="el" href="classWt_1_1WApplication.html#e0">Wt::WApplication::instance()</a>.<p>
As of version 2.0.0, the library offers two different mechanisms to map sessions onto processes: <b>dedicated processes</b> and <b>shared processes</b>. The first mechanisms forks a dedicated process for every distinct session. This provides the kernel-level isolation of different sessions, which may be useful for highly security sensitive applications. The second mechanism spawns a number of processes and allocates new sessions randomly to one of these processes. This reduces the danger for DoS attacks, but requires more careful programming as memory corruption affects all sessions in a single process, and sessions are not isolated by any other mechanism but correct programming.<h2><a class="anchor" name="container_sec">
3. Widget containers</a></h2>
With a few exceptions, all widgets are child of (and contained in) a container widget such as <a class="el" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a> or <a class="el" href="classWt_1_1WTableCell.html">Wt::WTableCell</a>. A widget is inserted into a WContainerWidget by adding the widget to the container using <a class="el" href="classWt_1_1WContainerWidget.html#a1">Wt::WContainerWidget::addWidget(WWidget *widget)</a>, or by passing the parent container as an argument to the constructor.<h2><a class="anchor" name="signal_slot">
4. Signal/Slot mechanism</a></h2>
To respond to user-interactivity events, or in general to communicate events from one widget to any other, Wt uses a signal/slot system.<p>
A slot is any method of any descendant of <a class="el" href="classWt_1_1WObject.html">Wt::WObject</a>. To connect a signal with a slot, the only requirement is that the method signature of the slot must be compatible with the signal definition. While in this way every method may be used as a slot, we encourage to explicitly indicate a particular method to be a slot, in the same way as is done in Qt, by putting them in a special section (which improves for example documentation generated using doxygen):<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyWidgetry : <span class="keyword">public</span> Wt::WCompositeWidget
{
<span class="comment">// ...</span>

<span class="keyword">public</span> slots:
  <span class="keywordtype">void</span> doThis();

<span class="keyword">private</span> slots:
  <span class="keywordtype">void</span> doThat(<span class="keywordtype">int</span> count);

  <span class="comment">// ...</span>
};
</pre></div><p>
A signal may be created for an object by instantiating a <a class="el" href="classWt_1_1Signal.html">Wt::Signal</a>&lt;..&gt; class.<p>
While the library defines signals and slots on the various widgets, it is easy and convenient to add signals and slots to widget classes to communicate events and trigger callbacks.<p>
Event signals are special signals that may be triggered internally by the library to respond to user interactivity events. Together, the abstract classes <a class="el" href="classWt_1_1WInteractWidget.html">Wt::WInteractWidget</a> and <a class="el" href="classWt_1_1WFormWidget.html">Wt::WFormWidget</a>, which are baseclasses of many widgets, provide most of these event signals. To react to one of these events, the programmer simply connects a self-defined or already existing slot to the signal.<h2><a class="anchor" name="eventhandling">
5. Server side versus client side event handling.</a></h2>
By default, Wt performs all event processing server-side. Every connected event signal will cause the web browser to communicate with the web server in order to perform the call-back code, and any visual changes will be updated in the web page.<p>
However, Wt may also be told to perform some of the visual processing on the client-side. This may be used for a highly interactive user- interface, because the typical communication delay is avoided. The only way for portable client-side processing is JavaScript. For various reasons, Wt does not expose JavaScript, since it is an error-prone, ill-defined interpreted language that poses various security problems such as cross-site scripting.<p>
Instead, Wt may be told to cache the result of a visual update, as a result of slot call-back code, on the client-side for subsequent calls, or to pre-learn the result of a visual update in advance and store it (as JavaScript) on the client-side. The restriction is that this is only possible for stateless call-back code -- i.e. when the visual update does not depend on state that may change in the course of the application. See the documentation of <a class="el" href="classWt_1_1WObject.html#a10">Wt::WObject::implementStateless</a> for details, or the <a class="el" href="example.html">Treelist example</a> for the use of stateless implementations to create a treelist widget that does all node expansion / collapsing client-side, at least if JavaScript is available.<p>
The stateless slot learning allows applications to be developed entirely in C++, with only one specification of the desired behaviour, and decide at run-time to optimize certain event handling in client-side JavaScript if possible, and fall-back to server-side event handling otherwise.<h2><a class="anchor" name="debugging">
5. Debugging</a></h2>
<h3><a class="anchor" name="gdb">
5.1 gdb (Gnu debugger)</a></h3>
When using the FastCGI connector, the Wt application is spawned by the web server, and one may attach gdb to a running application to perform interactive debugging.<p>
To connect to a running instance, use the following command: <div class="fragment"><pre class="fragment">$ gdb /path/to/your/wt/application &lt;pid&gt; </pre></div> where &lt;pid&gt; is the process of the application, as reported by the web server. In this way you may debug your application after the event loop has started (i.e. just before the first event is handled).<p>
If the application fails before entering the event loop, for example during construction of the first widget tree, you can add a <div class="fragment"><pre class="fragment">sleep(30); </pre></div> statement to your wmain() function, to be able to break right at the start of your program.<h3><a class="anchor" name="valgrind">
5.2 Valgrind</a></h3>
We heartly recommend using <a href="http://valgrind.org">Valgrind</a> to debug Wt applications for memory-related problems or problems caused by reading from unitisialised values. Wt itself has been debugged extensively using this tool. To enable debugging in a Wt application, enable both valgrind and debug support in the Wt configuration file and append a ?debug at the end of your webapp's url. For example, myapp.fcg?debug. The stack trace and other debugging logs will be available in your web server's error_log file. Note that debugging a Wt app will slow it down dramatically, and therefore should be disabled entirely in production installations.<h2><a class="anchor" name="configuration_sec">
6. Configuration</a></h2>
Wt uses an XML configuration file (which by default is located in /etc/wt/wt_config.xml) in which several aspects of application deployment may be configured, on a site-wide or application-specific basis.<p>
<dl>
<dt><b>dedicated-process</b> </dt>
<dd>Every session is mapped a dedicated process, allowing maximal session isolation, but at an increased session cost. </dd>
<dt><b>shared-process</b> </dt>
<dd>Sessions share a fixed number of processes, yielding a lower session cost. </dd>
<dt><b>tracking</b> </dt>
<dd>How session tracking is implemented: automatically (using cookies when available, otherwise using URL rewriting) or strictly using URL rewriting (which is allows multiple concurrent sessions from one user)  </dd>
<dt><b>reload-is-new-session</b> </dt>
<dd>Should a brower reload spawn a new session (convenient for debuggin) or simply refresh (using <a class="el" href="classWt_1_1WApplication.html#a12">Wt::WApplication::refresh()</a>) the current session ? </dd>
<dt><b>timeout</b> </dt>
<dd>The timeout (in seconds) for detecting an idle session. A Wt application uses a keep-alive messages to keep the session alive as long as the user is visiting the page. Increasing this number will result in a longer time between keep-alive message, resulting in a lower server load, but at the same time will detect a dead session with a longer delay. </dd>
<dt><b>max-request-size</b> </dt>
<dd>The maximum HTTP request size (Kb) that is accepted. An oversized request will result in a <a class="el" href="classWt_1_1WApplication.html#o1">Wt::WApplication::requestTooLarge</a> signal.  </dd>
<dt><b>enable-debug</b> </dt>
<dd>When debugging is enabled, appending a debug to the initial query will enable debug information. </dd>
<dt><b>valgrind-path</b> </dt>
<dd>Set the path to valgrind for debugging using valgrind. </dd>
<dt><b>run-directory</b> </dt>
<dd>The path that is used by the library for managing sessions. </dd>
<dt><b>session-id-length</b> </dt>
<dd>The length (in number of characters) for the unique session ID. </dd>
</dl>
<p>
You can now proceed to the <a class="el" href="example.html">Treelist example</a> <hr size="1"><address style="align: right;"><small>Generated on Sat Jan 20 20:29:51 2007 for Wt by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
