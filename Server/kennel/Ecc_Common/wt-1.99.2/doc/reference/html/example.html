<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Wt: Treelist example</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.4 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1><a class="anchor" name="example">Treelist example</a></h1>In this example we will step through the code of the <a href="http://jose.med.kuleuven.be/wt/examples/treelist/demotreelist.fcg" 
>Tree List example</a>. The source code of the entire example is available as leafs of the tree. Note that Wt offers a Tree List widget as part of the library (see <a class="el" href="classWt_1_1WTreeNode.html">Wt::WTreeNode</a>), of which this example is a down-stripped version.<p>
The example in particular demonstrates the use of stateless slot learning to simultaneously implement client-side and server-side event handling in C++.<p>
The tree constructed as hierarchy of tree nodes. A single tree node is implemented in the class TreeNode. TreeNode uses the helper class IconPair for rendering icons that have a state (such as the expand/collapse icons). We start with a walk-over of this class.<h2><a class="anchor" name="stateicon_sec">
IconPair: a pair of icons that reflects state.</a></h2>
For the implementation of the tree list expand/collapse icons, as well as the label icons (such as the folder icon), we use class IconPair. It takes a pair of icons and shows only one at a time. Passing clickIsSwitch = true to the constructor will make the icon react to click events to switch the current icon.<p>
This is the class definition of IconPair:<p>
 <div class="fragment"><pre class="fragment">
<span class="keyword">class </span>IconPair : <span class="keyword">public</span> Wt::WCompositeWidget
{
<span class="keyword">public</span>:
  IconPair(<span class="keyword">const</span> std::string icon1URI, <span class="keyword">const</span> std::string icon2URI,
           <span class="keywordtype">bool</span> clickIsSwitch = <span class="keyword">true</span>, <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a> *parent = 0);

  <span class="keywordtype">void</span> setState(<span class="keywordtype">int</span> num);

  <span class="keywordtype">int</span> state() <span class="keyword">const</span>;

  <a class="code" href="classWt_1_1WImage.html">Wt::WImage</a> *icon1()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> icon1_; }
  
  <a class="code" href="classWt_1_1WImage.html">Wt::WImage</a> *icon2()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> icon2_; }

<span class="keyword">public</span> slots:
  <span class="keywordtype">void</span> showIcon1();

  <span class="keywordtype">void</span> showIcon2();

<span class="keyword">private</span>:
  <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a> *impl_;

  <a class="code" href="classWt_1_1WImage.html">Wt::WImage</a> *icon1_;

  <a class="code" href="classWt_1_1WImage.html">Wt::WImage</a> *icon2_;

<span class="keyword">public</span>:
  <a class="code" href="classWt_1_1EventSignal.html">Wt::EventSignal&lt;Wt::WMouseEvent&gt;</a>&amp; icon1Clicked;

  <a class="code" href="classWt_1_1EventSignal.html">Wt::EventSignal&lt;Wt::WMouseEvent&gt;</a>&amp; icon2Clicked;

<span class="keyword">private</span>:
  <span class="keywordtype">int</span> previousState_;

  <span class="keywordtype">void</span> undoShowIcon1();

  <span class="keywordtype">void</span> undoShowIcon2();
};
</pre></div><p>
IconPair is a composite widget, implemented as a <a class="el" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a> which contains two <a class="el" href="classWt_1_1WImage.html">Wt::WImage</a> objects. The class defines two slots: IconPair::showIcon1() and IconPair::showIcon2(), which show the respective icon, while hiding the other icon.<p>
Although Wt is a C++ (server-side) library, it can also generate client-side JavaScript code for instant visual response. This example will use this capability to implement all of the tree navigation at the client-side for those clients that support JavaScript -- as if it were implemented as a JavaScript library. But since everything is still plain C++ code, it works whatever technology is available or lacking at the client side. Think of a stateless slot implementation as creating a forked implementation, with JavaScript in the client for visual response -- when JavaScript is available, and C++ at the server. When no JavaScript is available, everything happens at the server.<p>
The key concept behind Wt's capability to implement things at the client-side is stateless slot implementations. A stateless slot is, besides a normal C++ function that may be connected to a signal, a C++ function that promises to always have the same behaviour (until it is reset, as we will see later).<p>
This applies to the two functions showIcon1() and showIcon2(), as they simply set the corresponding icon, irrespective of any application state. The library offers two methods for stateless slot implementations: AutoLearned and PreLearned. An AutoLearned stateless slot will only "become client-side" after the first invocation. Applied to our tree widget, this would mean that the first click on any icon would require a round-trip to the server the first time only. An AutoLearned stateless slot simply requires an indication that the particular slot confirms to the contract of being stateless. A PreLearned stateless slot, on the other hand, is "client-side" from the first invocation. To implement a PreLearned stateless however, we need to do some extra work by providing methods that exactly undo the effect of the slot. We provide here two such undo methods: undoShowIcon1() and undoShowIcon2().<p>
Enough talk! Let's look at the implementation, starting with the constructor.<p>
 <div class="fragment"><pre class="fragment">IconPair::IconPair(<span class="keyword">const</span> std::string icon1URI, <span class="keyword">const</span> std::string icon2URI,
                   <span class="keywordtype">bool</span> clickIsSwitch, <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a> *parent)
  : Wt::WCompositeWidget(parent),
    impl_(new Wt::WContainerWidget()),
    icon1_(new Wt::WImage(icon1URI, impl_)),
    icon2_(new Wt::WImage(icon2URI, impl_)),
    icon1Clicked(icon1_-&gt;clicked),
    icon2Clicked(icon2_-&gt;clicked)
{
</pre></div><p>
IconPair inherits from <a class="el" href="classWt_1_1WCompositeWidget.html">Wt::WCompositeWidget</a>. A composite widget is a widget which is composed from other widgets, in a way not exposed in its API. In this way, you may later change the implementation without any problem.<p>
Notice how we constructed three widgets that are used in the implementation: two images (icon1_ and icon2_), and a container (impl_) to hold them. The images are added to the container by passing the container as the last argument in their constructor.<p>
<a class="el" href="classWt_1_1WCompositeWidget.html">Wt::WCompositeWidget</a> requires to set the implementation widget, which is in our case a <a class="el" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a>:<p>
<div class="fragment"><pre class="fragment">  setImplementation(impl_);
</pre></div><p>
We declare the slots showIcon1() and showIcon2() as stateless slots, allowing for client-side optimisation, and offer an undo function which facilitates a PreLearned client-side implementation.<p>
The calls to <a class="el" href="classWt_1_1WObject.html#a10">Wt::WObject::implementStateless()</a> state that the slots showIcon1() and showIcon2() are stateless slots, and their visual effect may be learned in advance. The effect of these statements is merely an optimization. Any non-visual effects of these slots are still propagated and executed, as expected.<p>
<div class="fragment"><pre class="fragment">
  implementStateless(&amp;IconPair::showIcon1, &amp;IconPair::undoShowIcon1);
  implementStateless(&amp;IconPair::showIcon2, &amp;IconPair::undoShowIcon2);
</pre></div><p>
Next, we declare the widget to be an inline widget. An inline widget will be layed out following the natural flow of text (left to right). This does not really matter for our example, since TreeNode will do the layout with a <a class="el" href="classWt_1_1WTable.html">Wt::WTable</a>, but we do so to provide consistency with a <a class="el" href="classWt_1_1WImage.html">Wt::WImage</a> which is also inline by default.<p>
<div class="fragment"><pre class="fragment">  setInline(<span class="keyword">true</span>);
</pre></div><p>
The initial state is to show the first icon:<p>
<div class="fragment"><pre class="fragment">  icon2_-&gt;hide();
</pre></div><p>
To react to click events, we connect signals with slots:<p>
<div class="fragment"><pre class="fragment">
  <span class="keywordflow">if</span> (clickIsSwitch) {
    icon1_-&gt;clicked.connect(SLOT(icon1_, <a class="code" href="classWt_1_1WWidget.html#i0">Wt::WImage::hide</a>));
    icon1_-&gt;clicked.connect(SLOT(icon2_, <a class="code" href="classWt_1_1WWidget.html#i1">Wt::WImage::show</a>));

    icon2_-&gt;clicked.connect(SLOT(icon2_, <a class="code" href="classWt_1_1WWidget.html#i0">Wt::WImage::hide</a>));
    icon2_-&gt;clicked.connect(SLOT(icon1_, <a class="code" href="classWt_1_1WWidget.html#i1">Wt::WImage::show</a>)); <span class="comment">//</span>
</pre></div><p>
We change the cursor to a pointer to hint that clicking these icons may do something useful.<p>
<div class="fragment"><pre class="fragment">
    decorationStyle().setCursor(<a class="code" href="classWt_1_1WCssDecorationStyle.html#w16w3">Wt::WCssDecorationStyle::Pointer</a>);
  }
} <span class="comment">//</span>
</pre></div><p>
We also change the cursor to a pointer to hint that clicking these icons will in fact perform an action.<p>
The rest of the class definition is:<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> IconPair::setState(<span class="keywordtype">int</span> num)
{
  <span class="keywordflow">if</span> (num == 0) {
    icon1_-&gt;show();
    icon2_-&gt;hide();
  } <span class="keywordflow">else</span> {
    icon1_-&gt;hide();
    icon2_-&gt;show();
  }
}

<span class="keywordtype">int</span> IconPair::state()<span class="keyword"> const</span>
<span class="keyword"></span>{
  <span class="keywordflow">return</span> (icon1_-&gt;isHidden() ? 1 : 0);
}

<span class="keywordtype">void</span> IconPair::showIcon1()
{
  previousState_ = (icon1_-&gt;isHidden() ? 1 : 0);
  setState(0);
}

<span class="keywordtype">void</span> IconPair::showIcon2()
{
  previousState_ = (icon1_-&gt;isHidden() ? 1 : 0);
  setState(1);
}

<span class="keywordtype">void</span> IconPair::undoShowIcon1()
{
  setState(previousState_);
}

<span class="keywordtype">void</span> IconPair::undoShowIcon2()
{
  setState(previousState_);
} <span class="comment">//</span>
</pre></div><p>
Note the implementations of undoShowIcon1() and undoShowIcon2(): they simply, but accurately, reset the state to what it was before the respective showIcon1() and showIcon2() calls.<h2><a class="anchor" name="treenode_sec">
TreeNode: an expandable tree node.</a></h2>
TreeNode contains the implementation of the tree, as a hierarchy of tree nodes. The layout of a single node is done using a 2x2 WTable:<p>
<div class="fragment"><pre class="fragment">   |-----------------------|
   | +/- | label           |
   |------------------------
   |     | child1          |
   |     | child2          |
   |     | child3          |
   |     |       ...       |
   |-----------------------| </pre></div><p>
The TreeNode manages a list of child nodes in a WContainerWidget which will be hidden and shown when the node is expanded or collapsed, and children are collapsed when the node is expanded.<p>
This is the TreeNode class definition:<p>
 <div class="fragment"><pre class="fragment"><span class="keyword">class </span>TreeNode : <span class="keyword">public</span> Wt::WCompositeWidget
{
<span class="keyword">public</span>:
  TreeNode(<span class="keyword">const</span> std::wstring labelText,
           <a class="code" href="classWt_1_1WText.html#w2">Wt::WText::Formatting</a> labelFormatting,
           IconPair *labelIcon, <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a> *parent = 0);

  <span class="keywordtype">void</span> addChildNode(TreeNode *node);

  <span class="keywordtype">void</span> removeChildNode(TreeNode *node);

  <span class="keyword">const</span> std::vector&lt;TreeNode *&gt;&amp; childNodes()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> childNodes_; }

<span class="keyword">public</span> slots:
  <span class="keywordtype">void</span> collapse();

  <span class="keywordtype">void</span> expand();

<span class="keyword">private</span>:
  std::vector&lt;TreeNode *&gt; childNodes_;

  TreeNode                 *parentNode_;

  <a class="code" href="classWt_1_1WTable.html">Wt::WTable</a>               *layout_;

  IconPair                 *expandIcon_;

  <a class="code" href="classWt_1_1WImage.html">Wt::WImage</a>               *noExpandIcon_;

  IconPair                 *labelIcon_;

  <a class="code" href="classWt_1_1WText.html">Wt::WText</a>                *labelText_;

  <a class="code" href="classWt_1_1WText.html">Wt::WText</a>                *childCountLabel_;

  <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a>     *expandedContent_;

  <span class="keywordtype">void</span> adjustExpandIcon();

  <span class="keywordtype">bool</span> isLastChildNode() <span class="keyword">const</span>;

  <span class="keywordtype">void</span> childNodesChanged();

  <span class="keywordtype">bool</span> wasCollapsed_;

  <span class="keywordtype">void</span> undoCollapse();

  <span class="keywordtype">void</span> undoExpand();

  <span class="keyword">enum</span> ImageIndex { Middle = 0, Last = 1 };

  <span class="keyword">static</span> std::string imageLine_[];
  <span class="keyword">static</span> std::string imagePlus_[];
  <span class="keyword">static</span> std::string imageMin_[];
}; <span class="comment">//</span>
</pre></div><p>
The public interface of the TreeNode provides methods to manage its children, and two public slots to expand or collapse the node. Remember, a slot is nothing more than a method (and the public slots: does not actually mean anything, except providing a hint to the user of this class that these methods are made to be connected to signals).<p>
We start with the implementation of the constructor:<p>
 <div class="fragment"><pre class="fragment">TreeNode::TreeNode(<span class="keyword">const</span> std::wstring labelText,
                   <a class="code" href="classWt_1_1WText.html#w2">Wt::WText::Formatting</a> labelFormatting,
                   IconPair *labelIcon,
                   <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a> *parent)
  : Wt::WCompositeWidget(parent),
    parentNode_(0),
    labelIcon_(labelIcon)
{
</pre></div><p>
We start with declaring stateless implementations for the slots. It is good practice to do this first, since it must be done before any connections are made to the slots.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// pre-learned stateless implementations ...</span>
  implementStateless(&amp;TreeNode::expand, &amp;TreeNode::undoExpand);
  implementStateless(&amp;TreeNode::collapse, &amp;TreeNode::undoCollapse);
</pre></div><p>
We will implement the treenode as 2 by 2 table.<p>
<div class="fragment"><pre class="fragment">  setImplementation(layout_ = <span class="keyword">new</span> <a class="code" href="classWt_1_1WTable.html">Wt::WTable</a>());
</pre></div><p>
We create all icons. Since currently the node is empty, we only show the no-expand version (which is simply a horizontal line).<p>
<div class="fragment"><pre class="fragment">
  expandIcon_ = <span class="keyword">new</span> IconPair(imagePlus_[Last], imageMin_[Last]);
  expandIcon_-&gt;hide();
  noExpandIcon_ = <span class="keyword">new</span> <a class="code" href="classWt_1_1WImage.html">Wt::WImage</a>(imageLine_[Last]);
</pre></div><p>
The expanded content is a WContainerWidget.<p>
<div class="fragment"><pre class="fragment">
  expandedContent_ = <span class="keyword">new</span> <a class="code" href="classWt_1_1WContainerWidget.html">Wt::WContainerWidget</a>();
  expandedContent_-&gt;hide();
</pre></div><p>
We create the label and child count text widgets:<p>
<div class="fragment"><pre class="fragment">
  labelText_ = <span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html">Wt::WText</a>(labelText);
  labelText_-&gt;setFormatting(labelFormatting);
  labelText_-&gt;setStyleClass(L<span class="stringliteral">"treenodelabel"</span>);
  childCountLabel_ = <span class="keyword">new</span> <a class="code" href="classWt_1_1WText.html">Wt::WText</a>();
  childCountLabel_-&gt;setMargin(<a class="code" href="classWt_1_1WLength.html">Wt::WLength</a>(7), Left);
  childCountLabel_-&gt;setStyleClass(L<span class="stringliteral">"treenodechildcount"</span>);
</pre></div><p>
Now we add all widgets in the proper table cell, and set the correct alignment.<p>
<div class="fragment"><pre class="fragment">
  layout_-&gt;elementAt(0, 0)-&gt;addWidget(expandIcon_);
  layout_-&gt;elementAt(0, 0)-&gt;addWidget(noExpandIcon_);

  <span class="keywordflow">if</span> (labelIcon_) {
    layout_-&gt;elementAt(0, 1)-&gt;addWidget(labelIcon_);
    labelIcon_-&gt;setVerticalAlignment(AlignMiddle);
  }
  layout_-&gt;elementAt(0, 1)-&gt;addWidget(labelText_);
  layout_-&gt;elementAt(0, 1)-&gt;addWidget(childCountLabel_);

  layout_-&gt;elementAt(1, 1)-&gt;addWidget(expandedContent_);

  layout_-&gt;elementAt(0, 0)-&gt;setContentAlignment(AlignTop);
  layout_-&gt;elementAt(0, 1)-&gt;setContentAlignment(AlignMiddle);
</pre></div><p>
Finally, we connect the click events of the expandIcon to the expand and collapse slots.<p>
<div class="fragment"><pre class="fragment">
  expandIcon_-&gt;icon1Clicked.connect(SLOT(<span class="keyword">this</span>, TreeNode::expand));
  expandIcon_-&gt;icon2Clicked.connect(SLOT(<span class="keyword">this</span>, TreeNode::collapse));
} <span class="comment">//</span>
</pre></div><p>
WTable::elementAt(int row, int column) is used repeatedly to add or modify contents of the table cells, expanding the table geometry as needed. Finally, we make connections from the expand and collapse icons to the slots we define in the TreeNode class.<p>
Again, we optimize the visual effect of expand() and collaps() in client-side JavaScript, which is possible since they both have an effect independent of application state. Typically, one will start with a default dynamic slot implementation, and indicate stateless implementations where desired and possible, using one of the two mechanisms of stateless slot learning.<p>
The "business logic" of the TreeNode is simply to manage its children. Whenever a child is added or removed, adjustments to its look are updated by calling childNodesChanged().<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">bool</span> TreeNode::isLastChildNode()<span class="keyword"> const</span>
<span class="keyword"></span>{
  <span class="keywordflow">if</span> (parentNode_) {
    <span class="keywordflow">return</span> parentNode_-&gt;childNodes_.back() == <span class="keyword">this</span>;
  } <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="keywordtype">void</span> TreeNode::addChildNode(TreeNode *node)
{
  childNodes_.push_back(node);
  node-&gt;parentNode_ = <span class="keyword">this</span>;

  expandedContent_-&gt;addWidget(node);

  childNodesChanged();
}

<span class="keywordtype">void</span> TreeNode::removeChildNode(TreeNode *node)
{
  childNodes_.erase(find(childNodes_.begin(), childNodes_.end(), node));

  node-&gt;parentNode_ = 0;

  expandedContent_-&gt;removeWidget(node);

  childNodesChanged();
} <span class="comment">//</span>
</pre></div><p>
The expand icon of the last child is rendered differently, as it needs to terminate the vertical guide line. To keep the implementation simple, we simply let every child reset its proper look by calling adjustExpandIcon().<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> TreeNode::childNodesChanged()
{
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; childNodes_.size(); ++i)
    childNodes_[i]-&gt;adjustExpandIcon();
</pre></div><p>
When getting a first child, or losing the last child, the expand icon changes too.<p>
<div class="fragment"><pre class="fragment">
  adjustExpandIcon();
</pre></div><p>
We also update the childCount label.<p>
<div class="fragment"><pre class="fragment">
  <span class="keywordflow">if</span> (childNodes_.size())
    childCountLabel_
      -&gt;setText(L<span class="stringliteral">"("</span> + boost::lexical_cast&lt;std::wstring&gt;(childNodes_.size())
                + L<span class="stringliteral">")"</span>);
  <span class="keywordflow">else</span>
    childCountLabel_-&gt;setText(L<span class="stringliteral">""</span>);
</pre></div><p>
Finally, we call WObject::resetLearnedSlots(). Because the expand() slot depends on the number of children, because it needs to collapse all children -- this slot is not entirely stateless, breaking the contract for a stateless slot. However, we can get away with still implementing as a stateless slot, by indicating when the state has changed.<p>
<div class="fragment"><pre class="fragment">
  resetLearnedSlots();
} <span class="comment">//</span>
</pre></div><p>
The implementation of the collapse slot is as follows:<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> TreeNode::collapse()
{
</pre></div><p>
First we record the current state, so the undo method can exactly undo what happened.<p>
<div class="fragment"><pre class="fragment">  wasCollapsed_ = expandedContent_-&gt;isHidden();
</pre></div><p>
Next, we implement the actual collapse logic:<p>
<div class="fragment"><pre class="fragment">
  expandIcon_-&gt;setState(0);
  expandedContent_-&gt;hide();
  <span class="keywordflow">if</span> (labelIcon_)
    labelIcon_-&gt;setState(0);
} <span class="comment">//</span>
</pre></div><p>
Similarly, the implementation of the expand slot. However, in this case we need to collapse all children as well.<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> TreeNode::expand()
{
  wasCollapsed_ = expandedContent_-&gt;isHidden();

  expandIcon_-&gt;setState(1);
  expandedContent_-&gt;show();
  <span class="keywordflow">if</span> (labelIcon_)
    labelIcon_-&gt;setState(1);

  <span class="comment">/*</span>
<span class="comment">   * collapse all children</span>
<span class="comment">   */</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; childNodes_.size(); ++i)
    childNodes_[i]-&gt;collapse();
} <span class="comment">//</span>
</pre></div><p>
Since we implement these slots as prelearned stateless slots, we also need to define the undo functions. Note that Because expand() also collapses all child nodes, the undo function of expand() is not simply collapse() and vice-versa.<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> TreeNode::undoCollapse()
{
  <span class="keywordflow">if</span> (!wasCollapsed_) {
    <span class="comment">// re-expand</span>
    expandIcon_-&gt;setState(1);
    expandedContent_-&gt;show();
    <span class="keywordflow">if</span> (labelIcon_)
      labelIcon_-&gt;setState(1);    
  }
}

<span class="keywordtype">void</span> TreeNode::undoExpand()
{
  <span class="keywordflow">if</span> (wasCollapsed_) {
    <span class="comment">// re-collapse</span>
    expandIcon_-&gt;setState(0);
    expandedContent_-&gt;hide();
    <span class="keywordflow">if</span> (labelIcon_)
      labelIcon_-&gt;setState(0);
  }

  <span class="comment">/*</span>
<span class="comment">   * undo collapse of children</span>
<span class="comment">   */</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; childNodes_.size(); ++i)
    childNodes_[i]-&gt;undoCollapse();  
} <span class="comment">//</span>
</pre></div><p>
Finally, the adjustExpandIcon() function sets the correct images, which depends on how the node relates to its siblings. The last node looks a bit different.<p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> TreeNode::adjustExpandIcon()
{
</pre></div><p>
We set the expand icon images:<p>
<div class="fragment"><pre class="fragment">  ImageIndex index = isLastChildNode() ? Last : Middle;

  <span class="keywordflow">if</span> (expandIcon_-&gt;icon1()-&gt;imageRef() != imagePlus_[index])
    expandIcon_-&gt;icon1()-&gt;setImageRef(imagePlus_[index]);
  <span class="keywordflow">if</span> (expandIcon_-&gt;icon2()-&gt;imageRef() != imageMin_[index])
    expandIcon_-&gt;icon2()-&gt;setImageRef(imageMin_[index]);
  <span class="keywordflow">if</span> (noExpandIcon_-&gt;imageRef() != imageLine_[index])
    noExpandIcon_-&gt;setImageRef(imageLine_[index]);
</pre></div><p>
Then, we set the vertical guide line if not the last child, and nothing if the last child:<p>
<div class="fragment"><pre class="fragment">
  <span class="keywordflow">if</span> (index == Last) {
    layout_-&gt;elementAt(0, 0)
      -&gt;decorationStyle().setBackgroundImage(<span class="stringliteral">""</span>);
    layout_-&gt;elementAt(1, 0)
      -&gt;decorationStyle().setBackgroundImage(<span class="stringliteral">""</span>);
  } <span class="keywordflow">else</span> {
    layout_-&gt;elementAt(0, 0)
      -&gt;decorationStyle().setBackgroundImage(<span class="stringliteral">"icons/line-trunk.gif"</span>,
                                             <a class="code" href="classWt_1_1WCssDecorationStyle.html#w17w10">Wt::WCssDecorationStyle::RepeatY</a>);
    layout_-&gt;elementAt(1, 0)
      -&gt;decorationStyle().setBackgroundImage(<span class="stringliteral">"icons/line-trunk.gif"</span>,
                                             <a class="code" href="classWt_1_1WCssDecorationStyle.html#w17w10">Wt::WCssDecorationStyle::RepeatY</a>);
  } <span class="comment">//</span>
</pre></div><p>
Finally, we select the correct icon, depending on whether the node has children:<p>
<div class="fragment"><pre class="fragment">
  <span class="keywordflow">if</span> (childNodes_.empty()) {
    <span class="keywordflow">if</span> (noExpandIcon_-&gt;isHidden()) {
      noExpandIcon_-&gt;show();
      expandIcon_-&gt;hide();
    }
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">if</span> (expandIcon_-&gt;isHidden()) {
      noExpandIcon_-&gt;hide();
      expandIcon_-&gt;show();
    }
  }
} <span class="comment">//</span>
</pre></div><p>
And that's it. By using the TreeNode class in a hierarchy, we can create a tree widget. The tree widget will be implemented entirely in JavaScript, if available, and otherwise as plain HTML. In any case, client-side and server-side state are completely synchronized, and identical by definition since they are derived from the same C++ code.<p>
You can now proceed to <a class="el" href="Installation.html">Installation</a> <hr size="1"><address style="align: right;"><small>Generated on Sat Jan 20 20:29:51 2007 for Wt by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.4 </small></address>
</body>
</html>
